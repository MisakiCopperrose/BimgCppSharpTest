// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace Bgfx
{
    namespace Bx
    {
        public unsafe partial class AllocatorI
        {
            public partial struct __Internal
            {
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bx.AllocatorI> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bx.AllocatorI>();

            protected bool __ownsNativeInstance;

            internal static AllocatorI __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new AllocatorI(native.ToPointer(), skipVTables);
            }

            internal static AllocatorI __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (AllocatorI)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static AllocatorI __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AllocatorI(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private AllocatorI(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AllocatorI(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }
        }
    }

    namespace Bgfx
    {
        /// <summary>Memory release callback.</summary>
        /// <remarks>
        /// <para>param[in] _ptr Pointer to allocated data.</para>
        /// <para>param[in] _userData User defined data if needed.</para>
        /// <para>C99's equivalent binding is `bgfx_release_fn_t`.</para>
        /// </remarks>
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void ReleaseFn(__IntPtr _ptr, __IntPtr _userData);

        /// <summary>View id.</summary>
        /// <summary>Fatal error enum.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_fatal_t`.</remarks>
        public unsafe partial class Fatal : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx5FatalC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public enum Enum : uint
            {
                DebugCheck = 0,
                InvalidShader = 1,
                UnableToInitialize = 2,
                UnableToCreateTexture = 3,
                DeviceLost = 4,
                Count = 5
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Fatal> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Fatal>();

            protected bool __ownsNativeInstance;

            internal static Fatal __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Fatal(native.ToPointer(), skipVTables);
            }

            internal static Fatal __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Fatal)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Fatal __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Fatal(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Fatal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Fatal(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Fatal()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Fatal.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Fatal(global::Bgfx.Bgfx.Fatal _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Fatal.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.Fatal.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Fatal.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>Renderer backend type enum.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_renderer_type_t`.</remarks>
        public unsafe partial class RendererType : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx12RendererTypeC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            /// <summary>Renderer types:</summary>
            public enum Enum : uint
            {
                /// <summary>No rendering.</summary>
                Noop = 0,
                /// <summary>AGC</summary>
                Agc = 1,
                /// <summary>Direct3D 9.0</summary>
                Direct3D9 = 2,
                /// <summary>Direct3D 11.0</summary>
                Direct3D11 = 3,
                /// <summary>Direct3D 12.0</summary>
                Direct3D12 = 4,
                /// <summary>GNM</summary>
                Gnm = 5,
                /// <summary>Metal</summary>
                Metal = 6,
                /// <summary>NVN</summary>
                Nvn = 7,
                /// <summary>OpenGL ES 2.0+</summary>
                OpenGLES = 8,
                /// <summary>OpenGL 2.1+</summary>
                OpenGL = 9,
                /// <summary>Vulkan</summary>
                Vulkan = 10,
                /// <summary>WebGPU</summary>
                WebGPU = 11,
                Count = 12
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.RendererType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.RendererType>();

            protected bool __ownsNativeInstance;

            internal static RendererType __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new RendererType(native.ToPointer(), skipVTables);
            }

            internal static RendererType __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (RendererType)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static RendererType __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new RendererType(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private RendererType(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected RendererType(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public RendererType()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.RendererType.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public RendererType(global::Bgfx.Bgfx.RendererType _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.RendererType.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.RendererType.__Internal*) __Instance) = *((global::Bgfx.Bgfx.RendererType.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>Access mode enum.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_access_t`.</remarks>
        public unsafe partial class Access : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx6AccessC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            /// <summary>Access:</summary>
            public enum Enum : uint
            {
                /// <summary>Read</summary>
                Read = 0,
                /// <summary>Write</summary>
                Write = 1,
                /// <summary>Read and write</summary>
                ReadWrite = 2,
                Count = 3
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Access> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Access>();

            protected bool __ownsNativeInstance;

            internal static Access __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Access(native.ToPointer(), skipVTables);
            }

            internal static Access __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Access)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Access __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Access(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Access(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Access(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Access()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Access.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Access(global::Bgfx.Bgfx.Access _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Access.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.Access.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Access.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>Vertex attribute enum.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_attrib_t`.</remarks>
        public unsafe partial class Attrib : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx6AttribC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            /// <summary>Corresponds to vertex shader attribute.</summary>
            public enum Enum : uint
            {
                /// <summary>a_position</summary>
                Position = 0,
                /// <summary>a_normal</summary>
                Normal = 1,
                /// <summary>a_tangent</summary>
                Tangent = 2,
                /// <summary>a_bitangent</summary>
                Bitangent = 3,
                /// <summary>a_color0</summary>
                Color0 = 4,
                /// <summary>a_color1</summary>
                Color1 = 5,
                /// <summary>a_color2</summary>
                Color2 = 6,
                /// <summary>a_color3</summary>
                Color3 = 7,
                /// <summary>a_indices</summary>
                Indices = 8,
                /// <summary>a_weight</summary>
                Weight = 9,
                /// <summary>a_texcoord0</summary>
                TexCoord0 = 10,
                /// <summary>a_texcoord1</summary>
                TexCoord1 = 11,
                /// <summary>a_texcoord2</summary>
                TexCoord2 = 12,
                /// <summary>a_texcoord3</summary>
                TexCoord3 = 13,
                /// <summary>a_texcoord4</summary>
                TexCoord4 = 14,
                /// <summary>a_texcoord5</summary>
                TexCoord5 = 15,
                /// <summary>a_texcoord6</summary>
                TexCoord6 = 16,
                /// <summary>a_texcoord7</summary>
                TexCoord7 = 17,
                Count = 18
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Attrib> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Attrib>();

            protected bool __ownsNativeInstance;

            internal static Attrib __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Attrib(native.ToPointer(), skipVTables);
            }

            internal static Attrib __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Attrib)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Attrib __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Attrib(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Attrib(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Attrib(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Attrib()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Attrib.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Attrib(global::Bgfx.Bgfx.Attrib _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Attrib.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.Attrib.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Attrib.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>Vertex attribute type enum.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_attrib_type_t`.</remarks>
        public unsafe partial class AttribType : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx10AttribTypeC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            /// <summary>Attribute types:</summary>
            public enum Enum : uint
            {
                /// <summary>Uint8</summary>
                Uint8 = 0,
                /// <summary>Uint10, availability depends on: `BGFX_CAPS_VERTEX_ATTRIB_UINT10`.</summary>
                Uint10 = 1,
                /// <summary>Int16</summary>
                Int16 = 2,
                /// <summary>Half, availability depends on: `BGFX_CAPS_VERTEX_ATTRIB_HALF`.</summary>
                Half = 3,
                /// <summary>Float</summary>
                Float = 4,
                Count = 5
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.AttribType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.AttribType>();

            protected bool __ownsNativeInstance;

            internal static AttribType __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new AttribType(native.ToPointer(), skipVTables);
            }

            internal static AttribType __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (AttribType)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static AttribType __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new AttribType(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private AttribType(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected AttribType(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public AttribType()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.AttribType.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public AttribType(global::Bgfx.Bgfx.AttribType _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.AttribType.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.AttribType.__Internal*) __Instance) = *((global::Bgfx.Bgfx.AttribType.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>Texture format enum.</summary>
        /// <remarks>
        /// <para>Notation:</para>
        /// <para>RGBA16S</para>
        /// <para>^   ^ ^</para>
        /// <para>|   | +-- [ ]Unorm</para>
        /// <para>|   |     [F]loat</para>
        /// <para>|   |     [S]norm</para>
        /// <para>|   |     [I]nt</para>
        /// <para>|   |     [U]int</para>
        /// <para>|   +---- Number of bits per component</para>
        /// <para>+-------- Components</para>
        /// <para>Availability depends on Caps (see: formats).</para>
        /// <para>C99's equivalent binding is `bgfx_texture_format_t`.</para>
        /// </remarks>
        public unsafe partial class TextureFormat : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx13TextureFormatC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            /// <summary>Texture formats:</summary>
            public enum Enum : uint
            {
                /// <summary>DXT1 R5G6B5A1</summary>
                BC1 = 0,
                /// <summary>DXT3 R5G6B5A4</summary>
                BC2 = 1,
                /// <summary>DXT5 R5G6B5A8</summary>
                BC3 = 2,
                /// <summary>LATC1/ATI1 R8</summary>
                BC4 = 3,
                /// <summary>LATC2/ATI2 RG8</summary>
                BC5 = 4,
                /// <summary>BC6H RGB16F</summary>
                BC6H = 5,
                /// <summary>BC7 RGB 4-7 bits per color channel, 0-8 bits alpha</summary>
                BC7 = 6,
                /// <summary>ETC1 RGB8</summary>
                ETC1 = 7,
                /// <summary>ETC2 RGB8</summary>
                ETC2 = 8,
                /// <summary>ETC2 RGBA8</summary>
                ETC2A = 9,
                /// <summary>ETC2 RGB8A1</summary>
                ETC2A1 = 10,
                /// <summary>PVRTC1 RGB 2BPP</summary>
                PTC12 = 11,
                /// <summary>PVRTC1 RGB 4BPP</summary>
                PTC14 = 12,
                /// <summary>PVRTC1 RGBA 2BPP</summary>
                PTC12A = 13,
                /// <summary>PVRTC1 RGBA 4BPP</summary>
                PTC14A = 14,
                /// <summary>PVRTC2 RGBA 2BPP</summary>
                PTC22 = 15,
                /// <summary>PVRTC2 RGBA 4BPP</summary>
                PTC24 = 16,
                /// <summary>ATC RGB 4BPP</summary>
                ATC = 17,
                /// <summary>ATCE RGBA 8 BPP explicit alpha</summary>
                ATCE = 18,
                /// <summary>ATCI RGBA 8 BPP interpolated alpha</summary>
                ATCI = 19,
                /// <summary>ASTC 4x4 8.0 BPP</summary>
                ASTC4x4 = 20,
                /// <summary>ASTC 5x5 5.12 BPP</summary>
                ASTC5x5 = 21,
                /// <summary>ASTC 6x6 3.56 BPP</summary>
                ASTC6x6 = 22,
                /// <summary>ASTC 8x5 3.20 BPP</summary>
                ASTC8x5 = 23,
                /// <summary>ASTC 8x6 2.67 BPP</summary>
                ASTC8x6 = 24,
                /// <summary>ASTC 10x5 2.56 BPP</summary>
                ASTC10x5 = 0x19,
                Unknown = 26,
                R1 = 27,
                A8 = 28,
                R8 = 29,
                R8I = 30,
                R8U = 31,
                R8S = 32,
                R16 = 33,
                R16I = 34,
                R16U = 35,
                R16F = 36,
                R16S = 37,
                R32I = 38,
                R32U = 39,
                R32F = 40,
                RG8 = 41,
                RG8I = 42,
                RG8U = 43,
                RG8S = 44,
                RG16 = 45,
                RG16I = 46,
                RG16U = 47,
                RG16F = 48,
                RG16S = 49,
                RG32I = 50,
                RG32U = 51,
                RG32F = 52,
                RGB8 = 53,
                RGB8I = 54,
                RGB8U = 55,
                RGB8S = 56,
                RGB9E5F = 57,
                BGRA8 = 58,
                RGBA8 = 59,
                RGBA8I = 60,
                RGBA8U = 61,
                RGBA8S = 62,
                RGBA16 = 63,
                RGBA16I = 64,
                RGBA16U = 65,
                RGBA16F = 66,
                RGBA16S = 67,
                RGBA32I = 68,
                RGBA32U = 69,
                RGBA32F = 70,
                R5G6B5 = 71,
                RGBA4 = 72,
                RGB5A1 = 73,
                RGB10A2 = 74,
                RG11B10F = 75,
                UnknownDepth = 76,
                D16 = 77,
                D24 = 78,
                D24S8 = 79,
                D32 = 80,
                D16F = 81,
                D24F = 82,
                D32F = 83,
                D0S8 = 84,
                Count = 85
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.TextureFormat> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.TextureFormat>();

            protected bool __ownsNativeInstance;

            internal static TextureFormat __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new TextureFormat(native.ToPointer(), skipVTables);
            }

            internal static TextureFormat __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (TextureFormat)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static TextureFormat __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TextureFormat(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private TextureFormat(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TextureFormat(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public TextureFormat()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.TextureFormat.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public TextureFormat(global::Bgfx.Bgfx.TextureFormat _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.TextureFormat.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.TextureFormat.__Internal*) __Instance) = *((global::Bgfx.Bgfx.TextureFormat.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>Uniform type enum.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_uniform_type_t`.</remarks>
        public unsafe partial class UniformType : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx11UniformTypeC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            /// <summary>Uniform types:</summary>
            public enum Enum : uint
            {
                /// <summary>Sampler.</summary>
                Sampler = 0,
                /// <summary>Reserved, do not use.</summary>
                End = 1,
                /// <summary>4 floats vector.</summary>
                Vec4 = 2,
                /// <summary>3x3 matrix.</summary>
                Mat3 = 3,
                /// <summary>4x4 matrix.</summary>
                Mat4 = 4,
                Count = 5
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.UniformType> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.UniformType>();

            protected bool __ownsNativeInstance;

            internal static UniformType __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new UniformType(native.ToPointer(), skipVTables);
            }

            internal static UniformType __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (UniformType)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static UniformType __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new UniformType(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private UniformType(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected UniformType(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public UniformType()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.UniformType.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public UniformType(global::Bgfx.Bgfx.UniformType _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.UniformType.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.UniformType.__Internal*) __Instance) = *((global::Bgfx.Bgfx.UniformType.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>Backbuffer ratio enum.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_backbuffer_ratio_t`.</remarks>
        public unsafe partial class BackbufferRatio : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx15BackbufferRatioC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            /// <summary>Backbuffer ratios:</summary>
            public enum Enum : uint
            {
                /// <summary>Equal to backbuffer.</summary>
                Equal = 0,
                /// <summary>One half size of backbuffer.</summary>
                Half = 1,
                /// <summary>One quarter size of backbuffer.</summary>
                Quarter = 2,
                /// <summary>One eighth size of backbuffer.</summary>
                Eighth = 3,
                /// <summary>One sixteenth size of backbuffer.</summary>
                Sixteenth = 4,
                /// <summary>Double size of backbuffer.</summary>
                Double = 5,
                Count = 6
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.BackbufferRatio> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.BackbufferRatio>();

            protected bool __ownsNativeInstance;

            internal static BackbufferRatio __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new BackbufferRatio(native.ToPointer(), skipVTables);
            }

            internal static BackbufferRatio __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (BackbufferRatio)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static BackbufferRatio __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new BackbufferRatio(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private BackbufferRatio(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected BackbufferRatio(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public BackbufferRatio()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.BackbufferRatio.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public BackbufferRatio(global::Bgfx.Bgfx.BackbufferRatio _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.BackbufferRatio.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.BackbufferRatio.__Internal*) __Instance) = *((global::Bgfx.Bgfx.BackbufferRatio.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>Occlusion query result.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_occlusion_query_result_t`.</remarks>
        public unsafe partial class OcclusionQueryResult : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx20OcclusionQueryResultC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            /// <summary>Occlusion query results:</summary>
            public enum Enum : uint
            {
                /// <summary>Query failed test.</summary>
                Invisible = 0,
                /// <summary>Query passed test.</summary>
                Visible = 1,
                /// <summary>Query result is not available yet.</summary>
                NoResult = 2,
                Count = 3
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.OcclusionQueryResult> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.OcclusionQueryResult>();

            protected bool __ownsNativeInstance;

            internal static OcclusionQueryResult __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new OcclusionQueryResult(native.ToPointer(), skipVTables);
            }

            internal static OcclusionQueryResult __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (OcclusionQueryResult)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static OcclusionQueryResult __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new OcclusionQueryResult(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private OcclusionQueryResult(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected OcclusionQueryResult(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public OcclusionQueryResult()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.OcclusionQueryResult.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public OcclusionQueryResult(global::Bgfx.Bgfx.OcclusionQueryResult _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.OcclusionQueryResult.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.OcclusionQueryResult.__Internal*) __Instance) = *((global::Bgfx.Bgfx.OcclusionQueryResult.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>Primitive topology.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_topology_t`.</remarks>
        public unsafe partial class Topology : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx8TopologyC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            /// <summary>Primitive topology:</summary>
            public enum Enum : uint
            {
                /// <summary>Triangle list.</summary>
                TriList = 0,
                /// <summary>Triangle strip.</summary>
                TriStrip = 1,
                /// <summary>Line list.</summary>
                LineList = 2,
                /// <summary>Line strip.</summary>
                LineStrip = 3,
                /// <summary>Point list.</summary>
                PointList = 4,
                Count = 5
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Topology> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Topology>();

            protected bool __ownsNativeInstance;

            internal static Topology __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Topology(native.ToPointer(), skipVTables);
            }

            internal static Topology __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Topology)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Topology __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Topology(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Topology(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Topology(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Topology()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Topology.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Topology(global::Bgfx.Bgfx.Topology _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Topology.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.Topology.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Topology.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>Topology conversion function.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_topology_convert_t`.</remarks>
        public unsafe partial class TopologyConvert : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx15TopologyConvertC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            /// <summary>Topology conversion functions:</summary>
            public enum Enum : uint
            {
                /// <summary>Flip winding order of triangle list.</summary>
                TriListFlipWinding = 0,
                /// <summary>Flip winding order of trinagle strip.</summary>
                TriStripFlipWinding = 1,
                /// <summary>Convert triangle list to line list.</summary>
                TriListToLineList = 2,
                /// <summary>Convert triangle strip to triangle list.</summary>
                TriStripToTriList = 3,
                /// <summary>Convert line strip to line list.</summary>
                LineStripToLineList = 4,
                Count = 5
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.TopologyConvert> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.TopologyConvert>();

            protected bool __ownsNativeInstance;

            internal static TopologyConvert __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new TopologyConvert(native.ToPointer(), skipVTables);
            }

            internal static TopologyConvert __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (TopologyConvert)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static TopologyConvert __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TopologyConvert(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private TopologyConvert(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TopologyConvert(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public TopologyConvert()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.TopologyConvert.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public TopologyConvert(global::Bgfx.Bgfx.TopologyConvert _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.TopologyConvert.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.TopologyConvert.__Internal*) __Instance) = *((global::Bgfx.Bgfx.TopologyConvert.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>Topology sort order.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_topology_sort_t`.</remarks>
        public unsafe partial class TopologySort : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx12TopologySortC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            /// <summary>Topology sort order:</summary>
            public enum Enum : uint
            {
                DirectionFrontToBackMin = 0,
                DirectionFrontToBackAvg = 1,
                DirectionFrontToBackMax = 2,
                DirectionBackToFrontMin = 3,
                DirectionBackToFrontAvg = 4,
                DirectionBackToFrontMax = 5,
                DistanceFrontToBackMin = 6,
                DistanceFrontToBackAvg = 7,
                DistanceFrontToBackMax = 8,
                DistanceBackToFrontMin = 9,
                DistanceBackToFrontAvg = 10,
                DistanceBackToFrontMax = 11,
                Count = 12
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.TopologySort> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.TopologySort>();

            protected bool __ownsNativeInstance;

            internal static TopologySort __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new TopologySort(native.ToPointer(), skipVTables);
            }

            internal static TopologySort __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (TopologySort)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static TopologySort __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TopologySort(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private TopologySort(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TopologySort(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public TopologySort()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.TopologySort.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public TopologySort(global::Bgfx.Bgfx.TopologySort _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.TopologySort.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.TopologySort.__Internal*) __Instance) = *((global::Bgfx.Bgfx.TopologySort.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        /// <summary>View mode sets draw call sort order.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_view_mode_t`.</remarks>
        public unsafe partial class ViewMode : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx8ViewModeC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            /// <summary>View modes:</summary>
            public enum Enum : uint
            {
                /// <summary>Default sort order.</summary>
                Default = 0,
                /// <summary>Sort in the same order in which submit calls were called.</summary>
                Sequential = 1,
                /// <summary>Sort draw call depth in ascending order.</summary>
                DepthAscending = 2,
                /// <summary>Sort draw call depth in descending order.</summary>
                DepthDescending = 3,
                Count = 4
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.ViewMode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.ViewMode>();

            protected bool __ownsNativeInstance;

            internal static ViewMode __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new ViewMode(native.ToPointer(), skipVTables);
            }

            internal static ViewMode __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (ViewMode)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static ViewMode __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ViewMode(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ViewMode(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ViewMode(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public ViewMode()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.ViewMode.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public ViewMode(global::Bgfx.Bgfx.ViewMode _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.ViewMode.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.ViewMode.__Internal*) __Instance) = *((global::Bgfx.Bgfx.ViewMode.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }
        }

        public unsafe partial class DynamicIndexBufferHandle : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 2)]
            public partial struct __Internal
            {
                internal ushort idx;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx24DynamicIndexBufferHandleC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.DynamicIndexBufferHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.DynamicIndexBufferHandle>();

            protected bool __ownsNativeInstance;

            internal static DynamicIndexBufferHandle __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new DynamicIndexBufferHandle(native.ToPointer(), skipVTables);
            }

            internal static DynamicIndexBufferHandle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (DynamicIndexBufferHandle)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static DynamicIndexBufferHandle __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DynamicIndexBufferHandle(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private DynamicIndexBufferHandle(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DynamicIndexBufferHandle(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public DynamicIndexBufferHandle()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public DynamicIndexBufferHandle(global::Bgfx.Bgfx.DynamicIndexBufferHandle _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal*) __Instance) = *((global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ushort Idx
            {
                get
                {
                    return ((__Internal*)__Instance)->idx;
                }

                set
                {
                    ((__Internal*)__Instance)->idx = value;
                }
            }
        }

        public unsafe partial class DynamicVertexBufferHandle : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 2)]
            public partial struct __Internal
            {
                internal ushort idx;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx25DynamicVertexBufferHandleC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.DynamicVertexBufferHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.DynamicVertexBufferHandle>();

            protected bool __ownsNativeInstance;

            internal static DynamicVertexBufferHandle __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new DynamicVertexBufferHandle(native.ToPointer(), skipVTables);
            }

            internal static DynamicVertexBufferHandle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (DynamicVertexBufferHandle)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static DynamicVertexBufferHandle __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new DynamicVertexBufferHandle(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private DynamicVertexBufferHandle(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected DynamicVertexBufferHandle(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public DynamicVertexBufferHandle()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public DynamicVertexBufferHandle(global::Bgfx.Bgfx.DynamicVertexBufferHandle _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal*) __Instance) = *((global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ushort Idx
            {
                get
                {
                    return ((__Internal*)__Instance)->idx;
                }

                set
                {
                    ((__Internal*)__Instance)->idx = value;
                }
            }
        }

        public unsafe partial class FrameBufferHandle : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 2)]
            public partial struct __Internal
            {
                internal ushort idx;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx17FrameBufferHandleC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.FrameBufferHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.FrameBufferHandle>();

            protected bool __ownsNativeInstance;

            internal static FrameBufferHandle __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new FrameBufferHandle(native.ToPointer(), skipVTables);
            }

            internal static FrameBufferHandle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (FrameBufferHandle)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static FrameBufferHandle __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new FrameBufferHandle(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private FrameBufferHandle(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected FrameBufferHandle(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public FrameBufferHandle()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.FrameBufferHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public FrameBufferHandle(global::Bgfx.Bgfx.FrameBufferHandle _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.FrameBufferHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.FrameBufferHandle.__Internal*) __Instance) = *((global::Bgfx.Bgfx.FrameBufferHandle.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ushort Idx
            {
                get
                {
                    return ((__Internal*)__Instance)->idx;
                }

                set
                {
                    ((__Internal*)__Instance)->idx = value;
                }
            }
        }

        public unsafe partial class IndexBufferHandle : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 2)]
            public partial struct __Internal
            {
                internal ushort idx;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx17IndexBufferHandleC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.IndexBufferHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.IndexBufferHandle>();

            protected bool __ownsNativeInstance;

            internal static IndexBufferHandle __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new IndexBufferHandle(native.ToPointer(), skipVTables);
            }

            internal static IndexBufferHandle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (IndexBufferHandle)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static IndexBufferHandle __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new IndexBufferHandle(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private IndexBufferHandle(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected IndexBufferHandle(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public IndexBufferHandle()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.IndexBufferHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public IndexBufferHandle(global::Bgfx.Bgfx.IndexBufferHandle _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.IndexBufferHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.IndexBufferHandle.__Internal*) __Instance) = *((global::Bgfx.Bgfx.IndexBufferHandle.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ushort Idx
            {
                get
                {
                    return ((__Internal*)__Instance)->idx;
                }

                set
                {
                    ((__Internal*)__Instance)->idx = value;
                }
            }
        }

        public unsafe partial class IndirectBufferHandle : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 2)]
            public partial struct __Internal
            {
                internal ushort idx;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx20IndirectBufferHandleC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.IndirectBufferHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.IndirectBufferHandle>();

            protected bool __ownsNativeInstance;

            internal static IndirectBufferHandle __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new IndirectBufferHandle(native.ToPointer(), skipVTables);
            }

            internal static IndirectBufferHandle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (IndirectBufferHandle)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static IndirectBufferHandle __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new IndirectBufferHandle(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private IndirectBufferHandle(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected IndirectBufferHandle(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public IndirectBufferHandle()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.IndirectBufferHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public IndirectBufferHandle(global::Bgfx.Bgfx.IndirectBufferHandle _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.IndirectBufferHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.IndirectBufferHandle.__Internal*) __Instance) = *((global::Bgfx.Bgfx.IndirectBufferHandle.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ushort Idx
            {
                get
                {
                    return ((__Internal*)__Instance)->idx;
                }

                set
                {
                    ((__Internal*)__Instance)->idx = value;
                }
            }
        }

        public unsafe partial class OcclusionQueryHandle : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 2)]
            public partial struct __Internal
            {
                internal ushort idx;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx20OcclusionQueryHandleC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.OcclusionQueryHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.OcclusionQueryHandle>();

            protected bool __ownsNativeInstance;

            internal static OcclusionQueryHandle __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new OcclusionQueryHandle(native.ToPointer(), skipVTables);
            }

            internal static OcclusionQueryHandle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (OcclusionQueryHandle)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static OcclusionQueryHandle __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new OcclusionQueryHandle(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private OcclusionQueryHandle(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected OcclusionQueryHandle(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public OcclusionQueryHandle()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public OcclusionQueryHandle(global::Bgfx.Bgfx.OcclusionQueryHandle _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal*) __Instance) = *((global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ushort Idx
            {
                get
                {
                    return ((__Internal*)__Instance)->idx;
                }

                set
                {
                    ((__Internal*)__Instance)->idx = value;
                }
            }
        }

        public unsafe partial class ProgramHandle : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 2)]
            public partial struct __Internal
            {
                internal ushort idx;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx13ProgramHandleC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.ProgramHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.ProgramHandle>();

            protected bool __ownsNativeInstance;

            internal static ProgramHandle __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new ProgramHandle(native.ToPointer(), skipVTables);
            }

            internal static ProgramHandle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (ProgramHandle)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static ProgramHandle __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ProgramHandle(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ProgramHandle(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ProgramHandle(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public ProgramHandle()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.ProgramHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public ProgramHandle(global::Bgfx.Bgfx.ProgramHandle _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.ProgramHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.ProgramHandle.__Internal*) __Instance) = *((global::Bgfx.Bgfx.ProgramHandle.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ushort Idx
            {
                get
                {
                    return ((__Internal*)__Instance)->idx;
                }

                set
                {
                    ((__Internal*)__Instance)->idx = value;
                }
            }
        }

        public unsafe partial class ShaderHandle : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 2)]
            public partial struct __Internal
            {
                internal ushort idx;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx12ShaderHandleC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.ShaderHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.ShaderHandle>();

            protected bool __ownsNativeInstance;

            internal static ShaderHandle __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new ShaderHandle(native.ToPointer(), skipVTables);
            }

            internal static ShaderHandle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (ShaderHandle)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static ShaderHandle __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ShaderHandle(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ShaderHandle(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ShaderHandle(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public ShaderHandle()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.ShaderHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public ShaderHandle(global::Bgfx.Bgfx.ShaderHandle _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.ShaderHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.ShaderHandle.__Internal*) __Instance) = *((global::Bgfx.Bgfx.ShaderHandle.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ushort Idx
            {
                get
                {
                    return ((__Internal*)__Instance)->idx;
                }

                set
                {
                    ((__Internal*)__Instance)->idx = value;
                }
            }
        }

        public unsafe partial class TextureHandle : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 2)]
            public partial struct __Internal
            {
                internal ushort idx;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx13TextureHandleC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.TextureHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.TextureHandle>();

            protected bool __ownsNativeInstance;

            internal static TextureHandle __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new TextureHandle(native.ToPointer(), skipVTables);
            }

            internal static TextureHandle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (TextureHandle)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static TextureHandle __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TextureHandle(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private TextureHandle(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TextureHandle(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public TextureHandle()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.TextureHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public TextureHandle(global::Bgfx.Bgfx.TextureHandle _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.TextureHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.TextureHandle.__Internal*) __Instance) = *((global::Bgfx.Bgfx.TextureHandle.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ushort Idx
            {
                get
                {
                    return ((__Internal*)__Instance)->idx;
                }

                set
                {
                    ((__Internal*)__Instance)->idx = value;
                }
            }
        }

        public unsafe partial class UniformHandle : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 2)]
            public partial struct __Internal
            {
                internal ushort idx;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx13UniformHandleC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.UniformHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.UniformHandle>();

            protected bool __ownsNativeInstance;

            internal static UniformHandle __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new UniformHandle(native.ToPointer(), skipVTables);
            }

            internal static UniformHandle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (UniformHandle)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static UniformHandle __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new UniformHandle(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private UniformHandle(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected UniformHandle(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public UniformHandle()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.UniformHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public UniformHandle(global::Bgfx.Bgfx.UniformHandle _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.UniformHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.UniformHandle.__Internal*) __Instance) = *((global::Bgfx.Bgfx.UniformHandle.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ushort Idx
            {
                get
                {
                    return ((__Internal*)__Instance)->idx;
                }

                set
                {
                    ((__Internal*)__Instance)->idx = value;
                }
            }
        }

        public unsafe partial class VertexBufferHandle : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 2)]
            public partial struct __Internal
            {
                internal ushort idx;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx18VertexBufferHandleC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.VertexBufferHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.VertexBufferHandle>();

            protected bool __ownsNativeInstance;

            internal static VertexBufferHandle __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new VertexBufferHandle(native.ToPointer(), skipVTables);
            }

            internal static VertexBufferHandle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (VertexBufferHandle)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static VertexBufferHandle __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new VertexBufferHandle(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private VertexBufferHandle(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected VertexBufferHandle(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public VertexBufferHandle()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.VertexBufferHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public VertexBufferHandle(global::Bgfx.Bgfx.VertexBufferHandle _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.VertexBufferHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) __Instance) = *((global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ushort Idx
            {
                get
                {
                    return ((__Internal*)__Instance)->idx;
                }

                set
                {
                    ((__Internal*)__Instance)->idx = value;
                }
            }
        }

        public unsafe partial class VertexLayoutHandle : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 2)]
            public partial struct __Internal
            {
                internal ushort idx;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx18VertexLayoutHandleC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.VertexLayoutHandle> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.VertexLayoutHandle>();

            protected bool __ownsNativeInstance;

            internal static VertexLayoutHandle __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new VertexLayoutHandle(native.ToPointer(), skipVTables);
            }

            internal static VertexLayoutHandle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (VertexLayoutHandle)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static VertexLayoutHandle __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new VertexLayoutHandle(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private VertexLayoutHandle(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected VertexLayoutHandle(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public VertexLayoutHandle()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.VertexLayoutHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public VertexLayoutHandle(global::Bgfx.Bgfx.VertexLayoutHandle _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.VertexLayoutHandle.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.VertexLayoutHandle.__Internal*) __Instance) = *((global::Bgfx.Bgfx.VertexLayoutHandle.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public ushort Idx
            {
                get
                {
                    return ((__Internal*)__Instance)->idx;
                }

                set
                {
                    ((__Internal*)__Instance)->idx = value;
                }
            }
        }

        /// <summary>
        /// <para>Callback interface to implement application specific behavior.</para>
        /// <para>Cached items are currently used for OpenGL and Direct3D 12 binary</para>
        /// <para>shaders.</para>
        /// </summary>
        /// <remarks>
        /// <para>'fatal' and 'trace' callbacks can be called from any thread. Other</para>
        /// <para>callbacks are called from the render thread.</para>
        /// <para>C99's equivalent binding is `bgfx_callback_interface_t`.</para>
        /// </remarks>
        public unsafe abstract partial class CallbackI : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 8)]
            public partial struct __Internal
            {
                internal __IntPtr vptr_CallbackI;

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx9CallbackIC2Ev", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx9CallbackIC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.CallbackI> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.CallbackI>();

            protected bool __ownsNativeInstance;

            internal static CallbackI __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new CallbackIInternal(native.ToPointer(), skipVTables);
            }

            internal static CallbackI __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (CallbackI)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static CallbackI __GetInstance(__IntPtr native)
            {
                if (!NativeToManagedMap.TryGetValue(native, out var managed))
                    throw new global::System.Exception("No managed instance was found");
                var result = (CallbackI)managed;
                if (result.__ownsNativeInstance)
                    result.SetupVTables();
                return result;
            }

            internal static CallbackI __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new CallbackIInternal(native, skipVTables);
            }

            protected CallbackI(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
                if (!skipVTables)
                    SetupVTables(true);
            }

            protected CallbackI()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.CallbackI.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor(__Instance);
                SetupVTables(GetType().FullName == "Bgfx.Bgfx.CallbackI");
            }

            protected CallbackI(global::Bgfx.Bgfx.CallbackI _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.CallbackI.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                if (ReferenceEquals(_0, null))
                    throw new global::System.ArgumentNullException("_0", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _0.__Instance;
                __Internal.cctor(__Instance, __arg0);
                SetupVTables(GetType().FullName == "Bgfx.Bgfx.CallbackI");
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                *(IntPtr*)(__Instance + 0) = __VTables.Tables[0];
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>This callback is called on unrecoverable errors.</para>
            /// <para>It's not safe to continue (Excluding _code `Fatal::DebugCheck`),</para>
            /// <para>inform the user and terminate the application.</para>
            /// </summary>
            /// <param name="_filePath">File path where fatal message was generated.</param>
            /// <param name="_line">Line where fatal message was generated.</param>
            /// <param name="_code">Fatal error code.</param>
            /// <param name="_str">More information about error.</param>
            /// <remarks>
            /// <para>Not thread safe and it can be called from any thread.</para>
            /// <para>C99's equivalent binding is `bgfx_callback_vtbl.fatal`.</para>
            /// </remarks>
            public abstract void Fatal(string _filePath, ushort _line, global::Bgfx.Bgfx.Fatal.Enum _code, string _str);

            /// <summary>Profiler region begin.</summary>
            /// <param name="_name">Region name, contains dynamic string.</param>
            /// <param name="_abgr">Color of profiler region.</param>
            /// <param name="_filePath">File path where `profilerBegin` was called.</param>
            /// <param name="_line">Line where `profilerBegin` was called.</param>
            /// <remarks>
            /// <para>Not thread safe and it can be called from any thread.</para>
            /// <para>C99's equivalent binding is `bgfx_callback_vtbl.profiler_begin`.</para>
            /// </remarks>
            public abstract void ProfilerBegin(string _name, uint _abgr, string _filePath, ushort _line);

            /// <summary>Profiler region begin with string literal name.</summary>
            /// <param name="_name">Region name, contains string literal.</param>
            /// <param name="_abgr">Color of profiler region.</param>
            /// <param name="_filePath">File path where `profilerBeginLiteral` was called.</param>
            /// <param name="_line">Line where `profilerBeginLiteral` was called.</param>
            /// <remarks>
            /// <para>Not thread safe and it can be called from any thread.</para>
            /// <para>C99's equivalent binding is `bgfx_callback_vtbl.profiler_begin_literal`.</para>
            /// </remarks>
            public abstract void ProfilerBeginLiteral(string _name, uint _abgr, string _filePath, ushort _line);

            /// <summary>Profiler region end.</summary>
            /// <remarks>
            /// <para>Not thread safe and it can be called from any thread.</para>
            /// <para>C99's equivalent binding is `bgfx_callback_vtbl.profiler_end`.</para>
            /// </remarks>
            public abstract void ProfilerEnd();

            /// <summary>
            /// <para>Returns the size of a cached item. Returns 0 if no cached item was</para>
            /// <para>found.</para>
            /// </summary>
            /// <param name="_id">Cache id.</param>
            /// <remarks>
            /// <para>Number of bytes to read.</para>
            /// <para>C99's equivalent binding is `bgfx_callback_vtbl.cache_read_size`.</para>
            /// </remarks>
            public abstract uint CacheReadSize(ulong _id);

            /// <summary>Read cached item.</summary>
            /// <param name="_id">Cache id.</param>
            /// <param name="_data">Buffer where to read data.</param>
            /// <param name="_size">Size of data to read.</param>
            /// <remarks>
            /// <para>True if data is read.</para>
            /// <para>C99's equivalent binding is `bgfx_callback_vtbl.cache_read`.</para>
            /// </remarks>
            public abstract bool CacheRead(ulong _id, __IntPtr _data, uint _size);

            /// <summary>Write cached item.</summary>
            /// <param name="_id">Cache id.</param>
            /// <param name="_data">Data to write.</param>
            /// <param name="_size">Size of data to write.</param>
            /// <remarks>C99's equivalent binding is `bgfx_callback_vtbl.cache_write`.</remarks>
            public abstract void CacheWrite(ulong _id, __IntPtr _data, uint _size);

            /// <summary>Screenshot captured. Screenshot format is always 4-byte BGRA.</summary>
            /// <param name="_filePath">File path.</param>
            /// <param name="_width">Image width.</param>
            /// <param name="_height">Image height.</param>
            /// <param name="_pitch">
            /// <para>Number of bytes to skip between the start of</para>
            /// <para>each horizontal line of the image.</para>
            /// </param>
            /// <param name="_data">Image data.</param>
            /// <param name="_size">Image size.</param>
            /// <param name="_yflip">If true, image origin is bottom left.</param>
            /// <remarks>C99's equivalent binding is `bgfx_callback_vtbl.screen_shot`.</remarks>
            public abstract void ScreenShot(string _filePath, uint _width, uint _height, uint _pitch, __IntPtr _data, uint _size, bool _yflip);

            /// <summary>Called when a video capture begins.</summary>
            /// <param name="_width">Image width.</param>
            /// <param name="_height">Image height.</param>
            /// <param name="_pitch">
            /// <para>Number of bytes to skip between the start of</para>
            /// <para>each horizontal line of the image.</para>
            /// </param>
            /// <param name="_format">Texture format. See: `TextureFormat::Enum`.</param>
            /// <param name="_yflip">If true, image origin is bottom left.</param>
            /// <remarks>C99's equivalent binding is `bgfx_callback_vtbl.capture_begin`.</remarks>
            public abstract void CaptureBegin(uint _width, uint _height, uint _pitch, global::Bgfx.Bgfx.TextureFormat.Enum _format, bool _yflip);

            /// <summary>Called when a video capture ends.</summary>
            /// <remarks>C99's equivalent binding is `bgfx_callback_vtbl.capture_end`.</remarks>
            public abstract void CaptureEnd();

            /// <summary>Captured frame.</summary>
            /// <param name="_data">Image data.</param>
            /// <param name="_size">Image size.</param>
            /// <remarks>C99's equivalent binding is `bgfx_callback_vtbl.capture_frame`.</remarks>
            public abstract void CaptureFrame(__IntPtr _data, uint _size);

            #region Virtual table interop

            // virtual ~CallbackI() = 0
            private static global::Bgfx.Delegates.Action___IntPtr _dtorDelegateInstance;

            private static void _dtorDelegateHook(__IntPtr __instance)
            {
                var __target = global::Bgfx.Bgfx.CallbackI.__GetInstance(__instance);
                __target.Dispose(disposing: true, callNativeDtor: true);
            }

            // void fatal( const char* _filePath , uint16_t _line , Fatal::Enum _code , const char* _str ) = 0
            private static global::Bgfx.Delegates.Action___IntPtr_string8_ushort_Bgfx_bgfx_Fatal_Enum_string8 _FatalDelegateInstance;

            private static void _FatalDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _filePath, ushort _line, global::Bgfx.Bgfx.Fatal.Enum _code, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _str)
            {
                var __target = global::Bgfx.Bgfx.CallbackI.__GetInstance(__instance);
                __target.Fatal(_filePath, _line, _code, _str);
            }

            // void profilerBegin( const char* _name , uint32_t _abgr , const char* _filePath , uint16_t _line ) = 0
            private static global::Bgfx.Delegates.Action___IntPtr_string8_uint_string8_ushort _ProfilerBeginDelegateInstance;

            private static void _ProfilerBeginDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _name, uint _abgr, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _filePath, ushort _line)
            {
                var __target = global::Bgfx.Bgfx.CallbackI.__GetInstance(__instance);
                __target.ProfilerBegin(_name, _abgr, _filePath, _line);
            }

            // void profilerBeginLiteral( const char* _name , uint32_t _abgr , const char* _filePath , uint16_t _line ) = 0
            private static global::Bgfx.Delegates.Action___IntPtr_string8_uint_string8_ushort _ProfilerBeginLiteralDelegateInstance;

            private static void _ProfilerBeginLiteralDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _name, uint _abgr, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _filePath, ushort _line)
            {
                var __target = global::Bgfx.Bgfx.CallbackI.__GetInstance(__instance);
                __target.ProfilerBeginLiteral(_name, _abgr, _filePath, _line);
            }

            // void profilerEnd() = 0
            private static global::Bgfx.Delegates.Action___IntPtr _ProfilerEndDelegateInstance;

            private static void _ProfilerEndDelegateHook(__IntPtr __instance)
            {
                var __target = global::Bgfx.Bgfx.CallbackI.__GetInstance(__instance);
                __target.ProfilerEnd();
            }

            // uint32_t cacheReadSize(uint64_t _id) = 0
            private static global::Bgfx.Delegates.Func_uint___IntPtr_ulong _CacheReadSizeDelegateInstance;

            private static uint _CacheReadSizeDelegateHook(__IntPtr __instance, ulong _id)
            {
                var __target = global::Bgfx.Bgfx.CallbackI.__GetInstance(__instance);
                return __target.CacheReadSize(_id);
            }

            // bool cacheRead(uint64_t _id, void* _data, uint32_t _size) = 0
            private static global::Bgfx.Delegates.Func_bool___IntPtr_ulong___IntPtr_uint _CacheReadDelegateInstance;

            private static bool _CacheReadDelegateHook(__IntPtr __instance, ulong _id, __IntPtr _data, uint _size)
            {
                var __target = global::Bgfx.Bgfx.CallbackI.__GetInstance(__instance);
                return __target.CacheRead(_id, _data, _size);
            }

            // void cacheWrite(uint64_t _id, const void* _data, uint32_t _size) = 0
            private static global::Bgfx.Delegates.Action___IntPtr_ulong___IntPtr_uint _CacheWriteDelegateInstance;

            private static void _CacheWriteDelegateHook(__IntPtr __instance, ulong _id, __IntPtr _data, uint _size)
            {
                var __target = global::Bgfx.Bgfx.CallbackI.__GetInstance(__instance);
                __target.CacheWrite(_id, _data, _size);
            }

            // void screenShot( const char* _filePath , uint32_t _width , uint32_t _height , uint32_t _pitch , const void* _data , uint32_t _size , bool _yflip ) = 0
            private static global::Bgfx.Delegates.Action___IntPtr_string8_uint_uint_uint___IntPtr_uint_bool _ScreenShotDelegateInstance;

            private static void _ScreenShotDelegateHook(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _filePath, uint _width, uint _height, uint _pitch, __IntPtr _data, uint _size, bool _yflip)
            {
                var __target = global::Bgfx.Bgfx.CallbackI.__GetInstance(__instance);
                __target.ScreenShot(_filePath, _width, _height, _pitch, _data, _size, _yflip);
            }

            // void captureBegin( uint32_t _width , uint32_t _height , uint32_t _pitch , TextureFormat::Enum _format , bool _yflip ) = 0
            private static global::Bgfx.Delegates.Action___IntPtr_uint_uint_uint_Bgfx_bgfx_TextureFormat_Enum_bool _CaptureBeginDelegateInstance;

            private static void _CaptureBeginDelegateHook(__IntPtr __instance, uint _width, uint _height, uint _pitch, global::Bgfx.Bgfx.TextureFormat.Enum _format, bool _yflip)
            {
                var __target = global::Bgfx.Bgfx.CallbackI.__GetInstance(__instance);
                __target.CaptureBegin(_width, _height, _pitch, _format, _yflip);
            }

            // void captureEnd() = 0
            private static global::Bgfx.Delegates.Action___IntPtr _CaptureEndDelegateInstance;

            private static void _CaptureEndDelegateHook(__IntPtr __instance)
            {
                var __target = global::Bgfx.Bgfx.CallbackI.__GetInstance(__instance);
                __target.CaptureEnd();
            }

            // void captureFrame(const void* _data, uint32_t _size) = 0
            private static global::Bgfx.Delegates.Action___IntPtr___IntPtr_uint _CaptureFrameDelegateInstance;

            private static void _CaptureFrameDelegateHook(__IntPtr __instance, __IntPtr _data, uint _size)
            {
                var __target = global::Bgfx.Bgfx.CallbackI.__GetInstance(__instance);
                __target.CaptureFrame(_data, _size);
            }

            internal static class VTableLoader
            {
                private static volatile bool initialized;
                private static readonly IntPtr*[] ManagedVTables = new IntPtr*[1];
                private static readonly IntPtr*[] ManagedVTablesDtorOnly = new IntPtr*[1];
                private static readonly IntPtr[] Thunks = new IntPtr[12];
                private static CppSharp.Runtime.VTables VTables;
                private static readonly global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>
                    SafeHandles = new global::System.Collections.Generic.List<CppSharp.Runtime.SafeUnmanagedMemoryHandle>();

                static VTableLoader()
                {
                    _dtorDelegateInstance += _dtorDelegateHook;
                    _FatalDelegateInstance += _FatalDelegateHook;
                    _ProfilerBeginDelegateInstance += _ProfilerBeginDelegateHook;
                    _ProfilerBeginLiteralDelegateInstance += _ProfilerBeginLiteralDelegateHook;
                    _ProfilerEndDelegateInstance += _ProfilerEndDelegateHook;
                    _CacheReadSizeDelegateInstance += _CacheReadSizeDelegateHook;
                    _CacheReadDelegateInstance += _CacheReadDelegateHook;
                    _CacheWriteDelegateInstance += _CacheWriteDelegateHook;
                    _ScreenShotDelegateInstance += _ScreenShotDelegateHook;
                    _CaptureBeginDelegateInstance += _CaptureBeginDelegateHook;
                    _CaptureEndDelegateInstance += _CaptureEndDelegateHook;
                    _CaptureFrameDelegateInstance += _CaptureFrameDelegateHook;
                    Thunks[0] = Marshal.GetFunctionPointerForDelegate(_dtorDelegateInstance);
                    Thunks[1] = Marshal.GetFunctionPointerForDelegate(_FatalDelegateInstance);
                    Thunks[2] = Marshal.GetFunctionPointerForDelegate(_ProfilerBeginDelegateInstance);
                    Thunks[3] = Marshal.GetFunctionPointerForDelegate(_ProfilerBeginLiteralDelegateInstance);
                    Thunks[4] = Marshal.GetFunctionPointerForDelegate(_ProfilerEndDelegateInstance);
                    Thunks[5] = Marshal.GetFunctionPointerForDelegate(_CacheReadSizeDelegateInstance);
                    Thunks[6] = Marshal.GetFunctionPointerForDelegate(_CacheReadDelegateInstance);
                    Thunks[7] = Marshal.GetFunctionPointerForDelegate(_CacheWriteDelegateInstance);
                    Thunks[8] = Marshal.GetFunctionPointerForDelegate(_ScreenShotDelegateInstance);
                    Thunks[9] = Marshal.GetFunctionPointerForDelegate(_CaptureBeginDelegateInstance);
                    Thunks[10] = Marshal.GetFunctionPointerForDelegate(_CaptureEndDelegateInstance);
                    Thunks[11] = Marshal.GetFunctionPointerForDelegate(_CaptureFrameDelegateInstance);
                }

                public static CppSharp.Runtime.VTables SetupVTables(IntPtr instance, bool destructorOnly = false)
                {
                    if (!initialized)
                    {
                        lock (ManagedVTables)
                        {
                            if (!initialized)
                            {
                                initialized = true;
                                VTables.Tables = new IntPtr[] { *(IntPtr*)(instance + 0) };
                                VTables.Methods = new Delegate[1][];
                                ManagedVTablesDtorOnly[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 16);
                                ManagedVTablesDtorOnly[0][1] = Thunks[0];
                                ManagedVTables[0] = CppSharp.Runtime.VTables.CloneTable(SafeHandles, instance, 0, 16);
                                ManagedVTables[0][1] = Thunks[0];
                                ManagedVTables[0][2] = Thunks[1];
                                ManagedVTables[0][4] = Thunks[2];
                                ManagedVTables[0][5] = Thunks[3];
                                ManagedVTables[0][6] = Thunks[4];
                                ManagedVTables[0][7] = Thunks[5];
                                ManagedVTables[0][8] = Thunks[6];
                                ManagedVTables[0][9] = Thunks[7];
                                ManagedVTables[0][10] = Thunks[8];
                                ManagedVTables[0][11] = Thunks[9];
                                ManagedVTables[0][12] = Thunks[10];
                                ManagedVTables[0][13] = Thunks[11];
                                VTables.Methods[0] = new Delegate[16];
                            }
                        }
                    }

                    if (destructorOnly)
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTablesDtorOnly[0];
                    }
                    else
                    {
                        *(IntPtr**)(instance + 0) = ManagedVTables[0];
                    }
                    return VTables;
                }
            }

            protected CppSharp.Runtime.VTables __vtables;
            internal virtual CppSharp.Runtime.VTables __VTables
            { 
                get {
                    if (__vtables.IsEmpty)
                        __vtables.Tables = new IntPtr[] { *(IntPtr*)(__Instance + 0) };
                    return __vtables;
                }

                set {        
                    __vtables = value;
                }
            }

            internal virtual void SetupVTables(bool destructorOnly = false)
            {
                if (__VTables.IsTransient)
                    __VTables = VTableLoader.SetupVTables(__Instance, destructorOnly);
            }
            #endregion
        }

        /// <summary>Platform data.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_platform_data_t`.</remarks>
        public unsafe partial class PlatformData : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 40)]
            public partial struct __Internal
            {
                internal __IntPtr ndt;
                internal __IntPtr nwh;
                internal __IntPtr context;
                internal __IntPtr backBuffer;
                internal __IntPtr backBufferDS;

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12PlatformDataC2Ev", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx12PlatformDataC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.PlatformData> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.PlatformData>();

            protected bool __ownsNativeInstance;

            internal static PlatformData __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new PlatformData(native.ToPointer(), skipVTables);
            }

            internal static PlatformData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (PlatformData)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static PlatformData __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new PlatformData(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private PlatformData(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected PlatformData(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public PlatformData()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.PlatformData.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor(__Instance);
            }

            public PlatformData(global::Bgfx.Bgfx.PlatformData _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.PlatformData.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.PlatformData.__Internal*) __Instance) = *((global::Bgfx.Bgfx.PlatformData.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Native display type (*nix specific).</summary>
            public __IntPtr Ndt
            {
                get
                {
                    return ((__Internal*)__Instance)->ndt;
                }

                set
                {
                    ((__Internal*)__Instance)->ndt = (__IntPtr) value;
                }
            }

            /// <summary>Native window handle. If `NULL`, bgfx will create a headless</summary>
            public __IntPtr Nwh
            {
                get
                {
                    return ((__Internal*)__Instance)->nwh;
                }

                set
                {
                    ((__Internal*)__Instance)->nwh = (__IntPtr) value;
                }
            }

            /// <summary>GL context, D3D device, or Vulkan device. If `NULL`, bgfx</summary>
            public __IntPtr Context
            {
                get
                {
                    return ((__Internal*)__Instance)->context;
                }

                set
                {
                    ((__Internal*)__Instance)->context = (__IntPtr) value;
                }
            }

            /// <summary>GL back-buffer, or D3D render target view. If `NULL` bgfx will</summary>
            public __IntPtr BackBuffer
            {
                get
                {
                    return ((__Internal*)__Instance)->backBuffer;
                }

                set
                {
                    ((__Internal*)__Instance)->backBuffer = (__IntPtr) value;
                }
            }

            /// <summary>Backbuffer depth/stencil. If `NULL`, bgfx will create a back-buffer</summary>
            public __IntPtr BackBufferDS
            {
                get
                {
                    return ((__Internal*)__Instance)->backBufferDS;
                }

                set
                {
                    ((__Internal*)__Instance)->backBufferDS = (__IntPtr) value;
                }
            }
        }

        /// <summary>Backbuffer resolution and reset parameters.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_resolution_t`.</remarks>
        public unsafe partial class Resolution : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 20)]
            public partial struct __Internal
            {
                internal global::Bgfx.Bgfx.TextureFormat.Enum format;
                internal uint width;
                internal uint height;
                internal uint reset;
                internal byte numBackBuffers;
                internal byte maxFrameLatency;

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx10ResolutionC2Ev", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx10ResolutionC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Resolution> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Resolution>();

            protected bool __ownsNativeInstance;

            internal static Resolution __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Resolution(native.ToPointer(), skipVTables);
            }

            internal static Resolution __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Resolution)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Resolution __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Resolution(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Resolution(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Resolution(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Resolution()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Resolution.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor(__Instance);
            }

            public Resolution(global::Bgfx.Bgfx.Resolution _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Resolution.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.Resolution.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Resolution.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Backbuffer format.</summary>
            public global::Bgfx.Bgfx.TextureFormat.Enum Format
            {
                get
                {
                    return ((__Internal*)__Instance)->format;
                }

                set
                {
                    ((__Internal*)__Instance)->format = value;
                }
            }

            /// <summary>Backbuffer width.</summary>
            public uint Width
            {
                get
                {
                    return ((__Internal*)__Instance)->width;
                }

                set
                {
                    ((__Internal*)__Instance)->width = value;
                }
            }

            /// <summary>Backbuffer height.</summary>
            public uint Height
            {
                get
                {
                    return ((__Internal*)__Instance)->height;
                }

                set
                {
                    ((__Internal*)__Instance)->height = value;
                }
            }

            /// <summary>Reset parameters.</summary>
            public uint Reset
            {
                get
                {
                    return ((__Internal*)__Instance)->reset;
                }

                set
                {
                    ((__Internal*)__Instance)->reset = value;
                }
            }

            /// <summary>Number of back buffers.</summary>
            public byte NumBackBuffers
            {
                get
                {
                    return ((__Internal*)__Instance)->numBackBuffers;
                }

                set
                {
                    ((__Internal*)__Instance)->numBackBuffers = value;
                }
            }

            /// <summary>Maximum frame latency.</summary>
            public byte MaxFrameLatency
            {
                get
                {
                    return ((__Internal*)__Instance)->maxFrameLatency;
                }

                set
                {
                    ((__Internal*)__Instance)->maxFrameLatency = value;
                }
            }
        }

        /// <summary>Initialization parameters used by `bgfx::init`.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_init_t`.</remarks>
        public unsafe partial class Init : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 120)]
            public partial struct __Internal
            {
                internal global::Bgfx.Bgfx.RendererType.Enum type;
                internal ushort vendorId;
                internal ushort deviceId;
                internal ulong capabilities;
                internal byte debug;
                internal byte profile;
                internal global::Bgfx.Bgfx.PlatformData.__Internal platformData;
                internal global::Bgfx.Bgfx.Resolution.__Internal resolution;
                internal global::Bgfx.Bgfx.Init.Limits.__Internal limits;
                internal __IntPtr callback;
                internal __IntPtr allocator;

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx4InitC2Ev", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx4InitC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            /// <summary>Configurable runtime limits parameters.</summary>
            /// <remarks>C99's equivalent binding is `bgfx_init_limits_t`.</remarks>
            public unsafe partial class Limits : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 16)]
                public partial struct __Internal
                {
                    internal ushort maxEncoders;
                    internal uint minResourceCbSize;
                    internal uint transientVbSize;
                    internal uint transientIbSize;

                    [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx4Init6LimitsC2Ev", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void ctor(__IntPtr __instance);

                    [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx4Init6LimitsC2ERKS1_", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Init.Limits> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Init.Limits>();

                protected bool __ownsNativeInstance;

                internal static Limits __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    return new Limits(native.ToPointer(), skipVTables);
                }

                internal static Limits __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (NativeToManagedMap.TryGetValue(native, out var managed))
                        return (Limits)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        NativeToManagedMap[native] = result;
                    return result;
                }

                internal static Limits __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new Limits(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Limits(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Limits(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Limits()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Init.Limits.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    __Internal.ctor(__Instance);
                }

                public Limits(global::Bgfx.Bgfx.Init.Limits _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Init.Limits.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::Bgfx.Bgfx.Init.Limits.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Init.Limits.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                /// <summary>Maximum number of encoder threads.</summary>
                public ushort MaxEncoders
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxEncoders;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxEncoders = value;
                    }
                }

                /// <summary>Minimum resource command buffer size.</summary>
                public uint MinResourceCbSize
                {
                    get
                    {
                        return ((__Internal*)__Instance)->minResourceCbSize;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->minResourceCbSize = value;
                    }
                }

                /// <summary>Maximum transient vertex buffer size.</summary>
                public uint TransientVbSize
                {
                    get
                    {
                        return ((__Internal*)__Instance)->transientVbSize;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->transientVbSize = value;
                    }
                }

                /// <summary>Maximum transient index buffer size.</summary>
                public uint TransientIbSize
                {
                    get
                    {
                        return ((__Internal*)__Instance)->transientIbSize;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->transientIbSize = value;
                    }
                }
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Init> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Init>();

            protected bool __ownsNativeInstance;

            internal static Init __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Init(native.ToPointer(), skipVTables);
            }

            internal static Init __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Init)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Init __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Init(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Init(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Init(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Init()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Init.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor(__Instance);
            }

            public Init(global::Bgfx.Bgfx.Init _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Init.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.Init.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Init.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Select rendering backend. When set to RendererType::Count</para>
            /// <para>a default rendering backend will be selected appropriate to the platform.</para>
            /// <para>See: `bgfx::RendererType`</para>
            /// </summary>
            public global::Bgfx.Bgfx.RendererType.Enum Type
            {
                get
                {
                    return ((__Internal*)__Instance)->type;
                }

                set
                {
                    ((__Internal*)__Instance)->type = value;
                }
            }

            /// <summary>
            /// <para>Vendor PCI id. If set to `BGFX_PCI_ID_NONE` it will select the first</para>
            /// <para>device.</para>
            /// <para>- `BGFX_PCI_ID_NONE` - Autoselect adapter.</para>
            /// <para>- `BGFX_PCI_ID_SOFTWARE_RASTERIZER` - Software rasterizer.</para>
            /// <para>- `BGFX_PCI_ID_AMD` - AMD adapter.</para>
            /// <para>- `BGFX_PCI_ID_INTEL` - Intel adapter.</para>
            /// <para>- `BGFX_PCI_ID_NVIDIA` - nVidia adapter.</para>
            /// </summary>
            public ushort VendorId
            {
                get
                {
                    return ((__Internal*)__Instance)->vendorId;
                }

                set
                {
                    ((__Internal*)__Instance)->vendorId = value;
                }
            }

            /// <summary>
            /// <para>Device id. If set to 0 it will select first device, or device with</para>
            /// <para>matching id.</para>
            /// </summary>
            public ushort DeviceId
            {
                get
                {
                    return ((__Internal*)__Instance)->deviceId;
                }

                set
                {
                    ((__Internal*)__Instance)->deviceId = value;
                }
            }

            /// <summary>Capabilities initialization mask (default: UINT64_MAX).</summary>
            public ulong Capabilities
            {
                get
                {
                    return ((__Internal*)__Instance)->capabilities;
                }

                set
                {
                    ((__Internal*)__Instance)->capabilities = value;
                }
            }

            /// <summary>Enable device for debugging.</summary>
            public bool Debug
            {
                get
                {
                    return ((__Internal*)__Instance)->debug != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->debug = (byte) (value ? 1 : 0);
                }
            }

            /// <summary>Enable device for profiling.</summary>
            public bool Profile
            {
                get
                {
                    return ((__Internal*)__Instance)->profile != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->profile = (byte) (value ? 1 : 0);
                }
            }

            /// <summary>Platform data.</summary>
            public global::Bgfx.Bgfx.PlatformData PlatformData
            {
                get
                {
                    return global::Bgfx.Bgfx.PlatformData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->platformData));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->platformData = *(global::Bgfx.Bgfx.PlatformData.__Internal*) value.__Instance;
                }
            }

            /// <summary>Backbuffer resolution and reset parameters. See: `bgfx::Resolution`.</summary>
            public global::Bgfx.Bgfx.Resolution Resolution
            {
                get
                {
                    return global::Bgfx.Bgfx.Resolution.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->resolution));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->resolution = *(global::Bgfx.Bgfx.Resolution.__Internal*) value.__Instance;
                }
            }

            /// <summary>Configurable runtime limits.</summary>
            public global::Bgfx.Bgfx.Init.Limits limits
            {
                get
                {
                    return global::Bgfx.Bgfx.Init.Limits.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->limits));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->limits = *(global::Bgfx.Bgfx.Init.Limits.__Internal*) value.__Instance;
                }
            }

            /// <summary>
            /// <para>Provide application specific callback interface.</para>
            /// <para>See: `bgfx::CallbackI`</para>
            /// </summary>
            public global::Bgfx.Bgfx.CallbackI Callback
            {
                get
                {
                    var __result0 = global::Bgfx.Bgfx.CallbackI.__GetOrCreateInstance(((__Internal*)__Instance)->callback, true);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->callback = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            /// <summary>
            /// <para>Custom allocator. When a custom allocator is not</para>
            /// <para>specified, bgfx uses the CRT allocator. Bgfx assumes</para>
            /// <para>custom allocator is thread safe.</para>
            /// </summary>
            public global::Bgfx.Bx.AllocatorI Allocator
            {
                get
                {
                    var __result0 = global::Bgfx.Bx.AllocatorI.__GetOrCreateInstance(((__Internal*)__Instance)->allocator, false);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->allocator = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }
        }

        /// <summary>Memory must be obtained by calling `bgfx::alloc`, `bgfx::copy`, or `bgfx::makeRef`.</summary>
        /// <remarks>
        /// <para>It is illegal to create this structure on stack and pass it to any bgfx API.</para>
        /// <para>C99's equivalent binding is `bgfx_memory_t`.</para>
        /// </remarks>
        public unsafe partial class Memory : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr data;
                internal uint size;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx6MemoryC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Memory> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Memory>();

            protected bool __ownsNativeInstance;

            internal static Memory __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Memory(native.ToPointer(), skipVTables);
            }

            internal static Memory __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Memory)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Memory __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Memory(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Memory(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Memory(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Memory()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Memory.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Memory(global::Bgfx.Bgfx.Memory _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Memory.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.Memory.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Memory.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Pointer to data.</summary>
            public byte* Data
            {
                get
                {
                    return (byte*) ((__Internal*)__Instance)->data;
                }

                set
                {
                    ((__Internal*)__Instance)->data = (__IntPtr) value;
                }
            }

            /// <summary>Data size.</summary>
            public uint Size
            {
                get
                {
                    return ((__Internal*)__Instance)->size;
                }

                set
                {
                    ((__Internal*)__Instance)->size = value;
                }
            }
        }

        /// <summary>Renderer capabilities.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_caps_t`.</remarks>
        public unsafe partial class Caps : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 312)]
            public partial struct __Internal
            {
                internal global::Bgfx.Bgfx.RendererType.Enum rendererType;
                internal ulong supported;
                internal ushort vendorId;
                internal ushort deviceId;
                internal byte homogeneousDepth;
                internal byte originBottomLeft;
                internal byte numGPUs;
                internal byte gpuPadding;
                internal fixed byte gpu[16];
                internal global::Bgfx.Bgfx.Caps.Limits.__Internal limits;
                internal fixed ushort formats[85];

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx4CapsC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            /// <summary>GPU info.</summary>
            /// <remarks>C99's equivalent binding is `bgfx_caps_gpu_t`.</remarks>
            public unsafe partial class GPU : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 4)]
                public partial struct __Internal
                {
                    internal ushort vendorId;
                    internal ushort deviceId;

                    [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx4Caps3GPUC2ERKS1_", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Caps.GPU> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Caps.GPU>();

                protected bool __ownsNativeInstance;

                internal static GPU __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    return new GPU(native.ToPointer(), skipVTables);
                }

                internal static GPU __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (NativeToManagedMap.TryGetValue(native, out var managed))
                        return (GPU)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        NativeToManagedMap[native] = result;
                    return result;
                }

                internal static GPU __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new GPU(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private GPU(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected GPU(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public GPU()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Caps.GPU.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public GPU(global::Bgfx.Bgfx.Caps.GPU _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Caps.GPU.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::Bgfx.Bgfx.Caps.GPU.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Caps.GPU.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                /// <summary>Vendor PCI id. See `BGFX_PCI_ID_*`.</summary>
                public ushort VendorId
                {
                    get
                    {
                        return ((__Internal*)__Instance)->vendorId;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->vendorId = value;
                    }
                }

                /// <summary>Device id.</summary>
                public ushort DeviceId
                {
                    get
                    {
                        return ((__Internal*)__Instance)->deviceId;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->deviceId = value;
                    }
                }
            }

            /// <summary>Renderer runtime limits.</summary>
            /// <remarks>C99's equivalent binding is `bgfx_caps_limits_t`.</remarks>
            public unsafe partial class Limits : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 96)]
                public partial struct __Internal
                {
                    internal uint maxDrawCalls;
                    internal uint maxBlits;
                    internal uint maxTextureSize;
                    internal uint maxTextureLayers;
                    internal uint maxViews;
                    internal uint maxFrameBuffers;
                    internal uint maxFBAttachments;
                    internal uint maxPrograms;
                    internal uint maxShaders;
                    internal uint maxTextures;
                    internal uint maxTextureSamplers;
                    internal uint maxComputeBindings;
                    internal uint maxVertexLayouts;
                    internal uint maxVertexStreams;
                    internal uint maxIndexBuffers;
                    internal uint maxVertexBuffers;
                    internal uint maxDynamicIndexBuffers;
                    internal uint maxDynamicVertexBuffers;
                    internal uint maxUniforms;
                    internal uint maxOcclusionQueries;
                    internal uint maxEncoders;
                    internal uint minResourceCbSize;
                    internal uint transientVbSize;
                    internal uint transientIbSize;

                    [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx4Caps6LimitsC2ERKS1_", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Caps.Limits> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Caps.Limits>();

                protected bool __ownsNativeInstance;

                internal static Limits __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    return new Limits(native.ToPointer(), skipVTables);
                }

                internal static Limits __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (NativeToManagedMap.TryGetValue(native, out var managed))
                        return (Limits)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        NativeToManagedMap[native] = result;
                    return result;
                }

                internal static Limits __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new Limits(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Limits(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Limits(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Limits()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Caps.Limits.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Limits(global::Bgfx.Bgfx.Caps.Limits _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Caps.Limits.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::Bgfx.Bgfx.Caps.Limits.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Caps.Limits.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                /// <summary>Maximum number of draw calls.</summary>
                public uint MaxDrawCalls
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxDrawCalls;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxDrawCalls = value;
                    }
                }

                /// <summary>Maximum number of blit calls.</summary>
                public uint MaxBlits
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxBlits;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxBlits = value;
                    }
                }

                /// <summary>Maximum texture size.</summary>
                public uint MaxTextureSize
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxTextureSize;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxTextureSize = value;
                    }
                }

                /// <summary>Maximum texture layers.</summary>
                public uint MaxTextureLayers
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxTextureLayers;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxTextureLayers = value;
                    }
                }

                /// <summary>Maximum number of views.</summary>
                public uint MaxViews
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxViews;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxViews = value;
                    }
                }

                /// <summary>Maximum number of frame buffer handles.</summary>
                public uint MaxFrameBuffers
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxFrameBuffers;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxFrameBuffers = value;
                    }
                }

                /// <summary>Maximum number of frame buffer attachments.</summary>
                public uint MaxFBAttachments
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxFBAttachments;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxFBAttachments = value;
                    }
                }

                /// <summary>Maximum number of program handles.</summary>
                public uint MaxPrograms
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxPrograms;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxPrograms = value;
                    }
                }

                /// <summary>Maximum number of shader handles.</summary>
                public uint MaxShaders
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxShaders;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxShaders = value;
                    }
                }

                /// <summary>Maximum number of texture handles.</summary>
                public uint MaxTextures
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxTextures;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxTextures = value;
                    }
                }

                /// <summary>Maximum number of texture samplers.</summary>
                public uint MaxTextureSamplers
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxTextureSamplers;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxTextureSamplers = value;
                    }
                }

                /// <summary>Maximum number of compute bindings.</summary>
                public uint MaxComputeBindings
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxComputeBindings;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxComputeBindings = value;
                    }
                }

                /// <summary>Maximum number of vertex format layouts.</summary>
                public uint MaxVertexLayouts
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxVertexLayouts;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxVertexLayouts = value;
                    }
                }

                /// <summary>Maximum number of vertex streams.</summary>
                public uint MaxVertexStreams
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxVertexStreams;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxVertexStreams = value;
                    }
                }

                /// <summary>Maximum number of index buffer handles.</summary>
                public uint MaxIndexBuffers
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxIndexBuffers;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxIndexBuffers = value;
                    }
                }

                /// <summary>Maximum number of vertex buffer handles.</summary>
                public uint MaxVertexBuffers
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxVertexBuffers;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxVertexBuffers = value;
                    }
                }

                /// <summary>Maximum number of dynamic index buffer handles.</summary>
                public uint MaxDynamicIndexBuffers
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxDynamicIndexBuffers;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxDynamicIndexBuffers = value;
                    }
                }

                /// <summary>Maximum number of dynamic vertex buffer handles.</summary>
                public uint MaxDynamicVertexBuffers
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxDynamicVertexBuffers;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxDynamicVertexBuffers = value;
                    }
                }

                /// <summary>Maximum number of uniform handles.</summary>
                public uint MaxUniforms
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxUniforms;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxUniforms = value;
                    }
                }

                /// <summary>Maximum number of occlusion query handles.</summary>
                public uint MaxOcclusionQueries
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxOcclusionQueries;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxOcclusionQueries = value;
                    }
                }

                /// <summary>Maximum number of encoder threads.</summary>
                public uint MaxEncoders
                {
                    get
                    {
                        return ((__Internal*)__Instance)->maxEncoders;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->maxEncoders = value;
                    }
                }

                /// <summary>Minimum resource command buffer size.</summary>
                public uint MinResourceCbSize
                {
                    get
                    {
                        return ((__Internal*)__Instance)->minResourceCbSize;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->minResourceCbSize = value;
                    }
                }

                /// <summary>Maximum transient vertex buffer size.</summary>
                public uint TransientVbSize
                {
                    get
                    {
                        return ((__Internal*)__Instance)->transientVbSize;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->transientVbSize = value;
                    }
                }

                /// <summary>Maximum transient index buffer size.</summary>
                public uint TransientIbSize
                {
                    get
                    {
                        return ((__Internal*)__Instance)->transientIbSize;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->transientIbSize = value;
                    }
                }
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Caps> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Caps>();

            protected bool __ownsNativeInstance;

            internal static Caps __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Caps(native.ToPointer(), skipVTables);
            }

            internal static Caps __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Caps)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Caps __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Caps(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Caps(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Caps(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Caps()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Caps.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Caps(global::Bgfx.Bgfx.Caps _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Caps.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.Caps.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Caps.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Renderer backend type. See: `bgfx::RendererType`</summary>
            public global::Bgfx.Bgfx.RendererType.Enum RendererType
            {
                get
                {
                    return ((__Internal*)__Instance)->rendererType;
                }

                set
                {
                    ((__Internal*)__Instance)->rendererType = value;
                }
            }

            /// <summary>Supported functionality.</summary>
            /// <remarks>See `BGFX_CAPS_*` flags at https://bkaradzic.github.io/bgfx/bgfx.html#available-caps</remarks>
            public ulong Supported
            {
                get
                {
                    return ((__Internal*)__Instance)->supported;
                }

                set
                {
                    ((__Internal*)__Instance)->supported = value;
                }
            }

            /// <summary>Selected GPU vendor PCI id.</summary>
            public ushort VendorId
            {
                get
                {
                    return ((__Internal*)__Instance)->vendorId;
                }

                set
                {
                    ((__Internal*)__Instance)->vendorId = value;
                }
            }

            /// <summary>Selected GPU device id.</summary>
            public ushort DeviceId
            {
                get
                {
                    return ((__Internal*)__Instance)->deviceId;
                }

                set
                {
                    ((__Internal*)__Instance)->deviceId = value;
                }
            }

            /// <summary>True when NDC depth is in [-1, 1] range, otherwise its [0, 1].</summary>
            public bool HomogeneousDepth
            {
                get
                {
                    return ((__Internal*)__Instance)->homogeneousDepth != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->homogeneousDepth = (byte) (value ? 1 : 0);
                }
            }

            /// <summary>True when NDC origin is at bottom left.</summary>
            public bool OriginBottomLeft
            {
                get
                {
                    return ((__Internal*)__Instance)->originBottomLeft != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->originBottomLeft = (byte) (value ? 1 : 0);
                }
            }

            /// <summary>Number of enumerated GPUs.</summary>
            public byte NumGPUs
            {
                get
                {
                    return ((__Internal*)__Instance)->numGPUs;
                }

                set
                {
                    ((__Internal*)__Instance)->numGPUs = value;
                }
            }

            /// <summary>Enumerated GPUs.</summary>
            public global::Bgfx.Bgfx.Caps.GPU[] Gpu
            {
                get
                {
                    global::Bgfx.Bgfx.Caps.GPU[] __value = null;
                    if (((__Internal*)__Instance)->gpu != null)
                    {
                        __value = new global::Bgfx.Bgfx.Caps.GPU[4];
                        for (int i = 0; i < 4; i++)
                            __value[i] = global::Bgfx.Bgfx.Caps.GPU.__GetOrCreateInstance((IntPtr)((global::Bgfx.Bgfx.Caps.GPU.__Internal*)&(((__Internal*)__Instance)->gpu[i * sizeof(global::Bgfx.Bgfx.Caps.GPU.__Internal)])), true, true);
                    }
                    return __value;
                }

                set
                {
                    if (value != null)
                    {
                        if (value.Length != 4)
                            throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                        for (int i = 0; i < 4; i++)
                            *(global::Bgfx.Bgfx.Caps.GPU.__Internal*) &((__Internal*)__Instance)->gpu[i * sizeof(global::Bgfx.Bgfx.Caps.GPU.__Internal)] = *(global::Bgfx.Bgfx.Caps.GPU.__Internal*)value[i].__Instance;
                    }
                }
            }

            /// <summary>Renderer runtime limits.</summary>
            public global::Bgfx.Bgfx.Caps.Limits limits
            {
                get
                {
                    return global::Bgfx.Bgfx.Caps.Limits.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->limits));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->limits = *(global::Bgfx.Bgfx.Caps.Limits.__Internal*) value.__Instance;
                }
            }

            /// <summary>
            /// <para>Supported texture format capabilities flags:</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_NONE` - Texture format is not supported.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_2D` - Texture format is supported.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_2D_SRGB` - Texture as sRGB format is supported.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_2D_EMULATED` - Texture format is emulated.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_3D` - Texture format is supported.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_3D_SRGB` - Texture as sRGB format is supported.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_3D_EMULATED` - Texture format is emulated.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_CUBE` - Texture format is supported.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_CUBE_SRGB` - Texture as sRGB format is supported.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_CUBE_EMULATED` - Texture format is emulated.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_VERTEX` - Texture format can be used from vertex shader.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_IMAGE_READ` - Texture format can be used as image</para>
            /// <para>and read from.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_IMAGE_WRITE` - Texture format can be used as image</para>
            /// <para>and written to.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_FRAMEBUFFER` - Texture format can be used as frame</para>
            /// <para>buffer.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_FRAMEBUFFER_MSAA` - Texture format can be used as MSAA</para>
            /// <para>frame buffer.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_MSAA` - Texture can be sampled as MSAA.</para>
            /// <para>- `BGFX_CAPS_FORMAT_TEXTURE_MIP_AUTOGEN` - Texture format supports auto-generated</para>
            /// <para>mips.</para>
            /// </summary>
            public ushort[] Formats
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->formats, 85);
                }

                set
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 85; i++)
                            ((__Internal*)__Instance)->formats[i] = value[i];
                    }
                }
            }
        }

        /// <summary>Transient index buffer.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_transient_index_buffer_t`.</remarks>
        public unsafe partial class TransientIndexBuffer : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public partial struct __Internal
            {
                internal __IntPtr data;
                internal uint size;
                internal uint startIndex;
                internal global::Bgfx.Bgfx.IndexBufferHandle.__Internal handle;
                internal byte isIndex16;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx20TransientIndexBufferC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.TransientIndexBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.TransientIndexBuffer>();

            protected bool __ownsNativeInstance;

            internal static TransientIndexBuffer __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new TransientIndexBuffer(native.ToPointer(), skipVTables);
            }

            internal static TransientIndexBuffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (TransientIndexBuffer)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static TransientIndexBuffer __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TransientIndexBuffer(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private TransientIndexBuffer(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TransientIndexBuffer(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public TransientIndexBuffer()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.TransientIndexBuffer.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public TransientIndexBuffer(global::Bgfx.Bgfx.TransientIndexBuffer _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.TransientIndexBuffer.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.TransientIndexBuffer.__Internal*) __Instance) = *((global::Bgfx.Bgfx.TransientIndexBuffer.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Pointer to data.</summary>
            public byte* Data
            {
                get
                {
                    return (byte*) ((__Internal*)__Instance)->data;
                }

                set
                {
                    ((__Internal*)__Instance)->data = (__IntPtr) value;
                }
            }

            /// <summary>Data size.</summary>
            public uint Size
            {
                get
                {
                    return ((__Internal*)__Instance)->size;
                }

                set
                {
                    ((__Internal*)__Instance)->size = value;
                }
            }

            /// <summary>First index.</summary>
            public uint StartIndex
            {
                get
                {
                    return ((__Internal*)__Instance)->startIndex;
                }

                set
                {
                    ((__Internal*)__Instance)->startIndex = value;
                }
            }

            /// <summary>Index buffer handle.</summary>
            public global::Bgfx.Bgfx.IndexBufferHandle Handle
            {
                get
                {
                    return global::Bgfx.Bgfx.IndexBufferHandle.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->handle));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->handle = *(global::Bgfx.Bgfx.IndexBufferHandle.__Internal*) value.__Instance;
                }
            }

            /// <summary>Index buffer format is 16-bits if true, otherwise it is 32-bit.</summary>
            public bool IsIndex16
            {
                get
                {
                    return ((__Internal*)__Instance)->isIndex16 != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->isIndex16 = (byte) (value ? 1 : 0);
                }
            }
        }

        /// <summary>Transient vertex buffer.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_transient_vertex_buffer_t`.</remarks>
        public unsafe partial class TransientVertexBuffer : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public partial struct __Internal
            {
                internal __IntPtr data;
                internal uint size;
                internal uint startVertex;
                internal ushort stride;
                internal global::Bgfx.Bgfx.VertexBufferHandle.__Internal handle;
                internal global::Bgfx.Bgfx.VertexLayoutHandle.__Internal layoutHandle;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx21TransientVertexBufferC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.TransientVertexBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.TransientVertexBuffer>();

            protected bool __ownsNativeInstance;

            internal static TransientVertexBuffer __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new TransientVertexBuffer(native.ToPointer(), skipVTables);
            }

            internal static TransientVertexBuffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (TransientVertexBuffer)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static TransientVertexBuffer __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TransientVertexBuffer(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private TransientVertexBuffer(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TransientVertexBuffer(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public TransientVertexBuffer()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.TransientVertexBuffer.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public TransientVertexBuffer(global::Bgfx.Bgfx.TransientVertexBuffer _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.TransientVertexBuffer.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.TransientVertexBuffer.__Internal*) __Instance) = *((global::Bgfx.Bgfx.TransientVertexBuffer.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Pointer to data.</summary>
            public byte* Data
            {
                get
                {
                    return (byte*) ((__Internal*)__Instance)->data;
                }

                set
                {
                    ((__Internal*)__Instance)->data = (__IntPtr) value;
                }
            }

            /// <summary>Data size.</summary>
            public uint Size
            {
                get
                {
                    return ((__Internal*)__Instance)->size;
                }

                set
                {
                    ((__Internal*)__Instance)->size = value;
                }
            }

            /// <summary>First vertex.</summary>
            public uint StartVertex
            {
                get
                {
                    return ((__Internal*)__Instance)->startVertex;
                }

                set
                {
                    ((__Internal*)__Instance)->startVertex = value;
                }
            }

            /// <summary>Vertex stride.</summary>
            public ushort Stride
            {
                get
                {
                    return ((__Internal*)__Instance)->stride;
                }

                set
                {
                    ((__Internal*)__Instance)->stride = value;
                }
            }

            /// <summary>Vertex buffer handle.</summary>
            public global::Bgfx.Bgfx.VertexBufferHandle Handle
            {
                get
                {
                    return global::Bgfx.Bgfx.VertexBufferHandle.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->handle));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->handle = *(global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) value.__Instance;
                }
            }

            /// <summary>Vertex layout handle.</summary>
            public global::Bgfx.Bgfx.VertexLayoutHandle LayoutHandle
            {
                get
                {
                    return global::Bgfx.Bgfx.VertexLayoutHandle.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->layoutHandle));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->layoutHandle = *(global::Bgfx.Bgfx.VertexLayoutHandle.__Internal*) value.__Instance;
                }
            }
        }

        /// <summary>Instance data buffer info.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_instance_data_buffer_t`.</remarks>
        public unsafe partial class InstanceDataBuffer : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 24)]
            public partial struct __Internal
            {
                internal __IntPtr data;
                internal uint size;
                internal uint offset;
                internal uint num;
                internal ushort stride;
                internal global::Bgfx.Bgfx.VertexBufferHandle.__Internal handle;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx18InstanceDataBufferC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.InstanceDataBuffer> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.InstanceDataBuffer>();

            protected bool __ownsNativeInstance;

            internal static InstanceDataBuffer __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new InstanceDataBuffer(native.ToPointer(), skipVTables);
            }

            internal static InstanceDataBuffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (InstanceDataBuffer)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static InstanceDataBuffer __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new InstanceDataBuffer(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private InstanceDataBuffer(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected InstanceDataBuffer(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public InstanceDataBuffer()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.InstanceDataBuffer.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public InstanceDataBuffer(global::Bgfx.Bgfx.InstanceDataBuffer _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.InstanceDataBuffer.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.InstanceDataBuffer.__Internal*) __Instance) = *((global::Bgfx.Bgfx.InstanceDataBuffer.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Pointer to data.</summary>
            public byte* Data
            {
                get
                {
                    return (byte*) ((__Internal*)__Instance)->data;
                }

                set
                {
                    ((__Internal*)__Instance)->data = (__IntPtr) value;
                }
            }

            /// <summary>Data size.</summary>
            public uint Size
            {
                get
                {
                    return ((__Internal*)__Instance)->size;
                }

                set
                {
                    ((__Internal*)__Instance)->size = value;
                }
            }

            /// <summary>Offset in vertex buffer.</summary>
            public uint Offset
            {
                get
                {
                    return ((__Internal*)__Instance)->offset;
                }

                set
                {
                    ((__Internal*)__Instance)->offset = value;
                }
            }

            /// <summary>Number of instances.</summary>
            public uint Num
            {
                get
                {
                    return ((__Internal*)__Instance)->num;
                }

                set
                {
                    ((__Internal*)__Instance)->num = value;
                }
            }

            /// <summary>Vertex buffer stride.</summary>
            public ushort Stride
            {
                get
                {
                    return ((__Internal*)__Instance)->stride;
                }

                set
                {
                    ((__Internal*)__Instance)->stride = value;
                }
            }

            /// <summary>Vertex buffer object handle.</summary>
            public global::Bgfx.Bgfx.VertexBufferHandle Handle
            {
                get
                {
                    return global::Bgfx.Bgfx.VertexBufferHandle.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->handle));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->handle = *(global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) value.__Instance;
                }
            }
        }

        /// <summary>Texture info.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_texture_info_t`.</remarks>
        public unsafe partial class TextureInfo : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 20)]
            public partial struct __Internal
            {
                internal global::Bgfx.Bgfx.TextureFormat.Enum format;
                internal uint storageSize;
                internal ushort width;
                internal ushort height;
                internal ushort depth;
                internal ushort numLayers;
                internal byte numMips;
                internal byte bitsPerPixel;
                internal byte cubeMap;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx11TextureInfoC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.TextureInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.TextureInfo>();

            protected bool __ownsNativeInstance;

            internal static TextureInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new TextureInfo(native.ToPointer(), skipVTables);
            }

            internal static TextureInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (TextureInfo)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static TextureInfo __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new TextureInfo(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private TextureInfo(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected TextureInfo(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public TextureInfo()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.TextureInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public TextureInfo(global::Bgfx.Bgfx.TextureInfo _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.TextureInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.TextureInfo.__Internal*) __Instance) = *((global::Bgfx.Bgfx.TextureInfo.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Texture format.</summary>
            public global::Bgfx.Bgfx.TextureFormat.Enum Format
            {
                get
                {
                    return ((__Internal*)__Instance)->format;
                }

                set
                {
                    ((__Internal*)__Instance)->format = value;
                }
            }

            /// <summary>Total amount of bytes required to store texture.</summary>
            public uint StorageSize
            {
                get
                {
                    return ((__Internal*)__Instance)->storageSize;
                }

                set
                {
                    ((__Internal*)__Instance)->storageSize = value;
                }
            }

            /// <summary>Texture width.</summary>
            public ushort Width
            {
                get
                {
                    return ((__Internal*)__Instance)->width;
                }

                set
                {
                    ((__Internal*)__Instance)->width = value;
                }
            }

            /// <summary>Texture height.</summary>
            public ushort Height
            {
                get
                {
                    return ((__Internal*)__Instance)->height;
                }

                set
                {
                    ((__Internal*)__Instance)->height = value;
                }
            }

            /// <summary>Texture depth.</summary>
            public ushort Depth
            {
                get
                {
                    return ((__Internal*)__Instance)->depth;
                }

                set
                {
                    ((__Internal*)__Instance)->depth = value;
                }
            }

            /// <summary>Number of layers in texture array.</summary>
            public ushort NumLayers
            {
                get
                {
                    return ((__Internal*)__Instance)->numLayers;
                }

                set
                {
                    ((__Internal*)__Instance)->numLayers = value;
                }
            }

            /// <summary>Number of MIP maps.</summary>
            public byte NumMips
            {
                get
                {
                    return ((__Internal*)__Instance)->numMips;
                }

                set
                {
                    ((__Internal*)__Instance)->numMips = value;
                }
            }

            /// <summary>Format bits per pixel.</summary>
            public byte BitsPerPixel
            {
                get
                {
                    return ((__Internal*)__Instance)->bitsPerPixel;
                }

                set
                {
                    ((__Internal*)__Instance)->bitsPerPixel = value;
                }
            }

            /// <summary>Texture is cubemap.</summary>
            public bool CubeMap
            {
                get
                {
                    return ((__Internal*)__Instance)->cubeMap != 0;
                }

                set
                {
                    ((__Internal*)__Instance)->cubeMap = (byte) (value ? 1 : 0);
                }
            }
        }

        /// <summary>Uniform info.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_uniform_info_t`.</remarks>
        public unsafe partial class UniformInfo : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 264)]
            public partial struct __Internal
            {
                internal fixed sbyte name[256];
                internal global::Bgfx.Bgfx.UniformType.Enum type;
                internal ushort num;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx11UniformInfoC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.UniformInfo> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.UniformInfo>();

            protected bool __ownsNativeInstance;

            internal static UniformInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new UniformInfo(native.ToPointer(), skipVTables);
            }

            internal static UniformInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (UniformInfo)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static UniformInfo __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new UniformInfo(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private UniformInfo(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected UniformInfo(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public UniformInfo()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.UniformInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public UniformInfo(global::Bgfx.Bgfx.UniformInfo _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.UniformInfo.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.UniformInfo.__Internal*) __Instance) = *((global::Bgfx.Bgfx.UniformInfo.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Uniform name.</summary>
            public sbyte[] Name
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->name, 256);
                }

                set
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 256; i++)
                            ((__Internal*)__Instance)->name[i] = value[i];
                    }
                }
            }

            /// <summary>Uniform type.</summary>
            public global::Bgfx.Bgfx.UniformType.Enum Type
            {
                get
                {
                    return ((__Internal*)__Instance)->type;
                }

                set
                {
                    ((__Internal*)__Instance)->type = value;
                }
            }

            /// <summary>Number of elements in array.</summary>
            public ushort Num
            {
                get
                {
                    return ((__Internal*)__Instance)->num;
                }

                set
                {
                    ((__Internal*)__Instance)->num = value;
                }
            }
        }

        /// <summary>Frame buffer texture attachment info.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_attachment_t`.</remarks>
        public unsafe partial class Attachment : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal global::Bgfx.Bgfx.Access.Enum access;
                internal global::Bgfx.Bgfx.TextureHandle.__Internal handle;
                internal ushort mip;
                internal ushort layer;
                internal ushort numLayers;
                internal byte resolve;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx10AttachmentC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx10Attachment4initENS_13TextureHandleENS_6Access4EnumEttth", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Init(__IntPtr __instance, global::Bgfx.Bgfx.TextureHandle.__Internal _handle, global::Bgfx.Bgfx.Access.Enum _access, ushort _layer, ushort _numLayers, ushort _mip, byte _resolve);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Attachment> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Attachment>();

            protected bool __ownsNativeInstance;

            internal static Attachment __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Attachment(native.ToPointer(), skipVTables);
            }

            internal static Attachment __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Attachment)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Attachment __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Attachment(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Attachment(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Attachment(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Attachment()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Attachment.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Attachment(global::Bgfx.Bgfx.Attachment _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Attachment.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.Attachment.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Attachment.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Init attachment.</summary>
            /// <param name="_handle">Render target texture handle.</param>
            /// <param name="_access">Access. See `Access::Enum`.</param>
            /// <param name="_layer">Cubemap side or depth layer/slice to use.</param>
            /// <param name="_numLayers">Number of texture layer/slice(s) in array to use.</param>
            /// <param name="_mip">Mip level.</param>
            /// <param name="_resolve">Resolve flags. See: `BGFX_RESOLVE_*`</param>
            public void Init(global::Bgfx.Bgfx.TextureHandle _handle, global::Bgfx.Bgfx.Access.Enum _access, ushort _layer, ushort _numLayers, ushort _mip, byte _resolve)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.Init(__Instance, *(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg0, _access, _layer, _numLayers, _mip, _resolve);
            }

            /// <summary>Attachment access. See `Access::Enum`.</summary>
            public global::Bgfx.Bgfx.Access.Enum Access
            {
                get
                {
                    return ((__Internal*)__Instance)->access;
                }

                set
                {
                    ((__Internal*)__Instance)->access = value;
                }
            }

            /// <summary>Render target texture handle.</summary>
            public global::Bgfx.Bgfx.TextureHandle Handle
            {
                get
                {
                    return global::Bgfx.Bgfx.TextureHandle.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->handle));
                }

                set
                {
                    if (ReferenceEquals(value, null))
                        throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                    ((__Internal*)__Instance)->handle = *(global::Bgfx.Bgfx.TextureHandle.__Internal*) value.__Instance;
                }
            }

            /// <summary>Mip level.</summary>
            public ushort Mip
            {
                get
                {
                    return ((__Internal*)__Instance)->mip;
                }

                set
                {
                    ((__Internal*)__Instance)->mip = value;
                }
            }

            /// <summary>Cubemap side or depth layer/slice to use.</summary>
            public ushort Layer
            {
                get
                {
                    return ((__Internal*)__Instance)->layer;
                }

                set
                {
                    ((__Internal*)__Instance)->layer = value;
                }
            }

            /// <summary>Number of texture layer/slice(s) in array to use.</summary>
            public ushort NumLayers
            {
                get
                {
                    return ((__Internal*)__Instance)->numLayers;
                }

                set
                {
                    ((__Internal*)__Instance)->numLayers = value;
                }
            }

            /// <summary>Resolve flags. See: `BGFX_RESOLVE_*`</summary>
            public byte Resolve
            {
                get
                {
                    return ((__Internal*)__Instance)->resolve;
                }

                set
                {
                    ((__Internal*)__Instance)->resolve = value;
                }
            }
        }

        /// <summary>Transform data.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_transform_t`.</remarks>
        public unsafe partial class Transform : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal __IntPtr data;
                internal ushort num;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx9TransformC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Transform> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Transform>();

            protected bool __ownsNativeInstance;

            internal static Transform __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Transform(native.ToPointer(), skipVTables);
            }

            internal static Transform __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Transform)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Transform __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Transform(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Transform(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Transform(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Transform()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Transform.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Transform(global::Bgfx.Bgfx.Transform _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Transform.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.Transform.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Transform.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Pointer to first 4x4 matrix.</summary>
            public float* Data
            {
                get
                {
                    return (float*) ((__Internal*)__Instance)->data;
                }

                set
                {
                    ((__Internal*)__Instance)->data = (__IntPtr) value;
                }
            }

            /// <summary>Number of matrices.</summary>
            public ushort Num
            {
                get
                {
                    return ((__Internal*)__Instance)->num;
                }

                set
                {
                    ((__Internal*)__Instance)->num = value;
                }
            }
        }

        /// <summary>View stats.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_view_stats_t`.</remarks>
        public unsafe partial class ViewStats : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 296)]
            public partial struct __Internal
            {
                internal fixed sbyte name[256];
                internal ushort view;
                internal long cpuTimeBegin;
                internal long cpuTimeEnd;
                internal long gpuTimeBegin;
                internal long gpuTimeEnd;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx9ViewStatsC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.ViewStats> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.ViewStats>();

            protected bool __ownsNativeInstance;

            internal static ViewStats __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new ViewStats(native.ToPointer(), skipVTables);
            }

            internal static ViewStats __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (ViewStats)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static ViewStats __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new ViewStats(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private ViewStats(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected ViewStats(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public ViewStats()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.ViewStats.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public ViewStats(global::Bgfx.Bgfx.ViewStats _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.ViewStats.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.ViewStats.__Internal*) __Instance) = *((global::Bgfx.Bgfx.ViewStats.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>View name.</summary>
            public sbyte[] Name
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->name, 256);
                }

                set
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 256; i++)
                            ((__Internal*)__Instance)->name[i] = value[i];
                    }
                }
            }

            /// <summary>View id.</summary>
            public ushort View
            {
                get
                {
                    return ((__Internal*)__Instance)->view;
                }

                set
                {
                    ((__Internal*)__Instance)->view = value;
                }
            }

            /// <summary>CPU (submit) begin time.</summary>
            public long CpuTimeBegin
            {
                get
                {
                    return ((__Internal*)__Instance)->cpuTimeBegin;
                }

                set
                {
                    ((__Internal*)__Instance)->cpuTimeBegin = value;
                }
            }

            /// <summary>CPU (submit) end time.</summary>
            public long CpuTimeEnd
            {
                get
                {
                    return ((__Internal*)__Instance)->cpuTimeEnd;
                }

                set
                {
                    ((__Internal*)__Instance)->cpuTimeEnd = value;
                }
            }

            /// <summary>GPU begin time.</summary>
            public long GpuTimeBegin
            {
                get
                {
                    return ((__Internal*)__Instance)->gpuTimeBegin;
                }

                set
                {
                    ((__Internal*)__Instance)->gpuTimeBegin = value;
                }
            }

            /// <summary>GPU end time.</summary>
            public long GpuTimeEnd
            {
                get
                {
                    return ((__Internal*)__Instance)->gpuTimeEnd;
                }

                set
                {
                    ((__Internal*)__Instance)->gpuTimeEnd = value;
                }
            }
        }

        /// <summary>Encoder stats.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_encoder_stats_t`.</remarks>
        public unsafe partial class EncoderStats : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 16)]
            public partial struct __Internal
            {
                internal long cpuTimeBegin;
                internal long cpuTimeEnd;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx12EncoderStatsC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.EncoderStats> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.EncoderStats>();

            protected bool __ownsNativeInstance;

            internal static EncoderStats __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new EncoderStats(native.ToPointer(), skipVTables);
            }

            internal static EncoderStats __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (EncoderStats)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static EncoderStats __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new EncoderStats(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private EncoderStats(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected EncoderStats(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public EncoderStats()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.EncoderStats.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public EncoderStats(global::Bgfx.Bgfx.EncoderStats _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.EncoderStats.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.EncoderStats.__Internal*) __Instance) = *((global::Bgfx.Bgfx.EncoderStats.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Encoder thread CPU submit begin time.</summary>
            public long CpuTimeBegin
            {
                get
                {
                    return ((__Internal*)__Instance)->cpuTimeBegin;
                }

                set
                {
                    ((__Internal*)__Instance)->cpuTimeBegin = value;
                }
            }

            /// <summary>Encoder thread CPU submit end time.</summary>
            public long CpuTimeEnd
            {
                get
                {
                    return ((__Internal*)__Instance)->cpuTimeEnd;
                }

                set
                {
                    ((__Internal*)__Instance)->cpuTimeEnd = value;
                }
            }
        }

        /// <summary>Renderer statistics data.</summary>
        /// <remarks>
        /// <para>C99's equivalent binding is `bgfx_stats_t`.</para>
        /// <para>All time values are high-resolution timestamps, while</para>
        /// <para>time frequencies define timestamps-per-second for that hardware.</para>
        /// </remarks>
        public unsafe partial class Stats : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 216)]
            public partial struct __Internal
            {
                internal long cpuTimeFrame;
                internal long cpuTimeBegin;
                internal long cpuTimeEnd;
                internal long cpuTimerFreq;
                internal long gpuTimeBegin;
                internal long gpuTimeEnd;
                internal long gpuTimerFreq;
                internal long waitRender;
                internal long waitSubmit;
                internal uint numDraw;
                internal uint numCompute;
                internal uint numBlit;
                internal uint maxGpuLatency;
                internal ushort numDynamicIndexBuffers;
                internal ushort numDynamicVertexBuffers;
                internal ushort numFrameBuffers;
                internal ushort numIndexBuffers;
                internal ushort numOcclusionQueries;
                internal ushort numPrograms;
                internal ushort numShaders;
                internal ushort numTextures;
                internal ushort numUniforms;
                internal ushort numVertexBuffers;
                internal ushort numVertexLayouts;
                internal long textureMemoryUsed;
                internal long rtMemoryUsed;
                internal int transientVbUsed;
                internal int transientIbUsed;
                internal fixed uint numPrims[5];
                internal long gpuMemoryMax;
                internal long gpuMemoryUsed;
                internal ushort width;
                internal ushort height;
                internal ushort textWidth;
                internal ushort textHeight;
                internal ushort numViews;
                internal __IntPtr viewStats;
                internal byte numEncoders;
                internal __IntPtr encoderStats;

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx5StatsC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Stats> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Stats>();

            protected bool __ownsNativeInstance;

            internal static Stats __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Stats(native.ToPointer(), skipVTables);
            }

            internal static Stats __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Stats)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Stats __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Stats(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Stats(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Stats(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Stats()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Stats.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Stats(global::Bgfx.Bgfx.Stats _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Stats.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.Stats.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Stats.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>CPU time between two `bgfx::frame` calls.</summary>
            public long CpuTimeFrame
            {
                get
                {
                    return ((__Internal*)__Instance)->cpuTimeFrame;
                }

                set
                {
                    ((__Internal*)__Instance)->cpuTimeFrame = value;
                }
            }

            /// <summary>Render thread CPU submit begin time.</summary>
            public long CpuTimeBegin
            {
                get
                {
                    return ((__Internal*)__Instance)->cpuTimeBegin;
                }

                set
                {
                    ((__Internal*)__Instance)->cpuTimeBegin = value;
                }
            }

            /// <summary>Render thread CPU submit end time.</summary>
            public long CpuTimeEnd
            {
                get
                {
                    return ((__Internal*)__Instance)->cpuTimeEnd;
                }

                set
                {
                    ((__Internal*)__Instance)->cpuTimeEnd = value;
                }
            }

            /// <summary>CPU timer frequency. Timestamps-per-second</summary>
            public long CpuTimerFreq
            {
                get
                {
                    return ((__Internal*)__Instance)->cpuTimerFreq;
                }

                set
                {
                    ((__Internal*)__Instance)->cpuTimerFreq = value;
                }
            }

            /// <summary>GPU frame begin time.</summary>
            public long GpuTimeBegin
            {
                get
                {
                    return ((__Internal*)__Instance)->gpuTimeBegin;
                }

                set
                {
                    ((__Internal*)__Instance)->gpuTimeBegin = value;
                }
            }

            /// <summary>GPU frame end time.</summary>
            public long GpuTimeEnd
            {
                get
                {
                    return ((__Internal*)__Instance)->gpuTimeEnd;
                }

                set
                {
                    ((__Internal*)__Instance)->gpuTimeEnd = value;
                }
            }

            /// <summary>GPU timer frequency.</summary>
            public long GpuTimerFreq
            {
                get
                {
                    return ((__Internal*)__Instance)->gpuTimerFreq;
                }

                set
                {
                    ((__Internal*)__Instance)->gpuTimerFreq = value;
                }
            }

            /// <summary>Time spent waiting for render backend thread to finish issuing</summary>
            public long WaitRender
            {
                get
                {
                    return ((__Internal*)__Instance)->waitRender;
                }

                set
                {
                    ((__Internal*)__Instance)->waitRender = value;
                }
            }

            /// <summary>Time spent waiting for submit thread to advance to next frame.</summary>
            public long WaitSubmit
            {
                get
                {
                    return ((__Internal*)__Instance)->waitSubmit;
                }

                set
                {
                    ((__Internal*)__Instance)->waitSubmit = value;
                }
            }

            /// <summary>Number of draw calls submitted.</summary>
            public uint NumDraw
            {
                get
                {
                    return ((__Internal*)__Instance)->numDraw;
                }

                set
                {
                    ((__Internal*)__Instance)->numDraw = value;
                }
            }

            /// <summary>Number of compute calls submitted.</summary>
            public uint NumCompute
            {
                get
                {
                    return ((__Internal*)__Instance)->numCompute;
                }

                set
                {
                    ((__Internal*)__Instance)->numCompute = value;
                }
            }

            /// <summary>Number of blit calls submitted.</summary>
            public uint NumBlit
            {
                get
                {
                    return ((__Internal*)__Instance)->numBlit;
                }

                set
                {
                    ((__Internal*)__Instance)->numBlit = value;
                }
            }

            /// <summary>GPU driver latency.</summary>
            public uint MaxGpuLatency
            {
                get
                {
                    return ((__Internal*)__Instance)->maxGpuLatency;
                }

                set
                {
                    ((__Internal*)__Instance)->maxGpuLatency = value;
                }
            }

            /// <summary>Number of used dynamic index buffers.</summary>
            public ushort NumDynamicIndexBuffers
            {
                get
                {
                    return ((__Internal*)__Instance)->numDynamicIndexBuffers;
                }

                set
                {
                    ((__Internal*)__Instance)->numDynamicIndexBuffers = value;
                }
            }

            /// <summary>Number of used dynamic vertex buffers.</summary>
            public ushort NumDynamicVertexBuffers
            {
                get
                {
                    return ((__Internal*)__Instance)->numDynamicVertexBuffers;
                }

                set
                {
                    ((__Internal*)__Instance)->numDynamicVertexBuffers = value;
                }
            }

            /// <summary>Number of used frame buffers.</summary>
            public ushort NumFrameBuffers
            {
                get
                {
                    return ((__Internal*)__Instance)->numFrameBuffers;
                }

                set
                {
                    ((__Internal*)__Instance)->numFrameBuffers = value;
                }
            }

            /// <summary>Number of used index buffers.</summary>
            public ushort NumIndexBuffers
            {
                get
                {
                    return ((__Internal*)__Instance)->numIndexBuffers;
                }

                set
                {
                    ((__Internal*)__Instance)->numIndexBuffers = value;
                }
            }

            /// <summary>Number of used occlusion queries.</summary>
            public ushort NumOcclusionQueries
            {
                get
                {
                    return ((__Internal*)__Instance)->numOcclusionQueries;
                }

                set
                {
                    ((__Internal*)__Instance)->numOcclusionQueries = value;
                }
            }

            /// <summary>Number of used programs.</summary>
            public ushort NumPrograms
            {
                get
                {
                    return ((__Internal*)__Instance)->numPrograms;
                }

                set
                {
                    ((__Internal*)__Instance)->numPrograms = value;
                }
            }

            /// <summary>Number of used shaders.</summary>
            public ushort NumShaders
            {
                get
                {
                    return ((__Internal*)__Instance)->numShaders;
                }

                set
                {
                    ((__Internal*)__Instance)->numShaders = value;
                }
            }

            /// <summary>Number of used textures.</summary>
            public ushort NumTextures
            {
                get
                {
                    return ((__Internal*)__Instance)->numTextures;
                }

                set
                {
                    ((__Internal*)__Instance)->numTextures = value;
                }
            }

            /// <summary>Number of used uniforms.</summary>
            public ushort NumUniforms
            {
                get
                {
                    return ((__Internal*)__Instance)->numUniforms;
                }

                set
                {
                    ((__Internal*)__Instance)->numUniforms = value;
                }
            }

            /// <summary>Number of used vertex buffers.</summary>
            public ushort NumVertexBuffers
            {
                get
                {
                    return ((__Internal*)__Instance)->numVertexBuffers;
                }

                set
                {
                    ((__Internal*)__Instance)->numVertexBuffers = value;
                }
            }

            /// <summary>Number of used vertex layouts.</summary>
            public ushort NumVertexLayouts
            {
                get
                {
                    return ((__Internal*)__Instance)->numVertexLayouts;
                }

                set
                {
                    ((__Internal*)__Instance)->numVertexLayouts = value;
                }
            }

            /// <summary>Estimate of texture memory used.</summary>
            public long TextureMemoryUsed
            {
                get
                {
                    return ((__Internal*)__Instance)->textureMemoryUsed;
                }

                set
                {
                    ((__Internal*)__Instance)->textureMemoryUsed = value;
                }
            }

            /// <summary>Estimate of render target memory used.</summary>
            public long RtMemoryUsed
            {
                get
                {
                    return ((__Internal*)__Instance)->rtMemoryUsed;
                }

                set
                {
                    ((__Internal*)__Instance)->rtMemoryUsed = value;
                }
            }

            /// <summary>Amount of transient vertex buffer used.</summary>
            public int TransientVbUsed
            {
                get
                {
                    return ((__Internal*)__Instance)->transientVbUsed;
                }

                set
                {
                    ((__Internal*)__Instance)->transientVbUsed = value;
                }
            }

            /// <summary>Amount of transient index buffer used.</summary>
            public int TransientIbUsed
            {
                get
                {
                    return ((__Internal*)__Instance)->transientIbUsed;
                }

                set
                {
                    ((__Internal*)__Instance)->transientIbUsed = value;
                }
            }

            /// <summary>Number of primitives rendered.</summary>
            public uint[] NumPrims
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->numPrims, 5);
                }

                set
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 5; i++)
                            ((__Internal*)__Instance)->numPrims[i] = value[i];
                    }
                }
            }

            /// <summary>Maximum available GPU memory for application.</summary>
            public long GpuMemoryMax
            {
                get
                {
                    return ((__Internal*)__Instance)->gpuMemoryMax;
                }

                set
                {
                    ((__Internal*)__Instance)->gpuMemoryMax = value;
                }
            }

            /// <summary>Amount of GPU memory used by the application.</summary>
            public long GpuMemoryUsed
            {
                get
                {
                    return ((__Internal*)__Instance)->gpuMemoryUsed;
                }

                set
                {
                    ((__Internal*)__Instance)->gpuMemoryUsed = value;
                }
            }

            /// <summary>Backbuffer width in pixels.</summary>
            public ushort Width
            {
                get
                {
                    return ((__Internal*)__Instance)->width;
                }

                set
                {
                    ((__Internal*)__Instance)->width = value;
                }
            }

            /// <summary>Backbuffer height in pixels.</summary>
            public ushort Height
            {
                get
                {
                    return ((__Internal*)__Instance)->height;
                }

                set
                {
                    ((__Internal*)__Instance)->height = value;
                }
            }

            /// <summary>Debug text width in characters.</summary>
            public ushort TextWidth
            {
                get
                {
                    return ((__Internal*)__Instance)->textWidth;
                }

                set
                {
                    ((__Internal*)__Instance)->textWidth = value;
                }
            }

            /// <summary>Debug text height in characters.</summary>
            public ushort TextHeight
            {
                get
                {
                    return ((__Internal*)__Instance)->textHeight;
                }

                set
                {
                    ((__Internal*)__Instance)->textHeight = value;
                }
            }

            /// <summary>Number of view stats.</summary>
            public ushort NumViews
            {
                get
                {
                    return ((__Internal*)__Instance)->numViews;
                }

                set
                {
                    ((__Internal*)__Instance)->numViews = value;
                }
            }

            /// <summary>Array of View stats.</summary>
            public global::Bgfx.Bgfx.ViewStats ViewStats
            {
                get
                {
                    var __result0 = global::Bgfx.Bgfx.ViewStats.__GetOrCreateInstance(((__Internal*)__Instance)->viewStats, false);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->viewStats = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }

            /// <summary>Number of encoders used during frame.</summary>
            public byte NumEncoders
            {
                get
                {
                    return ((__Internal*)__Instance)->numEncoders;
                }

                set
                {
                    ((__Internal*)__Instance)->numEncoders = value;
                }
            }

            /// <summary>Array of encoder stats.</summary>
            public global::Bgfx.Bgfx.EncoderStats EncoderStats
            {
                get
                {
                    var __result0 = global::Bgfx.Bgfx.EncoderStats.__GetOrCreateInstance(((__Internal*)__Instance)->encoderStats, false);
                    return __result0;
                }

                set
                {
                    ((__Internal*)__Instance)->encoderStats = value is null ? __IntPtr.Zero : value.__Instance;
                }
            }
        }

        /// <summary>
        /// <para>Encoders are used for submitting draw calls from multiple threads. Only one encoder</para>
        /// <para>per thread should be used. Use `bgfx::begin()` to obtain an encoder for a thread.</para>
        /// </summary>
        /// <remarks>C99's equivalent binding is `bgfx_encoder`.</remarks>
        public unsafe partial class Encoder : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 1)]
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx7EncoderC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder9setMarkerEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMarker(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _marker);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder8setStateEmj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetState(__IntPtr __instance, ulong _state, uint _rgba);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder12setConditionENS_20OcclusionQueryHandleEb", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCondition(__IntPtr __instance, global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal _handle, bool _visible);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder10setStencilEjj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStencil(__IntPtr __instance, uint _fstencil, uint _bstencil);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder10setScissorEtttt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort SetScissor(__IntPtr __instance, ushort _x, ushort _y, ushort _width, ushort _height);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder10setScissorEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScissor(__IntPtr __instance, ushort _cache);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder12setTransformEPKvt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint SetTransform(__IntPtr __instance, __IntPtr _mtx, ushort _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder14allocTransformEPNS_9TransformEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint AllocTransform(__IntPtr __instance, __IntPtr _transform, ushort _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder12setTransformEjt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTransform(__IntPtr __instance, uint _cache, ushort _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder10setUniformENS_13UniformHandleEPKvt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetUniform(__IntPtr __instance, global::Bgfx.Bgfx.UniformHandle.__Internal _handle, __IntPtr _value, ushort _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder14setIndexBufferENS_17IndexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndexBuffer(__IntPtr __instance, global::Bgfx.Bgfx.IndexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder14setIndexBufferENS_17IndexBufferHandleEjj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndexBuffer(__IntPtr __instance, global::Bgfx.Bgfx.IndexBufferHandle.__Internal _handle, uint _firstIndex, uint _numIndices);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder14setIndexBufferENS_24DynamicIndexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndexBuffer_1(__IntPtr __instance, global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder14setIndexBufferENS_24DynamicIndexBufferHandleEjj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndexBuffer_1(__IntPtr __instance, global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal _handle, uint _firstIndex, uint _numIndices);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder14setIndexBufferEPKNS_20TransientIndexBufferE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndexBuffer(__IntPtr __instance, __IntPtr _tib);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder14setIndexBufferEPKNS_20TransientIndexBufferEjj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndexBuffer(__IntPtr __instance, __IntPtr _tib, uint _firstIndex, uint _numIndices);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder15setVertexBufferEhNS_18VertexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVertexBuffer(__IntPtr __instance, byte _stream, global::Bgfx.Bgfx.VertexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder15setVertexBufferEhNS_18VertexBufferHandleEjjNS_18VertexLayoutHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVertexBuffer(__IntPtr __instance, byte _stream, global::Bgfx.Bgfx.VertexBufferHandle.__Internal _handle, uint _startVertex, uint _numVertices, global::Bgfx.Bgfx.VertexLayoutHandle.__Internal _layoutHandle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder15setVertexBufferEhNS_25DynamicVertexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVertexBuffer_1(__IntPtr __instance, byte _stream, global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder15setVertexBufferEhNS_25DynamicVertexBufferHandleEjjNS_18VertexLayoutHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVertexBuffer_1(__IntPtr __instance, byte _stream, global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal _handle, uint _startVertex, uint _numVertices, global::Bgfx.Bgfx.VertexLayoutHandle.__Internal _layoutHandle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder15setVertexBufferEhPKNS_21TransientVertexBufferE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVertexBuffer(__IntPtr __instance, byte _stream, __IntPtr _tvb);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder15setVertexBufferEhPKNS_21TransientVertexBufferEjjNS_18VertexLayoutHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVertexBuffer(__IntPtr __instance, byte _stream, __IntPtr _tvb, uint _startVertex, uint _numVertices, global::Bgfx.Bgfx.VertexLayoutHandle.__Internal _layoutHandle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder14setVertexCountEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVertexCount(__IntPtr __instance, uint _numVertices);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder21setInstanceDataBufferEPKNS_18InstanceDataBufferE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInstanceDataBuffer(__IntPtr __instance, __IntPtr _idb);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder21setInstanceDataBufferEPKNS_18InstanceDataBufferEjj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInstanceDataBuffer(__IntPtr __instance, __IntPtr _idb, uint _start, uint _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder21setInstanceDataBufferENS_18VertexBufferHandleEjj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInstanceDataBuffer(__IntPtr __instance, global::Bgfx.Bgfx.VertexBufferHandle.__Internal _handle, uint _start, uint _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder21setInstanceDataBufferENS_25DynamicVertexBufferHandleEjj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInstanceDataBuffer_1(__IntPtr __instance, global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal _handle, uint _start, uint _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder16setInstanceCountEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInstanceCount(__IntPtr __instance, uint _numInstances);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder10setTextureEhNS_13UniformHandleENS_13TextureHandleEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTexture(__IntPtr __instance, byte _stage, global::Bgfx.Bgfx.UniformHandle.__Internal _sampler, global::Bgfx.Bgfx.TextureHandle.__Internal _handle, uint _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder5touchEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Touch(__IntPtr __instance, ushort _id);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder6submitEtNS_13ProgramHandleEjh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Submit(__IntPtr __instance, ushort _id, global::Bgfx.Bgfx.ProgramHandle.__Internal _program, uint _depth, byte _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder6submitEtNS_13ProgramHandleENS_20OcclusionQueryHandleEjh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Submit(__IntPtr __instance, ushort _id, global::Bgfx.Bgfx.ProgramHandle.__Internal _program, global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal _occlusionQuery, uint _depth, byte _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder6submitEtNS_13ProgramHandleENS_20IndirectBufferHandleEttjh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Submit(__IntPtr __instance, ushort _id, global::Bgfx.Bgfx.ProgramHandle.__Internal _program, global::Bgfx.Bgfx.IndirectBufferHandle.__Internal _indirectHandle, ushort _start, ushort _num, uint _depth, byte _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder9setBufferEhNS_17IndexBufferHandleENS_6Access4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBuffer(__IntPtr __instance, byte _stage, global::Bgfx.Bgfx.IndexBufferHandle.__Internal _handle, global::Bgfx.Bgfx.Access.Enum _access);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder9setBufferEhNS_18VertexBufferHandleENS_6Access4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBuffer_1(__IntPtr __instance, byte _stage, global::Bgfx.Bgfx.VertexBufferHandle.__Internal _handle, global::Bgfx.Bgfx.Access.Enum _access);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder9setBufferEhNS_24DynamicIndexBufferHandleENS_6Access4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBuffer_2(__IntPtr __instance, byte _stage, global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal _handle, global::Bgfx.Bgfx.Access.Enum _access);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder9setBufferEhNS_25DynamicVertexBufferHandleENS_6Access4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBuffer_3(__IntPtr __instance, byte _stage, global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal _handle, global::Bgfx.Bgfx.Access.Enum _access);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder9setBufferEhNS_20IndirectBufferHandleENS_6Access4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBuffer_4(__IntPtr __instance, byte _stage, global::Bgfx.Bgfx.IndirectBufferHandle.__Internal _handle, global::Bgfx.Bgfx.Access.Enum _access);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder8setImageEhNS_13TextureHandleEhNS_6Access4EnumENS_13TextureFormat4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetImage(__IntPtr __instance, byte _stage, global::Bgfx.Bgfx.TextureHandle.__Internal _handle, byte _mip, global::Bgfx.Bgfx.Access.Enum _access, global::Bgfx.Bgfx.TextureFormat.Enum _format);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder8dispatchEtNS_13ProgramHandleEjjjh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Dispatch(__IntPtr __instance, ushort _id, global::Bgfx.Bgfx.ProgramHandle.__Internal _handle, uint _numX, uint _numY, uint _numZ, byte _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder8dispatchEtNS_13ProgramHandleENS_20IndirectBufferHandleEtth", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Dispatch_1(__IntPtr __instance, ushort _id, global::Bgfx.Bgfx.ProgramHandle.__Internal _handle, global::Bgfx.Bgfx.IndirectBufferHandle.__Internal _indirectHandle, ushort _start, ushort _num, byte _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder7discardEh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Discard(__IntPtr __instance, byte _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder4blitEtNS_13TextureHandleEttS1_tttt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Blit(__IntPtr __instance, ushort _id, global::Bgfx.Bgfx.TextureHandle.__Internal _dst, ushort _dstX, ushort _dstY, global::Bgfx.Bgfx.TextureHandle.__Internal _src, ushort _srcX, ushort _srcY, ushort _width, ushort _height);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7Encoder4blitEtNS_13TextureHandleEhtttS1_htttttt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Blit(__IntPtr __instance, ushort _id, global::Bgfx.Bgfx.TextureHandle.__Internal _dst, byte _dstMip, ushort _dstX, ushort _dstY, ushort _dstZ, global::Bgfx.Bgfx.TextureHandle.__Internal _src, byte _srcMip, ushort _srcX, ushort _srcY, ushort _srcZ, ushort _width, ushort _height, ushort _depth);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Encoder> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.Encoder>();

            protected bool __ownsNativeInstance;

            internal static Encoder __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new Encoder(native.ToPointer(), skipVTables);
            }

            internal static Encoder __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (Encoder)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static Encoder __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new Encoder(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private Encoder(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected Encoder(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public Encoder()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Encoder.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public Encoder(global::Bgfx.Bgfx.Encoder _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.Encoder.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.Encoder.__Internal*) __Instance) = *((global::Bgfx.Bgfx.Encoder.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>Sets a debug marker. This allows you to group</para>
            /// <para>graphics calls together for easy browsing in</para>
            /// <para>graphics debugging tools.</para>
            /// </summary>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_marker`.</remarks>
            public void SetMarker(string _marker)
            {
                __Internal.SetMarker(__Instance, _marker);
            }

            /// <summary>Set render states for draw primitive.</summary>
            /// <param name="_state">
            /// <para>State flags. Default state for primitive type is</para>
            /// <para>triangles. See: `BGFX_STATE_DEFAULT`.</para>
            /// <para>- `BGFX_STATE_DEPTH_TEST_*` - Depth test function.</para>
            /// <para>- `BGFX_STATE_BLEND_*` - See remark 1 about BGFX_STATE_BLEND_FUNC.</para>
            /// <para>- `BGFX_STATE_BLEND_EQUATION_*` - See remark 2.</para>
            /// <para>- `BGFX_STATE_CULL_*` - Backface culling mode.</para>
            /// <para>- `BGFX_STATE_WRITE_*` - Enable R, G, B, A or Z write.</para>
            /// <para>- `BGFX_STATE_MSAA` - Enable hardware multisample antialiasing.</para>
            /// <para>- `BGFX_STATE_PT_[TRISTRIP/LINES/POINTS]` - Primitive type.</para>
            /// </param>
            /// <param name="_rgba">
            /// <para>Sets blend factor used by `BGFX_STATE_BLEND_FACTOR` and</para>
            /// <para>`BGFX_STATE_BLEND_INV_FACTOR` blend modes.</para>
            /// </param>
            /// <remarks>
            /// <para>1. To set up more complex states use:</para>
            /// <para>`BGFX_STATE_ALPHA_REF(_ref)`,</para>
            /// <para>`BGFX_STATE_POINT_SIZE(_size)`,</para>
            /// <para>`BGFX_STATE_BLEND_FUNC(_src, _dst)`,</para>
            /// <para>`BGFX_STATE_BLEND_FUNC_SEPARATE(_srcRGB, _dstRGB, _srcA, _dstA)`,</para>
            /// <para>`BGFX_STATE_BLEND_EQUATION(_equation)`,</para>
            /// <para>`BGFX_STATE_BLEND_EQUATION_SEPARATE(_equationRGB, _equationA)`</para>
            /// <para>2. `BGFX_STATE_BLEND_EQUATION_ADD` is set when no other blend</para>
            /// <para>equation is specified.</para>
            /// <para>C99's equivalent binding is `bgfx_encoder_set_state`.</para>
            /// </remarks>
            public void SetState(ulong _state, uint _rgba)
            {
                __Internal.SetState(__Instance, _state, _rgba);
            }

            /// <summary>Set condition for rendering.</summary>
            /// <param name="_handle">Occlusion query handle.</param>
            /// <param name="_visible">Render if occlusion query is visible.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_condition`.</remarks>
            public void SetCondition(global::Bgfx.Bgfx.OcclusionQueryHandle _handle, bool _visible)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetCondition(__Instance, *(global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal*) __arg0, _visible);
            }

            /// <summary>Set stencil test state.</summary>
            /// <param name="_fstencil">Front stencil state.</param>
            /// <param name="_bstencil">
            /// <para>Back stencil state. If back is set to `BGFX_STENCIL_NONE`</para>
            /// <para>_fstencil is applied to both front and back facing primitives.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_stencil`.</remarks>
            public void SetStencil(uint _fstencil, uint _bstencil)
            {
                __Internal.SetStencil(__Instance, _fstencil, _bstencil);
            }

            /// <summary>
            /// <para>Set scissor for draw primitive. To scissor for all primitives in</para>
            /// <para>view see `bgfx::setViewScissor`.</para>
            /// </summary>
            /// <param name="_x">Position x from the left side of the window.</param>
            /// <param name="_y">Position y from the top of the window.</param>
            /// <param name="_width">Width of scissor region.</param>
            /// <param name="_height">Height of scissor region.</param>
            /// <remarks>
            /// <para>Scissor cache index.</para>
            /// <para>C99's equivalent binding is `bgfx_encoder_set_scissor`.</para>
            /// </remarks>
            public ushort SetScissor(ushort _x, ushort _y, ushort _width, ushort _height)
            {
                var __ret = __Internal.SetScissor(__Instance, _x, _y, _width, _height);
                return __ret;
            }

            /// <summary>Set scissor from cache for draw primitive.</summary>
            /// <param name="_cache">
            /// <para>Index in scissor cache.</para>
            /// <para>Pass UINT16_MAX to have primitive use view scissor instead.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_scissor_cached`.</remarks>
            public void SetScissor(ushort _cache)
            {
                __Internal.SetScissor(__Instance, _cache);
            }

            /// <summary>
            /// <para>Set model matrix for draw primitive. If it is not called, model will</para>
            /// <para>be rendered with identity model matrix.</para>
            /// </summary>
            /// <param name="_mtx">Pointer to first matrix in array.</param>
            /// <param name="_num">Number of matrices in array.</param>
            /// <remarks>
            /// <para>Index into matrix cache in case the same model matrix has</para>
            /// <para>to be used for other draw primitive call.</para>
            /// <para>C99's equivalent binding is `bgfx_encoder_set_transform`.</para>
            /// </remarks>
            public uint SetTransform(__IntPtr _mtx, ushort _num)
            {
                var __ret = __Internal.SetTransform(__Instance, _mtx, _num);
                return __ret;
            }

            /// <summary>Reserve `_num` matrices in internal matrix cache.</summary>
            /// <param name="_transform">Pointer to `Transform` structure.</param>
            /// <param name="_num">Number of matrices.</param>
            /// <remarks>
            /// <para>Index into matrix cache.</para>
            /// <para>Pointer returned can be modified until `bgfx::frame` is called.</para>
            /// <para>C99's equivalent binding is `bgfx_encoder_alloc_transform`.</para>
            /// </remarks>
            public uint AllocTransform(global::Bgfx.Bgfx.Transform _transform, ushort _num)
            {
                var __arg0 = _transform is null ? __IntPtr.Zero : _transform.__Instance;
                var __ret = __Internal.AllocTransform(__Instance, __arg0, _num);
                return __ret;
            }

            /// <summary>Set model matrix from matrix cache for draw primitive.</summary>
            /// <param name="_cache">Index in matrix cache.</param>
            /// <param name="_num">Number of matrices from cache.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_transform_cached`.</remarks>
            public void SetTransform(uint _cache, ushort _num)
            {
                __Internal.SetTransform(__Instance, _cache, _num);
            }

            /// <summary>Set shader uniform parameter for draw primitive.</summary>
            /// <param name="_handle">Uniform.</param>
            /// <param name="_value">Pointer to uniform data.</param>
            /// <param name="_num">
            /// <para>Number of elements. Passing `UINT16_MAX` will</para>
            /// <para>use the _num passed on uniform creation.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_uniform`.</remarks>
            public void SetUniform(global::Bgfx.Bgfx.UniformHandle _handle, __IntPtr _value, ushort _num)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetUniform(__Instance, *(global::Bgfx.Bgfx.UniformHandle.__Internal*) __arg0, _value, _num);
            }

            /// <summary>Set index buffer for draw primitive.</summary>
            /// <param name="_handle">Index buffer.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_index_buffer`.</remarks>
            public void SetIndexBuffer(global::Bgfx.Bgfx.IndexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetIndexBuffer(__Instance, *(global::Bgfx.Bgfx.IndexBufferHandle.__Internal*) __arg0);
            }

            /// <summary>Set index buffer for draw primitive.</summary>
            /// <param name="_handle">Index buffer.</param>
            /// <param name="_firstIndex">First index to render.</param>
            /// <param name="_numIndices">Number of indices to render.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_index_buffer`.</remarks>
            public void SetIndexBuffer(global::Bgfx.Bgfx.IndexBufferHandle _handle, uint _firstIndex, uint _numIndices)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetIndexBuffer(__Instance, *(global::Bgfx.Bgfx.IndexBufferHandle.__Internal*) __arg0, _firstIndex, _numIndices);
            }

            /// <summary>Set index buffer for draw primitive.</summary>
            /// <param name="_handle">Dynamic index buffer.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_dynamic_index_buffer`.</remarks>
            public void SetIndexBuffer(global::Bgfx.Bgfx.DynamicIndexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetIndexBuffer_1(__Instance, *(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal*) __arg0);
            }

            /// <summary>Set index buffer for draw primitive.</summary>
            /// <param name="_handle">Dynamic index buffer.</param>
            /// <param name="_firstIndex">First index to render.</param>
            /// <param name="_numIndices">Number of indices to render.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_dynamic_index_buffer`.</remarks>
            public void SetIndexBuffer(global::Bgfx.Bgfx.DynamicIndexBufferHandle _handle, uint _firstIndex, uint _numIndices)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetIndexBuffer_1(__Instance, *(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal*) __arg0, _firstIndex, _numIndices);
            }

            /// <summary>Set index buffer for draw primitive.</summary>
            /// <param name="_tib">Transient index buffer.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_transient_index_buffer`.</remarks>
            public void SetIndexBuffer(global::Bgfx.Bgfx.TransientIndexBuffer _tib)
            {
                var __arg0 = _tib is null ? __IntPtr.Zero : _tib.__Instance;
                __Internal.SetIndexBuffer(__Instance, __arg0);
            }

            /// <summary>Set index buffer for draw primitive.</summary>
            /// <param name="_tib">Transient index buffer.</param>
            /// <param name="_firstIndex">First index to render.</param>
            /// <param name="_numIndices">Number of indices to render.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_transient_index_buffer`.</remarks>
            public void SetIndexBuffer(global::Bgfx.Bgfx.TransientIndexBuffer _tib, uint _firstIndex, uint _numIndices)
            {
                var __arg0 = _tib is null ? __IntPtr.Zero : _tib.__Instance;
                __Internal.SetIndexBuffer(__Instance, __arg0, _firstIndex, _numIndices);
            }

            /// <summary>Set vertex buffer for draw primitive.</summary>
            /// <param name="_stream">Vertex stream.</param>
            /// <param name="_handle">Vertex buffer.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_vertex_buffer`.</remarks>
            public void SetVertexBuffer(byte _stream, global::Bgfx.Bgfx.VertexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetVertexBuffer(__Instance, _stream, *(global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) __arg1);
            }

            /// <summary>Set vertex buffer for draw primitive.</summary>
            /// <param name="_stream">Vertex stream.</param>
            /// <param name="_handle">Vertex buffer.</param>
            /// <param name="_startVertex">First vertex to render.</param>
            /// <param name="_numVertices">Number of vertices to render.</param>
            /// <param name="_layoutHandle">
            /// <para>Vertex layout for aliasing vertex buffer. If invalid handle is</para>
            /// <para>used, vertex layout used for creation of vertex buffer will be used.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_vertex_buffer`.</remarks>
            public void SetVertexBuffer(byte _stream, global::Bgfx.Bgfx.VertexBufferHandle _handle, uint _startVertex, uint _numVertices, global::Bgfx.Bgfx.VertexLayoutHandle _layoutHandle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                if (ReferenceEquals(_layoutHandle, null))
                    throw new global::System.ArgumentNullException("_layoutHandle", "Cannot be null because it is passed by value.");
                var __arg4 = _layoutHandle.__Instance;
                __Internal.SetVertexBuffer(__Instance, _stream, *(global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) __arg1, _startVertex, _numVertices, *(global::Bgfx.Bgfx.VertexLayoutHandle.__Internal*) __arg4);
            }

            /// <summary>Set vertex buffer for draw primitive.</summary>
            /// <param name="_stream">Vertex stream.</param>
            /// <param name="_handle">Dynamic vertex buffer.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_dynamic_vertex_buffer`.</remarks>
            public void SetVertexBuffer(byte _stream, global::Bgfx.Bgfx.DynamicVertexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetVertexBuffer_1(__Instance, _stream, *(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal*) __arg1);
            }

            /// <summary>Set vertex buffer for draw primitive.</summary>
            /// <param name="_stream">Vertex stream.</param>
            /// <param name="_handle">Dynamic vertex buffer.</param>
            /// <param name="_startVertex">First vertex to render.</param>
            /// <param name="_numVertices">Number of vertices to render.</param>
            /// <param name="_layoutHandle">
            /// <para>Vertex layout for aliasing vertex buffer. If invalid handle is</para>
            /// <para>used, vertex layout used for creation of vertex buffer will be used.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_dynamic_vertex_buffer`.</remarks>
            public void SetVertexBuffer(byte _stream, global::Bgfx.Bgfx.DynamicVertexBufferHandle _handle, uint _startVertex, uint _numVertices, global::Bgfx.Bgfx.VertexLayoutHandle _layoutHandle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                if (ReferenceEquals(_layoutHandle, null))
                    throw new global::System.ArgumentNullException("_layoutHandle", "Cannot be null because it is passed by value.");
                var __arg4 = _layoutHandle.__Instance;
                __Internal.SetVertexBuffer_1(__Instance, _stream, *(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal*) __arg1, _startVertex, _numVertices, *(global::Bgfx.Bgfx.VertexLayoutHandle.__Internal*) __arg4);
            }

            /// <summary>Set vertex buffer for draw primitive.</summary>
            /// <param name="_stream">Vertex stream.</param>
            /// <param name="_tvb">Transient vertex buffer.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_transient_vertex_buffer`.</remarks>
            public void SetVertexBuffer(byte _stream, global::Bgfx.Bgfx.TransientVertexBuffer _tvb)
            {
                var __arg1 = _tvb is null ? __IntPtr.Zero : _tvb.__Instance;
                __Internal.SetVertexBuffer(__Instance, _stream, __arg1);
            }

            /// <summary>Set vertex buffer for draw primitive.</summary>
            /// <param name="_stream">Vertex stream.</param>
            /// <param name="_tvb">Transient vertex buffer.</param>
            /// <param name="_startVertex">First vertex to render.</param>
            /// <param name="_numVertices">Number of vertices to render.</param>
            /// <param name="_layoutHandle">
            /// <para>Vertex layout for aliasing vertex buffer. If invalid handle is</para>
            /// <para>used, vertex layout used for creation of vertex buffer will be used.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_transient_vertex_buffer`.</remarks>
            public void SetVertexBuffer(byte _stream, global::Bgfx.Bgfx.TransientVertexBuffer _tvb, uint _startVertex, uint _numVertices, global::Bgfx.Bgfx.VertexLayoutHandle _layoutHandle)
            {
                var __arg1 = _tvb is null ? __IntPtr.Zero : _tvb.__Instance;
                if (ReferenceEquals(_layoutHandle, null))
                    throw new global::System.ArgumentNullException("_layoutHandle", "Cannot be null because it is passed by value.");
                var __arg4 = _layoutHandle.__Instance;
                __Internal.SetVertexBuffer(__Instance, _stream, __arg1, _startVertex, _numVertices, *(global::Bgfx.Bgfx.VertexLayoutHandle.__Internal*) __arg4);
            }

            /// <summary>
            /// <para>Set number of vertices for auto generated vertices use in conjunction</para>
            /// <para>with gl_VertexID.</para>
            /// </summary>
            /// <param name="_numVertices">Number of vertices.</param>
            /// <remarks>
            /// <para>Availability depends on: `BGFX_CAPS_VERTEX_ID`.</para>
            /// <para>C99's equivalent binding is `bgfx_encoder_set_vertex_count`.</para>
            /// </remarks>
            public void SetVertexCount(uint _numVertices)
            {
                __Internal.SetVertexCount(__Instance, _numVertices);
            }

            /// <summary>Set instance data buffer for draw primitive.</summary>
            /// <param name="_idb">Transient instance data buffer.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_instance_data_buffer`.</remarks>
            public void SetInstanceDataBuffer(global::Bgfx.Bgfx.InstanceDataBuffer _idb)
            {
                var __arg0 = _idb is null ? __IntPtr.Zero : _idb.__Instance;
                __Internal.SetInstanceDataBuffer(__Instance, __arg0);
            }

            /// <summary>Set instance data buffer for draw primitive.</summary>
            /// <param name="_idb">Transient instance data buffer.</param>
            /// <param name="_start">First instance data.</param>
            /// <param name="_num">Number of data instances.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_instance_data_buffer`.</remarks>
            public void SetInstanceDataBuffer(global::Bgfx.Bgfx.InstanceDataBuffer _idb, uint _start, uint _num)
            {
                var __arg0 = _idb is null ? __IntPtr.Zero : _idb.__Instance;
                __Internal.SetInstanceDataBuffer(__Instance, __arg0, _start, _num);
            }

            /// <summary>Set instance data buffer for draw primitive.</summary>
            /// <param name="_handle">Vertex buffer.</param>
            /// <param name="_start">First instance data.</param>
            /// <param name="_num">Number of data instances.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_instance_data_from_vertex_buffer`.</remarks>
            public void SetInstanceDataBuffer(global::Bgfx.Bgfx.VertexBufferHandle _handle, uint _start, uint _num)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetInstanceDataBuffer(__Instance, *(global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) __arg0, _start, _num);
            }

            /// <summary>Set instance data buffer for draw primitive.</summary>
            /// <param name="_handle">Vertex buffer.</param>
            /// <param name="_start">First instance data.</param>
            /// <param name="_num">Number of data instances.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_instance_data_from_dynamic_vertex_buffer`.</remarks>
            public void SetInstanceDataBuffer(global::Bgfx.Bgfx.DynamicVertexBufferHandle _handle, uint _start, uint _num)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetInstanceDataBuffer_1(__Instance, *(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal*) __arg0, _start, _num);
            }

            /// <summary>
            /// <para>Set number of instances for auto generated instances use in conjunction</para>
            /// <para>with gl_InstanceID.</para>
            /// </summary>
            /// <param name="_numInstances">Number of instances.</param>
            /// <remarks>
            /// <para>Availability depends on: `BGFX_CAPS_VERTEX_ID`.</para>
            /// <para>C99's equivalent binding is `bgfx_encoder_set_instance_count`.</para>
            /// </remarks>
            public void SetInstanceCount(uint _numInstances)
            {
                __Internal.SetInstanceCount(__Instance, _numInstances);
            }

            /// <summary>Set texture stage for draw primitive.</summary>
            /// <param name="_stage">Texture unit.</param>
            /// <param name="_sampler">Program sampler.</param>
            /// <param name="_handle">Texture handle.</param>
            /// <param name="_flags">
            /// <para>Texture sampling mode. Default value UINT32_MAX uses</para>
            /// <para>texture sampling settings from the texture.</para>
            /// <para>- `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap</para>
            /// <para>mode.</para>
            /// <para>- `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic</para>
            /// <para>sampling.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_texture`.</remarks>
            public void SetTexture(byte _stage, global::Bgfx.Bgfx.UniformHandle _sampler, global::Bgfx.Bgfx.TextureHandle _handle, uint _flags)
            {
                if (ReferenceEquals(_sampler, null))
                    throw new global::System.ArgumentNullException("_sampler", "Cannot be null because it is passed by value.");
                var __arg1 = _sampler.__Instance;
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg2 = _handle.__Instance;
                __Internal.SetTexture(__Instance, _stage, *(global::Bgfx.Bgfx.UniformHandle.__Internal*) __arg1, *(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg2, _flags);
            }

            /// <summary>
            /// <para>Submit an empty primitive for rendering. Uniforms and draw state</para>
            /// <para>will be applied but no geometry will be submitted. Useful in cases</para>
            /// <para>when no other draw/compute primitive is submitted to view, but it's</para>
            /// <para>desired to execute clear view.</para>
            /// </summary>
            /// <param name="_id">View id.</param>
            /// <remarks>
            /// <para>These empty draw calls will sort before ordinary draw calls.</para>
            /// <para>C99's equivalent binding is `bgfx_encoder_touch`.</para>
            /// </remarks>
            public void Touch(ushort _id)
            {
                __Internal.Touch(__Instance, _id);
            }

            /// <summary>Submit primitive for rendering.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_program">Program.</param>
            /// <param name="_depth">Depth for sorting.</param>
            /// <param name="_flags">Discard or preserve states. See `BGFX_DISCARD_*`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_submit`.</remarks>
            public void Submit(ushort _id, global::Bgfx.Bgfx.ProgramHandle _program, uint _depth, byte _flags)
            {
                if (ReferenceEquals(_program, null))
                    throw new global::System.ArgumentNullException("_program", "Cannot be null because it is passed by value.");
                var __arg1 = _program.__Instance;
                __Internal.Submit(__Instance, _id, *(global::Bgfx.Bgfx.ProgramHandle.__Internal*) __arg1, _depth, _flags);
            }

            /// <summary>Submit primitive with occlusion query for rendering.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_program">Program.</param>
            /// <param name="_occlusionQuery">Occlusion query.</param>
            /// <param name="_depth">Depth for sorting.</param>
            /// <param name="_flags">Discard or preserve states. See `BGFX_DISCARD_*`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_submit_occlusion_query`.</remarks>
            public void Submit(ushort _id, global::Bgfx.Bgfx.ProgramHandle _program, global::Bgfx.Bgfx.OcclusionQueryHandle _occlusionQuery, uint _depth, byte _flags)
            {
                if (ReferenceEquals(_program, null))
                    throw new global::System.ArgumentNullException("_program", "Cannot be null because it is passed by value.");
                var __arg1 = _program.__Instance;
                if (ReferenceEquals(_occlusionQuery, null))
                    throw new global::System.ArgumentNullException("_occlusionQuery", "Cannot be null because it is passed by value.");
                var __arg2 = _occlusionQuery.__Instance;
                __Internal.Submit(__Instance, _id, *(global::Bgfx.Bgfx.ProgramHandle.__Internal*) __arg1, *(global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal*) __arg2, _depth, _flags);
            }

            /// <summary>
            /// <para>Submit primitive for rendering with index and instance data info from</para>
            /// <para>indirect buffer.</para>
            /// </summary>
            /// <param name="_id">View id.</param>
            /// <param name="_program">Program.</param>
            /// <param name="_indirectHandle">Indirect buffer.</param>
            /// <param name="_start">First element in indirect buffer.</param>
            /// <param name="_num">Number of dispatches.</param>
            /// <param name="_depth">Depth for sorting.</param>
            /// <param name="_flags">Discard or preserve states. See `BGFX_DISCARD_*`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_submit_indirect`.</remarks>
            public void Submit(ushort _id, global::Bgfx.Bgfx.ProgramHandle _program, global::Bgfx.Bgfx.IndirectBufferHandle _indirectHandle, ushort _start, ushort _num, uint _depth, byte _flags)
            {
                if (ReferenceEquals(_program, null))
                    throw new global::System.ArgumentNullException("_program", "Cannot be null because it is passed by value.");
                var __arg1 = _program.__Instance;
                if (ReferenceEquals(_indirectHandle, null))
                    throw new global::System.ArgumentNullException("_indirectHandle", "Cannot be null because it is passed by value.");
                var __arg2 = _indirectHandle.__Instance;
                __Internal.Submit(__Instance, _id, *(global::Bgfx.Bgfx.ProgramHandle.__Internal*) __arg1, *(global::Bgfx.Bgfx.IndirectBufferHandle.__Internal*) __arg2, _start, _num, _depth, _flags);
            }

            /// <summary>Set compute index buffer.</summary>
            /// <param name="_stage">Compute stage.</param>
            /// <param name="_handle">Index buffer handle.</param>
            /// <param name="_access">Buffer access. See `Access::Enum`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_compute_index_buffer`.</remarks>
            public void SetBuffer(byte _stage, global::Bgfx.Bgfx.IndexBufferHandle _handle, global::Bgfx.Bgfx.Access.Enum _access)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetBuffer(__Instance, _stage, *(global::Bgfx.Bgfx.IndexBufferHandle.__Internal*) __arg1, _access);
            }

            /// <summary>Set compute vertex buffer.</summary>
            /// <param name="_stage">Compute stage.</param>
            /// <param name="_handle">Vertex buffer handle.</param>
            /// <param name="_access">Buffer access. See `Access::Enum`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_compute_vertex_buffer`.</remarks>
            public void SetBuffer(byte _stage, global::Bgfx.Bgfx.VertexBufferHandle _handle, global::Bgfx.Bgfx.Access.Enum _access)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetBuffer_1(__Instance, _stage, *(global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) __arg1, _access);
            }

            /// <summary>Set compute dynamic index buffer.</summary>
            /// <param name="_stage">Compute stage.</param>
            /// <param name="_handle">Dynamic index buffer handle.</param>
            /// <param name="_access">Buffer access. See `Access::Enum`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_compute_dynamic_index_buffer`.</remarks>
            public void SetBuffer(byte _stage, global::Bgfx.Bgfx.DynamicIndexBufferHandle _handle, global::Bgfx.Bgfx.Access.Enum _access)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetBuffer_2(__Instance, _stage, *(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal*) __arg1, _access);
            }

            /// <summary>Set compute dynamic vertex buffer.</summary>
            /// <param name="_stage">Compute stage.</param>
            /// <param name="_handle">Dynamic vertex buffer handle.</param>
            /// <param name="_access">Buffer access. See `Access::Enum`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_compute_dynamic_vertex_buffer`.</remarks>
            public void SetBuffer(byte _stage, global::Bgfx.Bgfx.DynamicVertexBufferHandle _handle, global::Bgfx.Bgfx.Access.Enum _access)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetBuffer_3(__Instance, _stage, *(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal*) __arg1, _access);
            }

            /// <summary>Set compute indirect buffer.</summary>
            /// <param name="_stage">Compute stage.</param>
            /// <param name="_handle">Indirect buffer handle.</param>
            /// <param name="_access">Buffer access. See `Access::Enum`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_compute_indirect_buffer`.</remarks>
            public void SetBuffer(byte _stage, global::Bgfx.Bgfx.IndirectBufferHandle _handle, global::Bgfx.Bgfx.Access.Enum _access)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetBuffer_4(__Instance, _stage, *(global::Bgfx.Bgfx.IndirectBufferHandle.__Internal*) __arg1, _access);
            }

            /// <summary>Set compute image from texture.</summary>
            /// <param name="_stage">Texture unit.</param>
            /// <param name="_handle">Texture handle.</param>
            /// <param name="_mip">Mip level.</param>
            /// <param name="_access">Texture access. See `Access::Enum`.</param>
            /// <param name="_format">Texture format. See: `TextureFormat::Enum`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_set_image`.</remarks>
            public void SetImage(byte _stage, global::Bgfx.Bgfx.TextureHandle _handle, byte _mip, global::Bgfx.Bgfx.Access.Enum _access, global::Bgfx.Bgfx.TextureFormat.Enum _format)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetImage(__Instance, _stage, *(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg1, _mip, _access, _format);
            }

            /// <summary>Dispatch compute.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_handle">Compute program.</param>
            /// <param name="_numX">Number of groups X.</param>
            /// <param name="_numY">Number of groups Y.</param>
            /// <param name="_numZ">Number of groups Z.</param>
            /// <param name="_flags">Discard or preserve states. See `BGFX_DISCARD_*`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_dispatch`.</remarks>
            public void Dispatch(ushort _id, global::Bgfx.Bgfx.ProgramHandle _handle, uint _numX, uint _numY, uint _numZ, byte _flags)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.Dispatch(__Instance, _id, *(global::Bgfx.Bgfx.ProgramHandle.__Internal*) __arg1, _numX, _numY, _numZ, _flags);
            }

            /// <summary>Dispatch compute indirect.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_handle">Compute program.</param>
            /// <param name="_indirectHandle">Indirect buffer.</param>
            /// <param name="_start">First element in indirect buffer.</param>
            /// <param name="_num">Number of dispatches.</param>
            /// <param name="_flags">Discard or preserve states. See `BGFX_DISCARD_*`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_dispatch_indirect`.</remarks>
            public void Dispatch(ushort _id, global::Bgfx.Bgfx.ProgramHandle _handle, global::Bgfx.Bgfx.IndirectBufferHandle _indirectHandle, ushort _start, ushort _num, byte _flags)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                if (ReferenceEquals(_indirectHandle, null))
                    throw new global::System.ArgumentNullException("_indirectHandle", "Cannot be null because it is passed by value.");
                var __arg2 = _indirectHandle.__Instance;
                __Internal.Dispatch_1(__Instance, _id, *(global::Bgfx.Bgfx.ProgramHandle.__Internal*) __arg1, *(global::Bgfx.Bgfx.IndirectBufferHandle.__Internal*) __arg2, _start, _num, _flags);
            }

            /// <summary>Discard all previously set state for draw or compute call.</summary>
            /// <param name="_flags">Draw/compute states to discard.</param>
            /// <remarks>C99's equivalent binding is `bgfx_encoder_discard`.</remarks>
            public void Discard(byte _flags)
            {
                __Internal.Discard(__Instance, _flags);
            }

            /// <summary>Blit texture 2D region between two 2D textures.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_dst">Destination texture handle.</param>
            /// <param name="_dstX">Destination texture X position.</param>
            /// <param name="_dstY">Destination texture Y position.</param>
            /// <param name="_src">Source texture handle.</param>
            /// <param name="_srcX">Source texture X position.</param>
            /// <param name="_srcY">Source texture Y position.</param>
            /// <param name="_width">Width of region.</param>
            /// <param name="_height">Height of region.</param>
            /// <remarks>
            /// <para>Destination texture must be created with `BGFX_TEXTURE_BLIT_DST` flag.</para>
            /// <para>Availability depends on: `BGFX_CAPS_TEXTURE_BLIT`.</para>
            /// <para>C99's equivalent binding is `bgfx_encoder_blit`.</para>
            /// </remarks>
            public void Blit(ushort _id, global::Bgfx.Bgfx.TextureHandle _dst, ushort _dstX, ushort _dstY, global::Bgfx.Bgfx.TextureHandle _src, ushort _srcX, ushort _srcY, ushort _width, ushort _height)
            {
                if (ReferenceEquals(_dst, null))
                    throw new global::System.ArgumentNullException("_dst", "Cannot be null because it is passed by value.");
                var __arg1 = _dst.__Instance;
                if (ReferenceEquals(_src, null))
                    throw new global::System.ArgumentNullException("_src", "Cannot be null because it is passed by value.");
                var __arg4 = _src.__Instance;
                __Internal.Blit(__Instance, _id, *(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg1, _dstX, _dstY, *(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg4, _srcX, _srcY, _width, _height);
            }

            /// <summary>Blit texture region between two textures.</summary>
            /// <param name="_depth">
            /// <para>If texture is 3D this argument represents depth of region, otherwise it's</para>
            /// <para>unused.</para>
            /// </param>
            /// <param name="_height">Height of region.</param>
            /// <param name="_width">Width of region.</param>
            /// <param name="_srcZ">
            /// <para>If texture is 2D this argument should be 0. If source texture is cube</para>
            /// <para>this argument represents source texture cube face. For 3D texture this argument</para>
            /// <para>represents source texture Z position.</para>
            /// </param>
            /// <param name="_srcY">Source texture Y position.</param>
            /// <param name="_srcX">Source texture X position.</param>
            /// <param name="_src">Source texture handle.</param>
            /// <param name="_srcMip">Source texture mip level.</param>
            /// <param name="_dstY">Destination texture Y position.</param>
            /// <param name="_dstX">Destination texture X position.</param>
            /// <param name="_dstMip">Destination texture mip level.</param>
            /// <param name="_dst">Destination texture handle.</param>
            /// <param name="_id">View id.</param>
            /// <param name="_dstZ">
            /// <para>If texture is 2D this argument should be 0. If destination texture is cube</para>
            /// <para>this argument represents destination texture cube face. For 3D texture this argument</para>
            /// <para>represents destination texture Z position.</para>
            /// </param>
            /// <remarks>
            /// <para>Availability depends on: `BGFX_CAPS_TEXTURE_BLIT`.</para>
            /// <para>Destination texture must be created with `BGFX_TEXTURE_BLIT_DST` flag.</para>
            /// <para>C99's equivalent binding is `bgfx_encoder_blit`.</para>
            /// </remarks>
            public void Blit(ushort _id, global::Bgfx.Bgfx.TextureHandle _dst, byte _dstMip, ushort _dstX, ushort _dstY, ushort _dstZ, global::Bgfx.Bgfx.TextureHandle _src, byte _srcMip, ushort _srcX, ushort _srcY, ushort _srcZ, ushort _width, ushort _height, ushort _depth)
            {
                if (ReferenceEquals(_dst, null))
                    throw new global::System.ArgumentNullException("_dst", "Cannot be null because it is passed by value.");
                var __arg1 = _dst.__Instance;
                if (ReferenceEquals(_src, null))
                    throw new global::System.ArgumentNullException("_src", "Cannot be null because it is passed by value.");
                var __arg6 = _src.__Instance;
                __Internal.Blit(__Instance, _id, *(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg1, _dstMip, _dstX, _dstY, _dstZ, *(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg6, _srcMip, _srcX, _srcY, _srcZ, _width, _height, _depth);
            }
        }

        /// <summary>Vertex layout.</summary>
        /// <remarks>C99's equivalent binding is `bgfx_vertex_layout_t`.</remarks>
        public unsafe partial class VertexLayout : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 80)]
            public partial struct __Internal
            {
                internal uint m_hash;
                internal ushort m_stride;
                internal fixed ushort m_offset[18];
                internal fixed ushort m_attributes[18];

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12VertexLayoutC2Ev", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ctor(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx12VertexLayoutC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12VertexLayout5beginENS_12RendererType4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Begin(__IntPtr __instance, global::Bgfx.Bgfx.RendererType.Enum _renderer);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12VertexLayout3endEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void End(__IntPtr __instance);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12VertexLayout3addENS_6Attrib4EnumEhNS_10AttribType4EnumEbb", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Add(__IntPtr __instance, global::Bgfx.Bgfx.Attrib.Enum _attrib, byte _num, global::Bgfx.Bgfx.AttribType.Enum _type, bool _normalized, bool _asInt);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12VertexLayout4skipEh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Skip(__IntPtr __instance, byte _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZNK4bgfx12VertexLayout6decodeENS_6Attrib4EnumERhRNS_10AttribType4EnumERbS7_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Decode(__IntPtr __instance, global::Bgfx.Bgfx.Attrib.Enum _attrib, byte* _num, global::Bgfx.Bgfx.AttribType.Enum* _type, bool* _normalized, bool* _asInt);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZNK4bgfx12VertexLayout3hasENS_6Attrib4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool Has(__IntPtr __instance, global::Bgfx.Bgfx.Attrib.Enum _attrib);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZNK4bgfx12VertexLayout9getOffsetENS_6Attrib4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort GetOffset(__IntPtr __instance, global::Bgfx.Bgfx.Attrib.Enum _attrib);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZNK4bgfx12VertexLayout7getSizeEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetSize(__IntPtr __instance, uint _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZNK4bgfx12VertexLayout9getStrideEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort GetStride(__IntPtr __instance);
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.VertexLayout> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.VertexLayout>();

            protected bool __ownsNativeInstance;

            internal static VertexLayout __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new VertexLayout(native.ToPointer(), skipVTables);
            }

            internal static VertexLayout __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (VertexLayout)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static VertexLayout __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new VertexLayout(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private VertexLayout(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected VertexLayout(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public VertexLayout()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.VertexLayout.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                __Internal.ctor(__Instance);
            }

            public VertexLayout(global::Bgfx.Bgfx.VertexLayout _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.VertexLayout.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.VertexLayout.__Internal*) __Instance) = *((global::Bgfx.Bgfx.VertexLayout.__Internal*) _0.__Instance);
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>Start VertexLayout.</summary>
            /// <param name="_renderer">Renderer backend type. See: `bgfx::RendererType`</param>
            /// <remarks>
            /// <para>Returns itself.</para>
            /// <para>C99's equivalent binding is `bgfx_vertex_layout_begin`.</para>
            /// </remarks>
            public global::Bgfx.Bgfx.VertexLayout Begin(global::Bgfx.Bgfx.RendererType.Enum _renderer)
            {
                var __ret = __Internal.Begin(__Instance, _renderer);
                var __result0 = global::Bgfx.Bgfx.VertexLayout.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            /// <summary>End VertexLayout.</summary>
            /// <remarks>C99's equivalent binding is `bgfx_vertex_layout_end`.</remarks>
            public void End()
            {
                __Internal.End(__Instance);
            }

            /// <summary>Add attribute to VertexLayout.</summary>
            /// <param name="_attrib">Attribute semantics. See: `bgfx::Attrib`</param>
            /// <param name="_num">Number of elements 1, 2, 3 or 4.</param>
            /// <param name="_type">Element type.</param>
            /// <param name="_normalized">
            /// <para>When using fixed point AttribType (f.e. Uint8)</para>
            /// <para>value will be normalized for vertex shader usage. When normalized</para>
            /// <para>is set to true, AttribType::Uint8 value in range 0-255 will be</para>
            /// <para>in range 0.0-1.0 in vertex shader.</para>
            /// </param>
            /// <param name="_asInt">
            /// <para>Packaging rule for vertexPack, vertexUnpack, and</para>
            /// <para>vertexConvert for AttribType::Uint8 and AttribType::Int16.</para>
            /// <para>Unpacking code must be implemented inside vertex shader.</para>
            /// </param>
            /// <remarks>
            /// <para>Returns itself.</para>
            /// <para>Must be called between begin/end.</para>
            /// <para>C99's equivalent binding is `bgfx_vertex_layout_add`.</para>
            /// </remarks>
            public global::Bgfx.Bgfx.VertexLayout Add(global::Bgfx.Bgfx.Attrib.Enum _attrib, byte _num, global::Bgfx.Bgfx.AttribType.Enum _type, bool _normalized, bool _asInt)
            {
                var __ret = __Internal.Add(__Instance, _attrib, _num, _type, _normalized, _asInt);
                var __result0 = global::Bgfx.Bgfx.VertexLayout.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            /// <summary>Skip _num bytes in vertex stream.</summary>
            /// <remarks>
            /// <para>Returns itself.</para>
            /// <para>C99's equivalent binding is `bgfx_vertex_layout_skip`.</para>
            /// </remarks>
            public global::Bgfx.Bgfx.VertexLayout Skip(byte _num)
            {
                var __ret = __Internal.Skip(__Instance, _num);
                var __result0 = global::Bgfx.Bgfx.VertexLayout.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            /// <summary>Decode attribute.</summary>
            /// <remarks>C99's equivalent binding is `bgfx_vertex_layout_decode`.</remarks>
            public void Decode(global::Bgfx.Bgfx.Attrib.Enum _attrib, byte* _num, ref global::Bgfx.Bgfx.AttribType.Enum _type, ref bool _normalized, ref bool _asInt)
            {
                fixed (global::Bgfx.Bgfx.AttribType.Enum* ___type2 = &_type)
                {
                    var __arg2 = ___type2;
                    fixed (bool* ___normalized3 = &_normalized)
                    {
                        var __arg3 = ___normalized3;
                        fixed (bool* ___asInt4 = &_asInt)
                        {
                            var __arg4 = ___asInt4;
                            __Internal.Decode(__Instance, _attrib, _num, __arg2, __arg3, __arg4);
                        }
                    }
                }
            }

            /// <summary>Returns `true` if VertexLayout contains attribute.</summary>
            /// <param name="_attrib">Attribute semantics. See: `bgfx::Attrib`</param>
            /// <remarks>
            /// <para>True if VertexLayout contains attribute.</para>
            /// <para>C99's equivalent binding is `bgfx_vertex_layout_has`.</para>
            /// </remarks>
            public bool Has(global::Bgfx.Bgfx.Attrib.Enum _attrib)
            {
                var __ret = __Internal.Has(__Instance, _attrib);
                return __ret;
            }

            /// <summary>Returns relative attribute offset from the vertex.</summary>
            /// <param name="_attrib">Attribute semantics. See: `bgfx::Attrib`</param>
            /// <remarks>Relative attribute offset from the vertex.</remarks>
            public ushort GetOffset(global::Bgfx.Bgfx.Attrib.Enum _attrib)
            {
                var __ret = __Internal.GetOffset(__Instance, _attrib);
                return __ret;
            }

            /// <summary>Returns size of vertex buffer for number of vertices.</summary>
            /// <param name="_num">Number of vertices.</param>
            /// <remarks>Size of vertex buffer for number of vertices.</remarks>
            public uint GetSize(uint _num)
            {
                var __ret = __Internal.GetSize(__Instance, _num);
                return __ret;
            }

            /// <summary>Hash.</summary>
            public uint MHash
            {
                get
                {
                    return ((__Internal*)__Instance)->m_hash;
                }

                set
                {
                    ((__Internal*)__Instance)->m_hash = value;
                }
            }

            /// <summary>Stride.</summary>
            public ushort MStride
            {
                get
                {
                    return ((__Internal*)__Instance)->m_stride;
                }

                set
                {
                    ((__Internal*)__Instance)->m_stride = value;
                }
            }

            /// <summary>Attribute offsets.</summary>
            public ushort[] MOffset
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->m_offset, 18);
                }

                set
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 18; i++)
                            ((__Internal*)__Instance)->m_offset[i] = value[i];
                    }
                }
            }

            /// <summary>Used attributes.</summary>
            public ushort[] MAttributes
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->m_attributes, 18);
                }

                set
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 18; i++)
                            ((__Internal*)__Instance)->m_attributes[i] = value[i];
                    }
                }
            }

            /// <summary>Returns vertex stride.</summary>
            /// <remarks>Vertex stride.</remarks>
            public ushort Stride
            {
                get
                {
                    var __ret = __Internal.GetStride(__Instance);
                    return __ret;
                }
            }
        }

        public unsafe partial class CallbackIInternal : global::Bgfx.Bgfx.CallbackI, IDisposable
        {
            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            internal CallbackIInternal(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            internal CallbackIInternal(void* native, bool skipVTables = false)
                : base((void*) native)
            {
            }

            partial void DisposePartial(bool disposing);

            internal protected override void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            /// <summary>
            /// <para>This callback is called on unrecoverable errors.</para>
            /// <para>It's not safe to continue (Excluding _code `Fatal::DebugCheck`),</para>
            /// <para>inform the user and terminate the application.</para>
            /// </summary>
            /// <param name="_filePath">File path where fatal message was generated.</param>
            /// <param name="_line">Line where fatal message was generated.</param>
            /// <param name="_code">Fatal error code.</param>
            /// <param name="_str">More information about error.</param>
            /// <remarks>
            /// <para>Not thread safe and it can be called from any thread.</para>
            /// <para>C99's equivalent binding is `bgfx_callback_vtbl.fatal`.</para>
            /// </remarks>
            public override void Fatal(string _filePath, ushort _line, global::Bgfx.Bgfx.Fatal.Enum _code, string _str)
            {
                var ___FatalDelegate = __VTables.GetMethodDelegate<global::Bgfx.Delegates.Action___IntPtr_string8_ushort_Bgfx_bgfx_Fatal_Enum_string8>(0, 2);
                ___FatalDelegate(__Instance, _filePath, _line, _code, _str);
            }

            /// <summary>Profiler region begin.</summary>
            /// <param name="_name">Region name, contains dynamic string.</param>
            /// <param name="_abgr">Color of profiler region.</param>
            /// <param name="_filePath">File path where `profilerBegin` was called.</param>
            /// <param name="_line">Line where `profilerBegin` was called.</param>
            /// <remarks>
            /// <para>Not thread safe and it can be called from any thread.</para>
            /// <para>C99's equivalent binding is `bgfx_callback_vtbl.profiler_begin`.</para>
            /// </remarks>
            public override void ProfilerBegin(string _name, uint _abgr, string _filePath, ushort _line)
            {
                var ___ProfilerBeginDelegate = __VTables.GetMethodDelegate<global::Bgfx.Delegates.Action___IntPtr_string8_uint_string8_ushort>(0, 4);
                ___ProfilerBeginDelegate(__Instance, _name, _abgr, _filePath, _line);
            }

            /// <summary>Profiler region begin with string literal name.</summary>
            /// <param name="_name">Region name, contains string literal.</param>
            /// <param name="_abgr">Color of profiler region.</param>
            /// <param name="_filePath">File path where `profilerBeginLiteral` was called.</param>
            /// <param name="_line">Line where `profilerBeginLiteral` was called.</param>
            /// <remarks>
            /// <para>Not thread safe and it can be called from any thread.</para>
            /// <para>C99's equivalent binding is `bgfx_callback_vtbl.profiler_begin_literal`.</para>
            /// </remarks>
            public override void ProfilerBeginLiteral(string _name, uint _abgr, string _filePath, ushort _line)
            {
                var ___ProfilerBeginLiteralDelegate = __VTables.GetMethodDelegate<global::Bgfx.Delegates.Action___IntPtr_string8_uint_string8_ushort>(0, 5);
                ___ProfilerBeginLiteralDelegate(__Instance, _name, _abgr, _filePath, _line);
            }

            /// <summary>Profiler region end.</summary>
            /// <remarks>
            /// <para>Not thread safe and it can be called from any thread.</para>
            /// <para>C99's equivalent binding is `bgfx_callback_vtbl.profiler_end`.</para>
            /// </remarks>
            public override void ProfilerEnd()
            {
                var ___ProfilerEndDelegate = __VTables.GetMethodDelegate<global::Bgfx.Delegates.Action___IntPtr>(0, 6);
                ___ProfilerEndDelegate(__Instance);
            }

            /// <summary>
            /// <para>Returns the size of a cached item. Returns 0 if no cached item was</para>
            /// <para>found.</para>
            /// </summary>
            /// <param name="_id">Cache id.</param>
            /// <remarks>
            /// <para>Number of bytes to read.</para>
            /// <para>C99's equivalent binding is `bgfx_callback_vtbl.cache_read_size`.</para>
            /// </remarks>
            public override uint CacheReadSize(ulong _id)
            {
                var ___CacheReadSizeDelegate = __VTables.GetMethodDelegate<global::Bgfx.Delegates.Func_uint___IntPtr_ulong>(0, 7);
                var __ret = ___CacheReadSizeDelegate(__Instance, _id);
                return __ret;
            }

            /// <summary>Read cached item.</summary>
            /// <param name="_id">Cache id.</param>
            /// <param name="_data">Buffer where to read data.</param>
            /// <param name="_size">Size of data to read.</param>
            /// <remarks>
            /// <para>True if data is read.</para>
            /// <para>C99's equivalent binding is `bgfx_callback_vtbl.cache_read`.</para>
            /// </remarks>
            public override bool CacheRead(ulong _id, __IntPtr _data, uint _size)
            {
                var ___CacheReadDelegate = __VTables.GetMethodDelegate<global::Bgfx.Delegates.Func_bool___IntPtr_ulong___IntPtr_uint>(0, 8);
                var __ret = ___CacheReadDelegate(__Instance, _id, _data, _size);
                return __ret;
            }

            /// <summary>Write cached item.</summary>
            /// <param name="_id">Cache id.</param>
            /// <param name="_data">Data to write.</param>
            /// <param name="_size">Size of data to write.</param>
            /// <remarks>C99's equivalent binding is `bgfx_callback_vtbl.cache_write`.</remarks>
            public override void CacheWrite(ulong _id, __IntPtr _data, uint _size)
            {
                var ___CacheWriteDelegate = __VTables.GetMethodDelegate<global::Bgfx.Delegates.Action___IntPtr_ulong___IntPtr_uint>(0, 9);
                ___CacheWriteDelegate(__Instance, _id, _data, _size);
            }

            /// <summary>Screenshot captured. Screenshot format is always 4-byte BGRA.</summary>
            /// <param name="_filePath">File path.</param>
            /// <param name="_width">Image width.</param>
            /// <param name="_height">Image height.</param>
            /// <param name="_pitch">
            /// <para>Number of bytes to skip between the start of</para>
            /// <para>each horizontal line of the image.</para>
            /// </param>
            /// <param name="_data">Image data.</param>
            /// <param name="_size">Image size.</param>
            /// <param name="_yflip">If true, image origin is bottom left.</param>
            /// <remarks>C99's equivalent binding is `bgfx_callback_vtbl.screen_shot`.</remarks>
            public override void ScreenShot(string _filePath, uint _width, uint _height, uint _pitch, __IntPtr _data, uint _size, bool _yflip)
            {
                var ___ScreenShotDelegate = __VTables.GetMethodDelegate<global::Bgfx.Delegates.Action___IntPtr_string8_uint_uint_uint___IntPtr_uint_bool>(0, 10);
                ___ScreenShotDelegate(__Instance, _filePath, _width, _height, _pitch, _data, _size, _yflip);
            }

            /// <summary>Called when a video capture begins.</summary>
            /// <param name="_width">Image width.</param>
            /// <param name="_height">Image height.</param>
            /// <param name="_pitch">
            /// <para>Number of bytes to skip between the start of</para>
            /// <para>each horizontal line of the image.</para>
            /// </param>
            /// <param name="_format">Texture format. See: `TextureFormat::Enum`.</param>
            /// <param name="_yflip">If true, image origin is bottom left.</param>
            /// <remarks>C99's equivalent binding is `bgfx_callback_vtbl.capture_begin`.</remarks>
            public override void CaptureBegin(uint _width, uint _height, uint _pitch, global::Bgfx.Bgfx.TextureFormat.Enum _format, bool _yflip)
            {
                var ___CaptureBeginDelegate = __VTables.GetMethodDelegate<global::Bgfx.Delegates.Action___IntPtr_uint_uint_uint_Bgfx_bgfx_TextureFormat_Enum_bool>(0, 11);
                ___CaptureBeginDelegate(__Instance, _width, _height, _pitch, _format, _yflip);
            }

            /// <summary>Called when a video capture ends.</summary>
            /// <remarks>C99's equivalent binding is `bgfx_callback_vtbl.capture_end`.</remarks>
            public override void CaptureEnd()
            {
                var ___CaptureEndDelegate = __VTables.GetMethodDelegate<global::Bgfx.Delegates.Action___IntPtr>(0, 12);
                ___CaptureEndDelegate(__Instance);
            }

            /// <summary>Captured frame.</summary>
            /// <param name="_data">Image data.</param>
            /// <param name="_size">Image size.</param>
            /// <remarks>C99's equivalent binding is `bgfx_callback_vtbl.capture_frame`.</remarks>
            public override void CaptureFrame(__IntPtr _data, uint _size)
            {
                var ___CaptureFrameDelegate = __VTables.GetMethodDelegate<global::Bgfx.Delegates.Action___IntPtr___IntPtr_uint>(0, 13);
                ___CaptureFrameDelegate(__Instance, _data, _size);
            }
        }

        public unsafe partial class bgfx
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7isValidENS_24DynamicIndexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7isValidENS_25DynamicVertexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid_1(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7isValidENS_17FrameBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid_2(global::Bgfx.Bgfx.FrameBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7isValidENS_17IndexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid_3(global::Bgfx.Bgfx.IndexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7isValidENS_20IndirectBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid_4(global::Bgfx.Bgfx.IndirectBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7isValidENS_20OcclusionQueryHandleE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid_5(global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7isValidENS_13ProgramHandleE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid_6(global::Bgfx.Bgfx.ProgramHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7isValidENS_12ShaderHandleE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid_7(global::Bgfx.Bgfx.ShaderHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7isValidENS_13TextureHandleE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid_8(global::Bgfx.Bgfx.TextureHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7isValidENS_13UniformHandleE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid_9(global::Bgfx.Bgfx.UniformHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7isValidENS_18VertexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid_10(global::Bgfx.Bgfx.VertexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7isValidENS_18VertexLayoutHandleE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsValid_11(global::Bgfx.Bgfx.VertexLayoutHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx10vertexPackEPKfbNS_6Attrib4EnumERKNS_12VertexLayoutEPvj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void VertexPack(float[] _input, bool _inputNormalized, global::Bgfx.Bgfx.Attrib.Enum _attr, __IntPtr _layout, __IntPtr _data, uint _index);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12vertexUnpackEPfNS_6Attrib4EnumERKNS_12VertexLayoutEPKvj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void VertexUnpack(float[] _output, global::Bgfx.Bgfx.Attrib.Enum _attr, __IntPtr _layout, __IntPtr _data, uint _index);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx13vertexConvertERKNS_12VertexLayoutEPvS2_PKvj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void VertexConvert(__IntPtr _destLayout, __IntPtr _destData, __IntPtr _srcLayout, __IntPtr _srcData, uint _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12weldVerticesEPvRKNS_12VertexLayoutEPKvjbf", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint WeldVertices(__IntPtr _output, __IntPtr _layout, __IntPtr _data, uint _num, bool _index32, float _epsilon);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15topologyConvertENS_15TopologyConvert4EnumEPvjPKvjb", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint topologyConvert(global::Bgfx.Bgfx.TopologyConvert.Enum _conversion, __IntPtr _dst, uint _dstSize, __IntPtr _indices, uint _numIndices, bool _index32);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx19topologySortTriListENS_12TopologySort4EnumEPvjPKfS4_PKvjS6_jb", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void TopologySortTriList(global::Bgfx.Bgfx.TopologySort.Enum _sort, __IntPtr _dst, uint _dstSize, float[] _dir, float[] _pos, __IntPtr _vertices, uint _stride, __IntPtr _indices, uint _numIndices, bool _index32);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx21getSupportedRenderersEhPNS_12RendererType4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern byte GetSupportedRenderers(byte _max, global::Bgfx.Bgfx.RendererType.Enum* _enum);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15getRendererNameENS_12RendererType4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetRendererName(global::Bgfx.Bgfx.RendererType.Enum _type);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx4initERKNS_4InitE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool init(__IntPtr _init);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx8shutdownEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Shutdown();

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx5resetEjjjNS_13TextureFormat4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Reset(uint _width, uint _height, uint _flags, global::Bgfx.Bgfx.TextureFormat.Enum _format);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx5beginEb", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Begin(bool _forThread);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx3endEPNS_7EncoderE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void End(__IntPtr _encoder);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx5frameEb", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint Frame(bool _capture);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15getRendererTypeEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.RendererType.Enum GetRendererType();

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7getCapsEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetCaps();

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx8getStatsEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetStats();

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx5allocEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Alloc(uint _size);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx4copyEPKvj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr Copy(__IntPtr _data, uint _size);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7makeRefEPKvjPFvPvS2_ES2_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr MakeRef(__IntPtr _data, uint _size, __IntPtr _releaseFn, __IntPtr _userData);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx8setDebugEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetDebug(uint _debug);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12dbgTextClearEhb", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DbgTextClear(byte _attr, bool _small);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx13dbgTextPrintfEtthPKcz", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DbgTextPrintf(ushort _x, ushort _y, byte _attr, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _format);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12dbgTextImageEttttPKvt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void DbgTextImage(ushort _x, ushort _y, ushort _width, ushort _height, __IntPtr _data, ushort _pitch);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx17createIndexBufferEPKNS_6MemoryEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.IndexBufferHandle.__Internal CreateIndexBuffer(__IntPtr _mem, ushort _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7setNameENS_17IndexBufferHandleEPKci", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetName(global::Bgfx.Bgfx.IndexBufferHandle.__Internal _handle, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _name, int _len);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7destroyENS_17IndexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Destroy(global::Bgfx.Bgfx.IndexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx18createVertexLayoutERKNS_12VertexLayoutE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.VertexLayoutHandle.__Internal CreateVertexLayout(__IntPtr _layout);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7destroyENS_18VertexLayoutHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Destroy_1(global::Bgfx.Bgfx.VertexLayoutHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx18createVertexBufferEPKNS_6MemoryERKNS_12VertexLayoutEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.VertexBufferHandle.__Internal CreateVertexBuffer(__IntPtr _mem, __IntPtr _layout, ushort _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7setNameENS_18VertexBufferHandleEPKci", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetName_1(global::Bgfx.Bgfx.VertexBufferHandle.__Internal _handle, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _name, int _len);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7destroyENS_18VertexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Destroy_2(global::Bgfx.Bgfx.VertexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx24createDynamicIndexBufferEjt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal CreateDynamicIndexBuffer(uint _num, ushort _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx24createDynamicIndexBufferEPKNS_6MemoryEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal CreateDynamicIndexBuffer(__IntPtr _mem, ushort _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx6updateENS_24DynamicIndexBufferHandleEjPKNS_6MemoryE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Update(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal _handle, uint _startIndex, __IntPtr _mem);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7destroyENS_24DynamicIndexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Destroy_3(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx25createDynamicVertexBufferEjRKNS_12VertexLayoutEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal CreateDynamicVertexBuffer(uint _num, __IntPtr _layout, ushort _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx25createDynamicVertexBufferEPKNS_6MemoryERKNS_12VertexLayoutEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal CreateDynamicVertexBuffer(__IntPtr _mem, __IntPtr _layout, ushort _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx6updateENS_25DynamicVertexBufferHandleEjPKNS_6MemoryE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Update_1(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal _handle, uint _startVertex, __IntPtr _mem);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7destroyENS_25DynamicVertexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Destroy_4(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx28getAvailTransientIndexBufferEjb", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetAvailTransientIndexBuffer(uint _num, bool _index32);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx29getAvailTransientVertexBufferEjRKNS_12VertexLayoutE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetAvailTransientVertexBuffer(uint _num, __IntPtr _layout);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx26getAvailInstanceDataBufferEjt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint GetAvailInstanceDataBuffer(uint _num, ushort _stride);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx25allocTransientIndexBufferEPNS_20TransientIndexBufferEjb", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AllocTransientIndexBuffer(__IntPtr _tib, uint _num, bool _index32);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx26allocTransientVertexBufferEPNS_21TransientVertexBufferEjRKNS_12VertexLayoutE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AllocTransientVertexBuffer(__IntPtr _tvb, uint _num, __IntPtr _layout);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx21allocTransientBuffersEPNS_21TransientVertexBufferERKNS_12VertexLayoutEjPNS_20TransientIndexBufferEjb", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool AllocTransientBuffers(__IntPtr _tvb, __IntPtr _layout, uint _numVertices, __IntPtr _tib, uint _numIndices, bool _index32);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx23allocInstanceDataBufferEPNS_18InstanceDataBufferEjt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void AllocInstanceDataBuffer(__IntPtr _idb, uint _num, ushort _stride);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx20createIndirectBufferEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.IndirectBufferHandle.__Internal CreateIndirectBuffer(uint _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7destroyENS_20IndirectBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Destroy_5(global::Bgfx.Bgfx.IndirectBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12createShaderEPKNS_6MemoryE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.ShaderHandle.__Internal CreateShader(__IntPtr _mem);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx17getShaderUniformsENS_12ShaderHandleEPNS_13UniformHandleEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort GetShaderUniforms(global::Bgfx.Bgfx.ShaderHandle.__Internal _handle, __IntPtr _uniforms, ushort _max);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7setNameENS_12ShaderHandleEPKci", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetName_2(global::Bgfx.Bgfx.ShaderHandle.__Internal _handle, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _name, int _len);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7destroyENS_12ShaderHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Destroy_6(global::Bgfx.Bgfx.ShaderHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx13createProgramENS_12ShaderHandleES0_b", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.ProgramHandle.__Internal CreateProgram(global::Bgfx.Bgfx.ShaderHandle.__Internal _vsh, global::Bgfx.Bgfx.ShaderHandle.__Internal _fsh, bool _destroyShaders);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx13createProgramENS_12ShaderHandleEb", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.ProgramHandle.__Internal CreateProgram(global::Bgfx.Bgfx.ShaderHandle.__Internal _csh, bool _destroyShader);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7destroyENS_13ProgramHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Destroy_7(global::Bgfx.Bgfx.ProgramHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx14isTextureValidEtbtNS_13TextureFormat4EnumEm", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsTextureValid(ushort _depth, bool _cubeMap, ushort _numLayers, global::Bgfx.Bgfx.TextureFormat.Enum _format, ulong _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx18isFrameBufferValidEhPKNS_10AttachmentE", CallingConvention = __CallingConvention.Cdecl)]
                [return: MarshalAs(UnmanagedType.I1)]
                internal static extern bool IsFrameBufferValid(byte _num, __IntPtr _attachment);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15calcTextureSizeERNS_11TextureInfoEtttbbtNS_13TextureFormat4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void CalcTextureSize(__IntPtr _info, ushort _width, ushort _height, ushort _depth, bool _cubeMap, bool _hasMips, ushort _numLayers, global::Bgfx.Bgfx.TextureFormat.Enum _format);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx13createTextureEPKNS_6MemoryEmhPNS_11TextureInfoE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.TextureHandle.__Internal CreateTexture(__IntPtr _mem, ulong _flags, byte _skip, __IntPtr _info);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15createTexture2DEttbtNS_13TextureFormat4EnumEmPKNS_6MemoryE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.TextureHandle.__Internal CreateTexture2D(ushort _width, ushort _height, bool _hasMips, ushort _numLayers, global::Bgfx.Bgfx.TextureFormat.Enum _format, ulong _flags, __IntPtr _mem);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15createTexture2DENS_15BackbufferRatio4EnumEbtNS_13TextureFormat4EnumEm", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.TextureHandle.__Internal CreateTexture2D(global::Bgfx.Bgfx.BackbufferRatio.Enum _ratio, bool _hasMips, ushort _numLayers, global::Bgfx.Bgfx.TextureFormat.Enum _format, ulong _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15createTexture3DEtttbNS_13TextureFormat4EnumEmPKNS_6MemoryE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.TextureHandle.__Internal CreateTexture3D(ushort _width, ushort _height, ushort _depth, bool _hasMips, global::Bgfx.Bgfx.TextureFormat.Enum _format, ulong _flags, __IntPtr _mem);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx17createTextureCubeEtbtNS_13TextureFormat4EnumEmPKNS_6MemoryE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.TextureHandle.__Internal CreateTextureCube(ushort _size, bool _hasMips, ushort _numLayers, global::Bgfx.Bgfx.TextureFormat.Enum _format, ulong _flags, __IntPtr _mem);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15updateTexture2DENS_13TextureHandleEthttttPKNS_6MemoryEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateTexture2D(global::Bgfx.Bgfx.TextureHandle.__Internal _handle, ushort _layer, byte _mip, ushort _x, ushort _y, ushort _width, ushort _height, __IntPtr _mem, ushort _pitch);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15updateTexture3DENS_13TextureHandleEhttttttPKNS_6MemoryE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateTexture3D(global::Bgfx.Bgfx.TextureHandle.__Internal _handle, byte _mip, ushort _x, ushort _y, ushort _z, ushort _width, ushort _height, ushort _depth, __IntPtr _mem);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx17updateTextureCubeENS_13TextureHandleEthhttttPKNS_6MemoryEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void UpdateTextureCube(global::Bgfx.Bgfx.TextureHandle.__Internal _handle, ushort _layer, byte _side, byte _mip, ushort _x, ushort _y, ushort _width, ushort _height, __IntPtr _mem, ushort _pitch);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx11readTextureENS_13TextureHandleEPvh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint ReadTexture(global::Bgfx.Bgfx.TextureHandle.__Internal _handle, __IntPtr _data, byte _mip);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7setNameENS_13TextureHandleEPKci", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetName_3(global::Bgfx.Bgfx.TextureHandle.__Internal _handle, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _name, int _len);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx18getDirectAccessPtrENS_13TextureHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern __IntPtr GetDirectAccessPtr(global::Bgfx.Bgfx.TextureHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7destroyENS_13TextureHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Destroy_8(global::Bgfx.Bgfx.TextureHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx17createFrameBufferEttNS_13TextureFormat4EnumEm", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.FrameBufferHandle.__Internal CreateFrameBuffer(ushort _width, ushort _height, global::Bgfx.Bgfx.TextureFormat.Enum _format, ulong _textureFlags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx17createFrameBufferENS_15BackbufferRatio4EnumENS_13TextureFormat4EnumEm", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.FrameBufferHandle.__Internal CreateFrameBuffer(global::Bgfx.Bgfx.BackbufferRatio.Enum _ratio, global::Bgfx.Bgfx.TextureFormat.Enum _format, ulong _textureFlags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx17createFrameBufferEhPKNS_13TextureHandleEb", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.FrameBufferHandle.__Internal CreateFrameBuffer(byte _num, __IntPtr _handles, bool _destroyTextures);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx17createFrameBufferEhPKNS_10AttachmentEb", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.FrameBufferHandle.__Internal CreateFrameBuffer_1(byte _num, __IntPtr _attachment, bool _destroyTextures);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx17createFrameBufferEPvttNS_13TextureFormat4EnumES2_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.FrameBufferHandle.__Internal CreateFrameBuffer(__IntPtr _nwh, ushort _width, ushort _height, global::Bgfx.Bgfx.TextureFormat.Enum _format, global::Bgfx.Bgfx.TextureFormat.Enum _depthFormat);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7setNameENS_17FrameBufferHandleEPKci", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetName_4(global::Bgfx.Bgfx.FrameBufferHandle.__Internal _handle, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _name, int _len);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx10getTextureENS_17FrameBufferHandleEh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.TextureHandle.__Internal GetTexture(global::Bgfx.Bgfx.FrameBufferHandle.__Internal _handle, byte _attachment);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7destroyENS_17FrameBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Destroy_9(global::Bgfx.Bgfx.FrameBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx13createUniformEPKcNS_11UniformType4EnumEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.UniformHandle.__Internal CreateUniform([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _name, global::Bgfx.Bgfx.UniformType.Enum _type, ushort _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx14getUniformInfoENS_13UniformHandleERNS_11UniformInfoE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void GetUniformInfo(global::Bgfx.Bgfx.UniformHandle.__Internal _handle, __IntPtr _info);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7destroyENS_13UniformHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Destroy_10(global::Bgfx.Bgfx.UniformHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx20createOcclusionQueryEv", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal CreateOcclusionQuery();

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx9getResultENS_20OcclusionQueryHandleEPi", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.OcclusionQueryResult.Enum GetResult(global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal _handle, int* _result);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7destroyENS_20OcclusionQueryHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Destroy_11(global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15setPaletteColorEhj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPaletteColor(byte _index, uint _rgba);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15setPaletteColorEhffff", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPaletteColor(byte _index, float _r, float _g, float _b, float _a);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15setPaletteColorEhPKf", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetPaletteColor_1(byte _index, float[] _rgba);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx11setViewNameEtPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetViewName(ushort _id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _name);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx11setViewRectEttttt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetViewRect(ushort _id, ushort _x, ushort _y, ushort _width, ushort _height);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx11setViewRectEtttNS_15BackbufferRatio4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetViewRect(ushort _id, ushort _x, ushort _y, global::Bgfx.Bgfx.BackbufferRatio.Enum _ratio);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx14setViewScissorEttttt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetViewScissor(ushort _id, ushort _x, ushort _y, ushort _width, ushort _height);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12setViewClearEttjfh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetViewClear(ushort _id, ushort _flags, uint _rgba, float _depth, byte _stencil);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12setViewClearEttfhhhhhhhhh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetViewClear(ushort _id, ushort _flags, float _depth, byte _stencil, byte _0, byte _1, byte _2, byte _3, byte _4, byte _5, byte _6, byte _7);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx11setViewModeEtNS_8ViewMode4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetViewMode(ushort _id, global::Bgfx.Bgfx.ViewMode.Enum _mode);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx18setViewFrameBufferEtNS_17FrameBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetViewFrameBuffer(ushort _id, global::Bgfx.Bgfx.FrameBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx16setViewTransformEtPKvS1_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetViewTransform(ushort _id, __IntPtr _view, __IntPtr _proj);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12setViewOrderEttPKt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetViewOrder(ushort _id, ushort _num, ushort* _remap);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx9resetViewEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void ResetView(ushort _id);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx9setMarkerEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetMarker([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _marker);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx8setStateEmj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetState(ulong _state, uint _rgba);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12setConditionENS_20OcclusionQueryHandleEb", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetCondition(global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal _handle, bool _visible);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx10setStencilEjj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetStencil(uint _fstencil, uint _bstencil);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx10setScissorEtttt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern ushort SetScissor(ushort _x, ushort _y, ushort _width, ushort _height);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx10setScissorEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetScissor(ushort _cache);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12setTransformEPKvt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint SetTransform(__IntPtr _mtx, ushort _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx14allocTransformEPNS_9TransformEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern uint AllocTransform(__IntPtr _transform, ushort _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx12setTransformEjt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTransform(uint _cache, ushort _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx10setUniformENS_13UniformHandleEPKvt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetUniform(global::Bgfx.Bgfx.UniformHandle.__Internal _handle, __IntPtr _value, ushort _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx14setIndexBufferENS_17IndexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndexBuffer(global::Bgfx.Bgfx.IndexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx14setIndexBufferENS_17IndexBufferHandleEjj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndexBuffer(global::Bgfx.Bgfx.IndexBufferHandle.__Internal _handle, uint _firstIndex, uint _numIndices);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx14setIndexBufferENS_24DynamicIndexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndexBuffer_1(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx14setIndexBufferENS_24DynamicIndexBufferHandleEjj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndexBuffer_1(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal _handle, uint _firstIndex, uint _numIndices);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx14setIndexBufferEPKNS_20TransientIndexBufferE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndexBuffer(__IntPtr _tib);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx14setIndexBufferEPKNS_20TransientIndexBufferEjj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetIndexBuffer(__IntPtr _tib, uint _firstIndex, uint _numIndices);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15setVertexBufferEhNS_18VertexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVertexBuffer(byte _stream, global::Bgfx.Bgfx.VertexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15setVertexBufferEhNS_18VertexBufferHandleEjjNS_18VertexLayoutHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVertexBuffer(byte _stream, global::Bgfx.Bgfx.VertexBufferHandle.__Internal _handle, uint _startVertex, uint _numVertices, global::Bgfx.Bgfx.VertexLayoutHandle.__Internal _layoutHandle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15setVertexBufferEhNS_25DynamicVertexBufferHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVertexBuffer_1(byte _stream, global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal _handle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15setVertexBufferEhNS_25DynamicVertexBufferHandleEjjNS_18VertexLayoutHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVertexBuffer_1(byte _stream, global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal _handle, uint _startVertex, uint _numVertices, global::Bgfx.Bgfx.VertexLayoutHandle.__Internal _layoutHandle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15setVertexBufferEhPKNS_21TransientVertexBufferE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVertexBuffer(byte _stream, __IntPtr _tvb);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx15setVertexBufferEhPKNS_21TransientVertexBufferEjjNS_18VertexLayoutHandleE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVertexBuffer(byte _stream, __IntPtr _tvb, uint _startVertex, uint _numVertices, global::Bgfx.Bgfx.VertexLayoutHandle.__Internal _layoutHandle);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx14setVertexCountEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetVertexCount(uint _numVertices);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx21setInstanceDataBufferEPKNS_18InstanceDataBufferE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInstanceDataBuffer(__IntPtr _idb);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx21setInstanceDataBufferEPKNS_18InstanceDataBufferEjj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInstanceDataBuffer(__IntPtr _idb, uint _start, uint _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx21setInstanceDataBufferENS_18VertexBufferHandleEjj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInstanceDataBuffer(global::Bgfx.Bgfx.VertexBufferHandle.__Internal _handle, uint _start, uint _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx21setInstanceDataBufferENS_25DynamicVertexBufferHandleEjj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInstanceDataBuffer_1(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal _handle, uint _start, uint _num);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx16setInstanceCountEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetInstanceCount(uint _numInstances);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx10setTextureEhNS_13UniformHandleENS_13TextureHandleEj", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetTexture(byte _stage, global::Bgfx.Bgfx.UniformHandle.__Internal _sampler, global::Bgfx.Bgfx.TextureHandle.__Internal _handle, uint _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx5touchEt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Touch(ushort _id);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx6submitEtNS_13ProgramHandleEjh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Submit(ushort _id, global::Bgfx.Bgfx.ProgramHandle.__Internal _program, uint _depth, byte _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx6submitEtNS_13ProgramHandleENS_20OcclusionQueryHandleEjh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Submit(ushort _id, global::Bgfx.Bgfx.ProgramHandle.__Internal _program, global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal _occlusionQuery, uint _depth, byte _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx6submitEtNS_13ProgramHandleENS_20IndirectBufferHandleEttjh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Submit(ushort _id, global::Bgfx.Bgfx.ProgramHandle.__Internal _program, global::Bgfx.Bgfx.IndirectBufferHandle.__Internal _indirectHandle, ushort _start, ushort _num, uint _depth, byte _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx9setBufferEhNS_17IndexBufferHandleENS_6Access4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBuffer(byte _stage, global::Bgfx.Bgfx.IndexBufferHandle.__Internal _handle, global::Bgfx.Bgfx.Access.Enum _access);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx9setBufferEhNS_18VertexBufferHandleENS_6Access4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBuffer_1(byte _stage, global::Bgfx.Bgfx.VertexBufferHandle.__Internal _handle, global::Bgfx.Bgfx.Access.Enum _access);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx9setBufferEhNS_24DynamicIndexBufferHandleENS_6Access4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBuffer_2(byte _stage, global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal _handle, global::Bgfx.Bgfx.Access.Enum _access);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx9setBufferEhNS_25DynamicVertexBufferHandleENS_6Access4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBuffer_3(byte _stage, global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal _handle, global::Bgfx.Bgfx.Access.Enum _access);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx9setBufferEhNS_20IndirectBufferHandleENS_6Access4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetBuffer_4(byte _stage, global::Bgfx.Bgfx.IndirectBufferHandle.__Internal _handle, global::Bgfx.Bgfx.Access.Enum _access);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx8setImageEhNS_13TextureHandleEhNS_6Access4EnumENS_13TextureFormat4EnumE", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void SetImage(byte _stage, global::Bgfx.Bgfx.TextureHandle.__Internal _handle, byte _mip, global::Bgfx.Bgfx.Access.Enum _access, global::Bgfx.Bgfx.TextureFormat.Enum _format);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx8dispatchEtNS_13ProgramHandleEjjjh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Dispatch(ushort _id, global::Bgfx.Bgfx.ProgramHandle.__Internal _handle, uint _numX, uint _numY, uint _numZ, byte _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx8dispatchEtNS_13ProgramHandleENS_20IndirectBufferHandleEtth", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Dispatch_1(ushort _id, global::Bgfx.Bgfx.ProgramHandle.__Internal _handle, global::Bgfx.Bgfx.IndirectBufferHandle.__Internal _indirectHandle, ushort _start, ushort _num, byte _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx7discardEh", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Discard(byte _flags);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx4blitEtNS_13TextureHandleEttS0_tttt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Blit(ushort _id, global::Bgfx.Bgfx.TextureHandle.__Internal _dst, ushort _dstX, ushort _dstY, global::Bgfx.Bgfx.TextureHandle.__Internal _src, ushort _srcX, ushort _srcY, ushort _width, ushort _height);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx4blitEtNS_13TextureHandleEhtttS0_htttttt", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void Blit(ushort _id, global::Bgfx.Bgfx.TextureHandle.__Internal _dst, byte _dstMip, ushort _dstX, ushort _dstY, ushort _dstZ, global::Bgfx.Bgfx.TextureHandle.__Internal _src, byte _srcMip, ushort _srcX, ushort _srcY, ushort _srcZ, ushort _width, ushort _height, ushort _depth);

                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx17requestScreenShotENS_17FrameBufferHandleEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void RequestScreenShot(global::Bgfx.Bgfx.FrameBufferHandle.__Internal _handle, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _filePath);
            }

            public static bool IsValid(global::Bgfx.Bgfx.DynamicIndexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.IsValid(*(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal*) __arg0);
                return __ret;
            }

            public static bool IsValid(global::Bgfx.Bgfx.DynamicVertexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.IsValid_1(*(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal*) __arg0);
                return __ret;
            }

            public static bool IsValid(global::Bgfx.Bgfx.FrameBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.IsValid_2(*(global::Bgfx.Bgfx.FrameBufferHandle.__Internal*) __arg0);
                return __ret;
            }

            public static bool IsValid(global::Bgfx.Bgfx.IndexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.IsValid_3(*(global::Bgfx.Bgfx.IndexBufferHandle.__Internal*) __arg0);
                return __ret;
            }

            public static bool IsValid(global::Bgfx.Bgfx.IndirectBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.IsValid_4(*(global::Bgfx.Bgfx.IndirectBufferHandle.__Internal*) __arg0);
                return __ret;
            }

            public static bool IsValid(global::Bgfx.Bgfx.OcclusionQueryHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.IsValid_5(*(global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal*) __arg0);
                return __ret;
            }

            public static bool IsValid(global::Bgfx.Bgfx.ProgramHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.IsValid_6(*(global::Bgfx.Bgfx.ProgramHandle.__Internal*) __arg0);
                return __ret;
            }

            public static bool IsValid(global::Bgfx.Bgfx.ShaderHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.IsValid_7(*(global::Bgfx.Bgfx.ShaderHandle.__Internal*) __arg0);
                return __ret;
            }

            public static bool IsValid(global::Bgfx.Bgfx.TextureHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.IsValid_8(*(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg0);
                return __ret;
            }

            public static bool IsValid(global::Bgfx.Bgfx.UniformHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.IsValid_9(*(global::Bgfx.Bgfx.UniformHandle.__Internal*) __arg0);
                return __ret;
            }

            public static bool IsValid(global::Bgfx.Bgfx.VertexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.IsValid_10(*(global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) __arg0);
                return __ret;
            }

            public static bool IsValid(global::Bgfx.Bgfx.VertexLayoutHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.IsValid_11(*(global::Bgfx.Bgfx.VertexLayoutHandle.__Internal*) __arg0);
                return __ret;
            }

            /// <summary>Pack vertex attribute into vertex stream format.</summary>
            /// <param name="_input">Value to be packed into vertex stream.</param>
            /// <param name="_inputNormalized">True if input value is already normalized.</param>
            /// <param name="_attr">Attribute to pack.</param>
            /// <param name="_layout">Vertex stream layout.</param>
            /// <param name="_data">Destination vertex stream where data will be packed.</param>
            /// <param name="_index">Vertex index that will be modified.</param>
            /// <remarks>C99's equivalent binding is `bgfx_vertex_pack`.</remarks>
            public static void VertexPack(float[] _input, bool _inputNormalized, global::Bgfx.Bgfx.Attrib.Enum _attr, global::Bgfx.Bgfx.VertexLayout _layout, __IntPtr _data, uint _index)
            {
                if (_input == null || _input.Length != 4)
                    throw new ArgumentOutOfRangeException("_input", "The dimensions of the provided array don't match the required size.");
                if (ReferenceEquals(_layout, null))
                    throw new global::System.ArgumentNullException("_layout", "Cannot be null because it is a C++ reference (&).");
                var __arg3 = _layout.__Instance;
                __Internal.VertexPack(_input, _inputNormalized, _attr, __arg3, _data, _index);
            }

            /// <summary>Unpack vertex attribute from vertex stream format.</summary>
            /// <param name="_output">Result of unpacking.</param>
            /// <param name="_attr">Attribute to unpack.</param>
            /// <param name="_layout">Vertex stream layout.</param>
            /// <param name="_data">Source vertex stream from where data will be unpacked.</param>
            /// <param name="_index">Vertex index that will be unpacked.</param>
            /// <remarks>C99's equivalent binding is `bgfx_vertex_unpack`.</remarks>
            public static void VertexUnpack(float[] _output, global::Bgfx.Bgfx.Attrib.Enum _attr, global::Bgfx.Bgfx.VertexLayout _layout, __IntPtr _data, uint _index)
            {
                if (_output == null || _output.Length != 4)
                    throw new ArgumentOutOfRangeException("_output", "The dimensions of the provided array don't match the required size.");
                if (ReferenceEquals(_layout, null))
                    throw new global::System.ArgumentNullException("_layout", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = _layout.__Instance;
                __Internal.VertexUnpack(_output, _attr, __arg2, _data, _index);
            }

            /// <summary>Converts vertex stream data from one vertex stream format to another.</summary>
            /// <param name="_destLayout">Destination vertex stream layout.</param>
            /// <param name="_destData">Destination vertex stream.</param>
            /// <param name="_srcLayout">Source vertex stream layout.</param>
            /// <param name="_srcData">Source vertex stream data.</param>
            /// <param name="_num">Number of vertices to convert from source to destination.</param>
            /// <remarks>C99's equivalent binding is `bgfx_vertex_convert`.</remarks>
            public static void VertexConvert(global::Bgfx.Bgfx.VertexLayout _destLayout, __IntPtr _destData, global::Bgfx.Bgfx.VertexLayout _srcLayout, __IntPtr _srcData, uint _num)
            {
                if (ReferenceEquals(_destLayout, null))
                    throw new global::System.ArgumentNullException("_destLayout", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _destLayout.__Instance;
                if (ReferenceEquals(_srcLayout, null))
                    throw new global::System.ArgumentNullException("_srcLayout", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = _srcLayout.__Instance;
                __Internal.VertexConvert(__arg0, _destData, __arg2, _srcData, _num);
            }

            /// <summary>Weld vertices.</summary>
            /// <param name="_output">
            /// <para>Welded vertices remapping table. The size of buffer</para>
            /// <para>must be the same as number of vertices.</para>
            /// </param>
            /// <param name="_layout">Vertex stream layout.</param>
            /// <param name="_data">Vertex stream.</param>
            /// <param name="_num">Number of vertices in vertex stream.</param>
            /// <param name="_index32">Set to `true` if input indices are 32-bit.</param>
            /// <param name="_epsilon">Error tolerance for vertex position comparison.</param>
            /// <remarks>
            /// <para>Number of unique vertices after vertex welding.</para>
            /// <para>C99's equivalent binding is `bgfx_weld_vertices`.</para>
            /// </remarks>
            public static uint WeldVertices(__IntPtr _output, global::Bgfx.Bgfx.VertexLayout _layout, __IntPtr _data, uint _num, bool _index32, float _epsilon)
            {
                if (ReferenceEquals(_layout, null))
                    throw new global::System.ArgumentNullException("_layout", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _layout.__Instance;
                var __ret = __Internal.WeldVertices(_output, __arg1, _data, _num, _index32, _epsilon);
                return __ret;
            }

            /// <summary>Convert index buffer for use with different primitive topologies.</summary>
            /// <param name="_conversion">Conversion type, see `TopologyConvert::Enum`.</param>
            /// <param name="_dst">
            /// <para>Destination index buffer. If this argument is NULL</para>
            /// <para>function will return number of indices after conversion.</para>
            /// </param>
            /// <param name="_dstSize">
            /// <para>Destination index buffer in bytes. It must be</para>
            /// <para>large enough to contain output indices. If destination size is</para>
            /// <para>insufficient index buffer will be truncated.</para>
            /// </param>
            /// <param name="_indices">Source indices.</param>
            /// <param name="_numIndices">Number of input indices.</param>
            /// <param name="_index32">Set to `true` if input indices are 32-bit.</param>
            /// <remarks>
            /// <para>Number of output indices after conversion.</para>
            /// <para>C99's equivalent binding is `bgfx_topology_convert`.</para>
            /// </remarks>
            public static uint topologyConvert(global::Bgfx.Bgfx.TopologyConvert.Enum _conversion, __IntPtr _dst, uint _dstSize, __IntPtr _indices, uint _numIndices, bool _index32)
            {
                var __ret = __Internal.topologyConvert(_conversion, _dst, _dstSize, _indices, _numIndices, _index32);
                return __ret;
            }

            /// <summary>Sort indices.</summary>
            /// <param name="_sort">Sort order, see `TopologySort::Enum`.</param>
            /// <param name="_dst">Destination index buffer.</param>
            /// <param name="_dstSize">
            /// <para>Destination index buffer in bytes. It must be</para>
            /// <para>large enough to contain output indices. If destination size is</para>
            /// <para>insufficient index buffer will be truncated.</para>
            /// </param>
            /// <param name="_dir">Direction (vector must be normalized).</param>
            /// <param name="_pos">Position.</param>
            /// <param name="_vertices">
            /// <para>Pointer to first vertex represented as</para>
            /// <para>float x, y, z. Must contain at least number of vertices</para>
            /// <para>referencende by index buffer.</para>
            /// </param>
            /// <param name="_stride">Vertex stride.</param>
            /// <param name="_indices">Source indices.</param>
            /// <param name="_numIndices">Number of input indices.</param>
            /// <param name="_index32">Set to `true` if input indices are 32-bit.</param>
            /// <remarks>C99's equivalent binding is `bgfx_topology_sort_tri_list`.</remarks>
            public static void TopologySortTriList(global::Bgfx.Bgfx.TopologySort.Enum _sort, __IntPtr _dst, uint _dstSize, float[] _dir, float[] _pos, __IntPtr _vertices, uint _stride, __IntPtr _indices, uint _numIndices, bool _index32)
            {
                if (_dir == null || _dir.Length != 3)
                    throw new ArgumentOutOfRangeException("_dir", "The dimensions of the provided array don't match the required size.");
                if (_pos == null || _pos.Length != 3)
                    throw new ArgumentOutOfRangeException("_pos", "The dimensions of the provided array don't match the required size.");
                __Internal.TopologySortTriList(_sort, _dst, _dstSize, _dir, _pos, _vertices, _stride, _indices, _numIndices, _index32);
            }

            /// <summary>Returns supported backend API renderers.</summary>
            /// <param name="_max">Maximum number of elements in _enum array.</param>
            /// <param name="_enum">Array where supported renderers will be written.</param>
            /// <remarks>
            /// <para>Number of supported renderers.</para>
            /// <para>C99's equivalent binding is `bgfx_get_supported_renderers`.</para>
            /// </remarks>
            public static byte GetSupportedRenderers(byte _max, ref global::Bgfx.Bgfx.RendererType.Enum _enum)
            {
                fixed (global::Bgfx.Bgfx.RendererType.Enum* ___enum1 = &_enum)
                {
                    var __arg1 = ___enum1;
                    var __ret = __Internal.GetSupportedRenderers(_max, __arg1);
                    return __ret;
                }
            }

            /// <summary>Returns name of renderer.</summary>
            /// <remarks>C99's equivalent binding is `bgfx_get_renderer_name`.</remarks>
            public static string GetRendererName(global::Bgfx.Bgfx.RendererType.Enum _type)
            {
                var __ret = __Internal.GetRendererName(_type);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
            }

            /// <summary>Initialize the bgfx library.</summary>
            /// <param name="_init">Initialization parameters. See: `bgfx::Init` for more info.</param>
            /// <remarks>
            /// <para>`true` if initialization was successful.</para>
            /// <para>C99's equivalent binding is `bgfx_init`.</para>
            /// </remarks>
            public static bool init(global::Bgfx.Bgfx.Init _init)
            {
                if (ReferenceEquals(_init, null))
                    throw new global::System.ArgumentNullException("_init", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _init.__Instance;
                var __ret = __Internal.init(__arg0);
                return __ret;
            }

            /// <summary>Shutdown bgfx library.</summary>
            /// <remarks>C99's equivalent binding is `bgfx_shutdown`.</remarks>
            public static void Shutdown()
            {
                __Internal.Shutdown();
            }

            /// <summary>Reset graphic settings and back-buffer size.</summary>
            /// <param name="_width">Back-buffer width.</param>
            /// <param name="_height">Back-buffer height.</param>
            /// <param name="_flags">
            /// <para>See: `BGFX_RESET_*` for more info.</para>
            /// <para>- `BGFX_RESET_NONE` - No reset flags.</para>
            /// <para>- `BGFX_RESET_FULLSCREEN` - Not supported yet.</para>
            /// <para>- `BGFX_RESET_MSAA_X[2/4/8/16]` - Enable 2, 4, 8 or 16 x MSAA.</para>
            /// <para>- `BGFX_RESET_VSYNC` - Enable V-Sync.</para>
            /// <para>- `BGFX_RESET_MAXANISOTROPY` - Turn on/off max anisotropy.</para>
            /// <para>- `BGFX_RESET_CAPTURE` - Begin screen capture.</para>
            /// <para>- `BGFX_RESET_FLUSH_AFTER_RENDER` - Flush rendering after submitting to GPU.</para>
            /// <para>- `BGFX_RESET_FLIP_AFTER_RENDER` - This flag  specifies where flip</para>
            /// <para>occurs. Default behavior is that flip occurs before rendering new</para>
            /// <para>frame. This flag only has effect when `BGFX_CONFIG_MULTITHREADED=0`.</para>
            /// <para>- `BGFX_RESET_SRGB_BACKBUFFER` - Enable sRGB back-buffer.</para>
            /// </param>
            /// <param name="_format">Texture format. See: `TextureFormat::Enum`.</param>
            /// <remarks>
            /// <para>This call doesnt change the window size, it just resizes</para>
            /// <para>the back-buffer. Your windowing code controls the window size.</para>
            /// <para>C99's equivalent binding is `bgfx_reset`.</para>
            /// </remarks>
            public static void Reset(uint _width, uint _height, uint _flags, global::Bgfx.Bgfx.TextureFormat.Enum _format)
            {
                __Internal.Reset(_width, _height, _flags, _format);
            }

            /// <summary>Begin submitting draw calls from thread.</summary>
            /// <param name="_forThread">Explicitly request an encoder for a worker thread.</param>
            public static global::Bgfx.Bgfx.Encoder Begin(bool _forThread)
            {
                var __ret = __Internal.Begin(_forThread);
                var __result0 = global::Bgfx.Bgfx.Encoder.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            /// <summary>End submitting draw calls from thread.</summary>
            public static void End(global::Bgfx.Bgfx.Encoder _encoder)
            {
                var __arg0 = _encoder is null ? __IntPtr.Zero : _encoder.__Instance;
                __Internal.End(__arg0);
            }

            /// <summary>
            /// <para>Advance to next frame. When using multithreaded renderer, this call</para>
            /// <para>just swaps internal buffers, kicks render thread, and returns. In</para>
            /// <para>singlethreaded renderer this call does frame rendering.</para>
            /// </summary>
            /// <param name="_capture">Capture frame with graphics debugger.</param>
            /// <remarks>
            /// <para>Current frame number. This might be used in conjunction with</para>
            /// <para>double/multi buffering data outside the library and passing it to</para>
            /// <para>library via `bgfx::makeRef` calls.</para>
            /// <para>C99's equivalent binding is `bgfx_frame`.</para>
            /// </remarks>
            public static uint Frame(bool _capture)
            {
                var __ret = __Internal.Frame(_capture);
                return __ret;
            }

            /// <summary>Returns current renderer backend API type.</summary>
            /// <remarks>
            /// <para>Library must be initialized.</para>
            /// <para>C99's equivalent binding is `bgfx_get_renderer_type`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.RendererType.Enum GetRendererType()
            {
                var __ret = __Internal.GetRendererType();
                return __ret;
            }

            /// <summary>Returns renderer capabilities.</summary>
            /// <remarks>
            /// <para>Pointer to static `bgfx::Caps` structure.</para>
            /// <para>Library must be initialized.</para>
            /// <para>C99's equivalent binding is `bgfx_get_caps`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.Caps GetCaps()
            {
                var __ret = __Internal.GetCaps();
                var __result0 = global::Bgfx.Bgfx.Caps.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            /// <summary>Returns performance counters.</summary>
            /// <remarks>
            /// <para>Pointer returned is valid until `bgfx::frame` is called.</para>
            /// <para>C99's equivalent binding is `bgfx_get_stats`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.Stats GetStats()
            {
                var __ret = __Internal.GetStats();
                var __result0 = global::Bgfx.Bgfx.Stats.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            /// <summary>Allocate buffer to pass to bgfx calls. Data will be freed inside bgfx.</summary>
            /// <param name="_size">Size to allocate.</param>
            /// <remarks>C99's equivalent binding is `bgfx_alloc`.</remarks>
            public static global::Bgfx.Bgfx.Memory Alloc(uint _size)
            {
                var __ret = __Internal.Alloc(_size);
                var __result0 = global::Bgfx.Bgfx.Memory.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            /// <summary>Allocate buffer and copy data into it. Data will be freed inside bgfx.</summary>
            /// <param name="_data">Pointer to data to be copied.</param>
            /// <param name="_size">Size of data to be copied.</param>
            /// <remarks>C99's equivalent binding is `bgfx_copy`.</remarks>
            public static global::Bgfx.Bgfx.Memory Copy(__IntPtr _data, uint _size)
            {
                var __ret = __Internal.Copy(_data, _size);
                var __result0 = global::Bgfx.Bgfx.Memory.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            /// <summary>
            /// <para>Make reference to data to pass to bgfx. Unlike `bgfx::alloc`, this call</para>
            /// <para>doesn't allocate memory for data. It just copies the _data pointer. You</para>
            /// <para>can pass `ReleaseFn` function pointer to release this memory after it's</para>
            /// <para>consumed, otherwise you must make sure _data is available for at least 2</para>
            /// <para>`bgfx::frame` calls. `ReleaseFn` function must be able to be called</para>
            /// <para>from any thread.</para>
            /// </summary>
            /// <param name="_data">Pointer to data.</param>
            /// <param name="_size">Size of data.</param>
            /// <param name="_releaseFn">Callback function to release memory after use.</param>
            /// <param name="_userData">User data to be passed to callback function.</param>
            /// <remarks>
            /// <para>Data passed must be available for at least 2 `bgfx::frame` calls.</para>
            /// <para>C99's equivalent bindings are `bgfx_make_ref`, `bgfx_make_ref_release`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.Memory MakeRef(__IntPtr _data, uint _size, global::Bgfx.Bgfx.ReleaseFn _releaseFn, __IntPtr _userData)
            {
                var __arg2 = _releaseFn == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(_releaseFn);
                var __ret = __Internal.MakeRef(_data, _size, __arg2, _userData);
                var __result0 = global::Bgfx.Bgfx.Memory.__GetOrCreateInstance(__ret, false);
                return __result0;
            }

            /// <summary>Set debug flags.</summary>
            /// <param name="_debug">
            /// <para>Available flags:</para>
            /// <para>- `BGFX_DEBUG_IFH` - Infinitely fast hardware. When this flag is set</para>
            /// <para>all rendering calls will be skipped. This is useful when profiling</para>
            /// <para>to quickly assess potential bottlenecks between CPU and GPU.</para>
            /// <para>- `BGFX_DEBUG_PROFILER` - Enable profiler.</para>
            /// <para>- `BGFX_DEBUG_STATS` - Display internal statistics.</para>
            /// <para>- `BGFX_DEBUG_TEXT` - Display debug text.</para>
            /// <para>- `BGFX_DEBUG_WIREFRAME` - Wireframe rendering. All rendering</para>
            /// <para>primitives will be rendered as lines.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_debug`.</remarks>
            public static void SetDebug(uint _debug)
            {
                __Internal.SetDebug(_debug);
            }

            /// <summary>Clear internal debug text buffer.</summary>
            /// <param name="_attr">Background color.</param>
            /// <param name="_small">Default 8x16 or 8x8 font.</param>
            /// <remarks>C99's equivalent binding is `bgfx_dbg_text_clear`.</remarks>
            public static void DbgTextClear(byte _attr, bool _small)
            {
                __Internal.DbgTextClear(_attr, _small);
            }

            /// <summary>Print into internal debug text character-buffer (VGA-compatible text mode).</summary>
            /// <param name="_x,">_y 2D position from top-left.</param>
            /// <param name="_attr">
            /// <para>Color palette. Where top 4-bits represent index of background, and bottom</para>
            /// <para>4-bits represent foreground color from standard VGA text palette (ANSI escape codes).</para>
            /// </param>
            /// <param name="_format">`printf` style format.</param>
            /// <remarks>C99's equivalent binding is `bgfx_dbg_text_printf`.</remarks>
            public static void DbgTextPrintf(ushort _x, ushort _y, byte _attr, string _format)
            {
                __Internal.DbgTextPrintf(_x, _y, _attr, _format);
            }

            /// <summary>Draw image into internal debug text buffer.</summary>
            /// <param name="_x,">_y 2D position from top-left.</param>
            /// <param name="_width,">_height  Image width and height.</param>
            /// <param name="_data">Raw image data (character/attribute raw encoding).</param>
            /// <param name="_pitch">Image pitch in bytes.</param>
            /// <remarks>C99's equivalent binding is `bgfx_dbg_text_image`.</remarks>
            public static void DbgTextImage(ushort _x, ushort _y, ushort _width, ushort _height, __IntPtr _data, ushort _pitch)
            {
                __Internal.DbgTextImage(_x, _y, _width, _height, _data, _pitch);
            }

            /// <summary>Create static index buffer.</summary>
            /// <param name="_mem">Index buffer data.</param>
            /// <param name="_flags">
            /// <para>Buffer creation flags.</para>
            /// <para>- `BGFX_BUFFER_NONE` - No flags.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer</para>
            /// <para>is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.</para>
            /// <para>- `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of</para>
            /// <para>data is passed. If this flag is not specified, and more data is passed on update, the buffer</para>
            /// <para>will be trimmed to fit the existing buffer size. This flag has effect only on dynamic</para>
            /// <para>buffers.</para>
            /// <para>- `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on</para>
            /// <para>index buffers.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_create_index_buffer`.</remarks>
            public static global::Bgfx.Bgfx.IndexBufferHandle CreateIndexBuffer(global::Bgfx.Bgfx.Memory _mem, ushort _flags)
            {
                var __arg0 = _mem is null ? __IntPtr.Zero : _mem.__Instance;
                var __ret = __Internal.CreateIndexBuffer(__arg0, _flags);
                return global::Bgfx.Bgfx.IndexBufferHandle.__CreateInstance(__ret);
            }

            /// <summary>Set static index buffer debug name.</summary>
            /// <param name="_handle">Static index buffer handle.</param>
            /// <param name="_name">Static index buffer name.</param>
            /// <param name="_len">
            /// <para>Static index buffer name length (if length is INT32_MAX, it's expected</para>
            /// <para>that _name is zero terminated string.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_index_buffer_name`.</remarks>
            public static void SetName(global::Bgfx.Bgfx.IndexBufferHandle _handle, string _name, int _len)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetName(*(global::Bgfx.Bgfx.IndexBufferHandle.__Internal*) __arg0, _name, _len);
            }

            /// <summary>Destroy static index buffer.</summary>
            /// <param name="_handle">Static index buffer handle.</param>
            /// <remarks>C99's equivalent binding is `bgfx_destroy_index_buffer`.</remarks>
            public static void Destroy(global::Bgfx.Bgfx.IndexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.Destroy(*(global::Bgfx.Bgfx.IndexBufferHandle.__Internal*) __arg0);
            }

            /// <summary>Create vertex layout.</summary>
            /// <remarks>C99's equivalent binding is `bgfx_create_vertex_layout`.</remarks>
            public static global::Bgfx.Bgfx.VertexLayoutHandle CreateVertexLayout(global::Bgfx.Bgfx.VertexLayout _layout)
            {
                if (ReferenceEquals(_layout, null))
                    throw new global::System.ArgumentNullException("_layout", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _layout.__Instance;
                var __ret = __Internal.CreateVertexLayout(__arg0);
                return global::Bgfx.Bgfx.VertexLayoutHandle.__CreateInstance(__ret);
            }

            /// <summary>Destroy vertex layout.</summary>
            /// <remarks>C99's equivalent binding is `bgfx_destroy_vertex_layout`.</remarks>
            public static void Destroy(global::Bgfx.Bgfx.VertexLayoutHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.Destroy_1(*(global::Bgfx.Bgfx.VertexLayoutHandle.__Internal*) __arg0);
            }

            /// <summary>Create static vertex buffer.</summary>
            /// <param name="_mem">Vertex buffer data.</param>
            /// <param name="_layout">Vertex layout.</param>
            /// <param name="_flags">
            /// <para>Buffer creation flags.</para>
            /// <para>- `BGFX_BUFFER_NONE` - No flags.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer</para>
            /// <para>is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.</para>
            /// <para>- `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of</para>
            /// <para>data is passed. If this flag is not specified, and more data is passed on update, the buffer</para>
            /// <para>will be trimmed to fit the existing buffer size. This flag has effect only on dynamic</para>
            /// <para>buffers.</para>
            /// <para>- `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on</para>
            /// <para>index buffers.</para>
            /// </param>
            /// <remarks>
            /// <para>Static vertex buffer handle.</para>
            /// <para>C99's equivalent binding is `bgfx_create_vertex_buffer`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.VertexBufferHandle CreateVertexBuffer(global::Bgfx.Bgfx.Memory _mem, global::Bgfx.Bgfx.VertexLayout _layout, ushort _flags)
            {
                var __arg0 = _mem is null ? __IntPtr.Zero : _mem.__Instance;
                if (ReferenceEquals(_layout, null))
                    throw new global::System.ArgumentNullException("_layout", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _layout.__Instance;
                var __ret = __Internal.CreateVertexBuffer(__arg0, __arg1, _flags);
                return global::Bgfx.Bgfx.VertexBufferHandle.__CreateInstance(__ret);
            }

            /// <summary>Set static vertex buffer debug name.</summary>
            /// <param name="_handle">Static vertex buffer handle.</param>
            /// <param name="_name">Static vertex buffer name.</param>
            /// <param name="_len">
            /// <para>Static vertex buffer name length (if length is INT32_MAX, it's expected</para>
            /// <para>that _name is zero terminated string.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_vertex_buffer_name`.</remarks>
            public static void SetName(global::Bgfx.Bgfx.VertexBufferHandle _handle, string _name, int _len)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetName_1(*(global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) __arg0, _name, _len);
            }

            /// <summary>Destroy static vertex buffer.</summary>
            /// <param name="_handle">Static vertex buffer handle.</param>
            /// <remarks>C99's equivalent binding is `bgfx_destroy_vertex_buffer`.</remarks>
            public static void Destroy(global::Bgfx.Bgfx.VertexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.Destroy_2(*(global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) __arg0);
            }

            /// <summary>Create empty dynamic index buffer.</summary>
            /// <param name="_num">Number of indices.</param>
            /// <param name="_flags">
            /// <para>Buffer creation flags.</para>
            /// <para>- `BGFX_BUFFER_NONE` - No flags.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer</para>
            /// <para>is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.</para>
            /// <para>- `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of</para>
            /// <para>data is passed. If this flag is not specified, and more data is passed on update, the buffer</para>
            /// <para>will be trimmed to fit the existing buffer size. This flag has effect only on dynamic</para>
            /// <para>buffers.</para>
            /// <para>- `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on</para>
            /// <para>index buffers.</para>
            /// </param>
            /// <remarks>
            /// <para>Dynamic index buffer handle.</para>
            /// <para>C99's equivalent binding is `bgfx_create_dynamic_index_buffer`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.DynamicIndexBufferHandle CreateDynamicIndexBuffer(uint _num, ushort _flags)
            {
                var __ret = __Internal.CreateDynamicIndexBuffer(_num, _flags);
                return global::Bgfx.Bgfx.DynamicIndexBufferHandle.__CreateInstance(__ret);
            }

            /// <summary>Create a dynamic index buffer and initialize it.</summary>
            /// <param name="_mem">Index buffer data.</param>
            /// <param name="_flags">
            /// <para>Buffer creation flags.</para>
            /// <para>- `BGFX_BUFFER_NONE` - No flags.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer</para>
            /// <para>is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.</para>
            /// <para>- `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of</para>
            /// <para>data is passed. If this flag is not specified, and more data is passed on update, the buffer</para>
            /// <para>will be trimmed to fit the existing buffer size. This flag has effect only on dynamic</para>
            /// <para>buffers.</para>
            /// <para>- `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on</para>
            /// <para>index buffers.</para>
            /// </param>
            /// <remarks>
            /// <para>Dynamic index buffer handle.</para>
            /// <para>C99's equivalent binding is `bgfx_create_dynamic_index_buffer_mem`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.DynamicIndexBufferHandle CreateDynamicIndexBuffer(global::Bgfx.Bgfx.Memory _mem, ushort _flags)
            {
                var __arg0 = _mem is null ? __IntPtr.Zero : _mem.__Instance;
                var __ret = __Internal.CreateDynamicIndexBuffer(__arg0, _flags);
                return global::Bgfx.Bgfx.DynamicIndexBufferHandle.__CreateInstance(__ret);
            }

            /// <summary>Update dynamic index buffer.</summary>
            /// <param name="_handle">Dynamic index buffer handle.</param>
            /// <param name="_startIndex">Start index.</param>
            /// <param name="_mem">Index buffer data.</param>
            /// <remarks>C99's equivalent binding is `bgfx_update_dynamic_index_buffer`.</remarks>
            public static void Update(global::Bgfx.Bgfx.DynamicIndexBufferHandle _handle, uint _startIndex, global::Bgfx.Bgfx.Memory _mem)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __arg2 = _mem is null ? __IntPtr.Zero : _mem.__Instance;
                __Internal.Update(*(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal*) __arg0, _startIndex, __arg2);
            }

            /// <summary>Destroy dynamic index buffer.</summary>
            /// <param name="_handle">Dynamic index buffer handle.</param>
            /// <remarks>C99's equivalent binding is `bgfx_destroy_dynamic_index_buffer`.</remarks>
            public static void Destroy(global::Bgfx.Bgfx.DynamicIndexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.Destroy_3(*(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal*) __arg0);
            }

            /// <summary>Create empty dynamic vertex buffer.</summary>
            /// <param name="_num">Number of vertices.</param>
            /// <param name="_layout">Vertex layout.</param>
            /// <param name="_flags">
            /// <para>Buffer creation flags.</para>
            /// <para>- `BGFX_BUFFER_NONE` - No flags.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer</para>
            /// <para>is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.</para>
            /// <para>- `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of</para>
            /// <para>data is passed. If this flag is not specified, and more data is passed on update, the buffer</para>
            /// <para>will be trimmed to fit the existing buffer size. This flag has effect only on dynamic</para>
            /// <para>buffers.</para>
            /// <para>- `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on</para>
            /// <para>index buffers.</para>
            /// </param>
            /// <remarks>
            /// <para>Dynamic vertex buffer handle.</para>
            /// <para>C99's equivalent binding is `bgfx_create_dynamic_vertex_buffer`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.DynamicVertexBufferHandle CreateDynamicVertexBuffer(uint _num, global::Bgfx.Bgfx.VertexLayout _layout, ushort _flags)
            {
                if (ReferenceEquals(_layout, null))
                    throw new global::System.ArgumentNullException("_layout", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _layout.__Instance;
                var __ret = __Internal.CreateDynamicVertexBuffer(_num, __arg1, _flags);
                return global::Bgfx.Bgfx.DynamicVertexBufferHandle.__CreateInstance(__ret);
            }

            /// <summary>Create dynamic vertex buffer and initialize it.</summary>
            /// <param name="_mem">Vertex buffer data.</param>
            /// <param name="_layout">Vertex layout.</param>
            /// <param name="_flags">
            /// <para>Buffer creation flags.</para>
            /// <para>- `BGFX_BUFFER_NONE` - No flags.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_READ` - Buffer will be read from by compute shader.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_WRITE` - Buffer will be written into by compute shader. When buffer</para>
            /// <para>is created with `BGFX_BUFFER_COMPUTE_WRITE` flag it cannot be updated from CPU.</para>
            /// <para>- `BGFX_BUFFER_COMPUTE_READ_WRITE` - Buffer will be used for read/write by compute shader.</para>
            /// <para>- `BGFX_BUFFER_ALLOW_RESIZE` - Buffer will resize on buffer update if a different amount of</para>
            /// <para>data is passed. If this flag is not specified, and more data is passed on update, the buffer</para>
            /// <para>will be trimmed to fit the existing buffer size. This flag has effect only on dynamic</para>
            /// <para>buffers.</para>
            /// <para>- `BGFX_BUFFER_INDEX32` - Buffer is using 32-bit indices. This flag has effect only on</para>
            /// <para>index buffers.</para>
            /// </param>
            /// <remarks>
            /// <para>Dynamic vertex buffer handle.</para>
            /// <para>C99's equivalent binding is `bgfx_create_dynamic_vertex_buffer_mem`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.DynamicVertexBufferHandle CreateDynamicVertexBuffer(global::Bgfx.Bgfx.Memory _mem, global::Bgfx.Bgfx.VertexLayout _layout, ushort _flags)
            {
                var __arg0 = _mem is null ? __IntPtr.Zero : _mem.__Instance;
                if (ReferenceEquals(_layout, null))
                    throw new global::System.ArgumentNullException("_layout", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _layout.__Instance;
                var __ret = __Internal.CreateDynamicVertexBuffer(__arg0, __arg1, _flags);
                return global::Bgfx.Bgfx.DynamicVertexBufferHandle.__CreateInstance(__ret);
            }

            /// <summary>Update dynamic vertex buffer.</summary>
            /// <param name="_handle">Dynamic vertex buffer handle.</param>
            /// <param name="_startVertex">Start vertex.</param>
            /// <param name="_mem">Vertex buffer data.</param>
            /// <remarks>C99's equivalent binding is `bgfx_update_dynamic_vertex_buffer`.</remarks>
            public static void Update(global::Bgfx.Bgfx.DynamicVertexBufferHandle _handle, uint _startVertex, global::Bgfx.Bgfx.Memory _mem)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __arg2 = _mem is null ? __IntPtr.Zero : _mem.__Instance;
                __Internal.Update_1(*(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal*) __arg0, _startVertex, __arg2);
            }

            /// <summary>Destroy dynamic vertex buffer.</summary>
            /// <param name="_handle">Dynamic vertex buffer handle.</param>
            /// <remarks>C99's equivalent binding is `bgfx_destroy_dynamic_vertex_buffer`.</remarks>
            public static void Destroy(global::Bgfx.Bgfx.DynamicVertexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.Destroy_4(*(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal*) __arg0);
            }

            /// <summary>Returns number of requested or maximum available indices.</summary>
            /// <param name="_num">Number of required indices.</param>
            /// <param name="_index32">Set to `true` if input indices will be 32-bit.</param>
            /// <remarks>C99's equivalent binding is `bgfx_get_avail_transient_index_buffer`.</remarks>
            public static uint GetAvailTransientIndexBuffer(uint _num, bool _index32)
            {
                var __ret = __Internal.GetAvailTransientIndexBuffer(_num, _index32);
                return __ret;
            }

            /// <summary>Returns number of requested or maximum available vertices.</summary>
            /// <param name="_num">Number of required vertices.</param>
            /// <param name="_layout">Vertex layout.</param>
            /// <remarks>C99's equivalent binding is `bgfx_get_avail_transient_vertex_buffer`.</remarks>
            public static uint GetAvailTransientVertexBuffer(uint _num, global::Bgfx.Bgfx.VertexLayout _layout)
            {
                if (ReferenceEquals(_layout, null))
                    throw new global::System.ArgumentNullException("_layout", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _layout.__Instance;
                var __ret = __Internal.GetAvailTransientVertexBuffer(_num, __arg1);
                return __ret;
            }

            /// <summary>Returns number of requested or maximum available instance buffer slots.</summary>
            /// <param name="_num">Number of required instances.</param>
            /// <param name="_stride">Stride per instance.</param>
            /// <remarks>C99's equivalent binding is `bgfx_get_avail_instance_data_buffer`.</remarks>
            public static uint GetAvailInstanceDataBuffer(uint _num, ushort _stride)
            {
                var __ret = __Internal.GetAvailInstanceDataBuffer(_num, _stride);
                return __ret;
            }

            /// <summary>Allocate transient index buffer.</summary>
            /// <param name="_tib">
            /// <para>TransientIndexBuffer structure is filled and is valid</para>
            /// <para>for the duration of frame, and it can be reused for multiple draw</para>
            /// <para>calls.</para>
            /// </param>
            /// <param name="_num">Number of indices to allocate.</param>
            /// <param name="_index32">Set to `true` if input indices will be 32-bit.</param>
            /// <remarks>C99's equivalent binding is `bgfx_alloc_transient_index_buffer`.</remarks>
            public static void AllocTransientIndexBuffer(global::Bgfx.Bgfx.TransientIndexBuffer _tib, uint _num, bool _index32)
            {
                var __arg0 = _tib is null ? __IntPtr.Zero : _tib.__Instance;
                __Internal.AllocTransientIndexBuffer(__arg0, _num, _index32);
            }

            /// <summary>Allocate transient vertex buffer.</summary>
            /// <param name="_tvb">
            /// <para>TransientVertexBuffer structure is filled and is valid</para>
            /// <para>for the duration of frame, and it can be reused for multiple draw</para>
            /// <para>calls.</para>
            /// </param>
            /// <param name="_num">Number of vertices to allocate.</param>
            /// <param name="_layout">Vertex layout.</param>
            /// <remarks>C99's equivalent binding is `bgfx_alloc_transient_vertex_buffer`.</remarks>
            public static void AllocTransientVertexBuffer(global::Bgfx.Bgfx.TransientVertexBuffer _tvb, uint _num, global::Bgfx.Bgfx.VertexLayout _layout)
            {
                var __arg0 = _tvb is null ? __IntPtr.Zero : _tvb.__Instance;
                if (ReferenceEquals(_layout, null))
                    throw new global::System.ArgumentNullException("_layout", "Cannot be null because it is a C++ reference (&).");
                var __arg2 = _layout.__Instance;
                __Internal.AllocTransientVertexBuffer(__arg0, _num, __arg2);
            }

            /// <summary>
            /// <para>Check for required space and allocate transient vertex and index</para>
            /// <para>buffers. If both space requirements are satisfied function returns</para>
            /// <para>true.</para>
            /// </summary>
            /// <param name="_tvb">
            /// <para>TransientVertexBuffer structure is filled and is valid</para>
            /// <para>for the duration of frame, and it can be reused for multiple draw</para>
            /// <para>calls.</para>
            /// </param>
            /// <param name="_layout">Vertex layout.</param>
            /// <param name="_numVertices">Number of vertices to allocate.</param>
            /// <param name="_tib">
            /// <para>TransientIndexBuffer structure is filled and is valid</para>
            /// <para>for the duration of frame, and it can be reused for multiple draw</para>
            /// <para>calls.</para>
            /// </param>
            /// <param name="_numIndices">Number of indices to allocate.</param>
            /// <param name="_index32">Set to `true` if input indices will be 32-bit.</param>
            /// <remarks>C99's equivalent binding is `bgfx_alloc_transient_buffers`.</remarks>
            public static bool AllocTransientBuffers(global::Bgfx.Bgfx.TransientVertexBuffer _tvb, global::Bgfx.Bgfx.VertexLayout _layout, uint _numVertices, global::Bgfx.Bgfx.TransientIndexBuffer _tib, uint _numIndices, bool _index32)
            {
                var __arg0 = _tvb is null ? __IntPtr.Zero : _tvb.__Instance;
                if (ReferenceEquals(_layout, null))
                    throw new global::System.ArgumentNullException("_layout", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _layout.__Instance;
                var __arg3 = _tib is null ? __IntPtr.Zero : _tib.__Instance;
                var __ret = __Internal.AllocTransientBuffers(__arg0, __arg1, _numVertices, __arg3, _numIndices, _index32);
                return __ret;
            }

            /// <summary>Allocate instance data buffer.</summary>
            /// <param name="_idb">
            /// <para>InstanceDataBuffer structure is filled and is valid</para>
            /// <para>for duration of frame, and it can be reused for multiple draw</para>
            /// <para>calls.</para>
            /// </param>
            /// <param name="_num">Number of instances.</param>
            /// <param name="_stride">Instance stride. Must be multiple of 16.</param>
            /// <remarks>C99's equivalent binding is `bgfx_alloc_instance_data_buffer`.</remarks>
            public static void AllocInstanceDataBuffer(global::Bgfx.Bgfx.InstanceDataBuffer _idb, uint _num, ushort _stride)
            {
                var __arg0 = _idb is null ? __IntPtr.Zero : _idb.__Instance;
                __Internal.AllocInstanceDataBuffer(__arg0, _num, _stride);
            }

            /// <summary>Create draw indirect buffer.</summary>
            /// <param name="_num">Number of indirect calls.</param>
            /// <remarks>
            /// <para>Indirect buffer handle.</para>
            /// <para>C99's equivalent binding is `bgfx_create_indirect_buffer`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.IndirectBufferHandle CreateIndirectBuffer(uint _num)
            {
                var __ret = __Internal.CreateIndirectBuffer(_num);
                return global::Bgfx.Bgfx.IndirectBufferHandle.__CreateInstance(__ret);
            }

            /// <summary>Destroy draw indirect buffer.</summary>
            /// <param name="_handle">Indirect buffer handle.</param>
            /// <remarks>C99's equivalent binding is `bgfx_destroy_indirect_buffer`.</remarks>
            public static void Destroy(global::Bgfx.Bgfx.IndirectBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.Destroy_5(*(global::Bgfx.Bgfx.IndirectBufferHandle.__Internal*) __arg0);
            }

            /// <summary>Create shader from memory buffer.</summary>
            /// <remarks>
            /// <para>Shader handle.</para>
            /// <para>C99's equivalent binding is `bgfx_create_shader`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.ShaderHandle CreateShader(global::Bgfx.Bgfx.Memory _mem)
            {
                var __arg0 = _mem is null ? __IntPtr.Zero : _mem.__Instance;
                var __ret = __Internal.CreateShader(__arg0);
                return global::Bgfx.Bgfx.ShaderHandle.__CreateInstance(__ret);
            }

            /// <summary>Returns the number of uniforms and uniform handles used inside a shader.</summary>
            /// <param name="_handle">Shader handle.</param>
            /// <param name="_uniforms">UniformHandle array where data will be stored.</param>
            /// <param name="_max">Maximum capacity of array.</param>
            /// <remarks>
            /// <para>Number of uniforms used by shader.</para>
            /// <para>Only non-predefined uniforms are returned.</para>
            /// <para>C99's equivalent binding is `bgfx_get_shader_uniforms`.</para>
            /// </remarks>
            public static ushort GetShaderUniforms(global::Bgfx.Bgfx.ShaderHandle _handle, global::Bgfx.Bgfx.UniformHandle _uniforms, ushort _max)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __arg1 = _uniforms is null ? __IntPtr.Zero : _uniforms.__Instance;
                var __ret = __Internal.GetShaderUniforms(*(global::Bgfx.Bgfx.ShaderHandle.__Internal*) __arg0, __arg1, _max);
                return __ret;
            }

            /// <summary>Set shader debug name.</summary>
            /// <param name="_handle">Shader handle.</param>
            /// <param name="_name">Shader name.</param>
            /// <param name="_len">
            /// <para>Shader name length (if length is INT32_MAX, it's expected</para>
            /// <para>that _name is zero terminated string.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_shader_name`.</remarks>
            public static void SetName(global::Bgfx.Bgfx.ShaderHandle _handle, string _name, int _len)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetName_2(*(global::Bgfx.Bgfx.ShaderHandle.__Internal*) __arg0, _name, _len);
            }

            /// <summary>
            /// <para>Destroy shader. Once a shader program is created with _handle,</para>
            /// <para>it is safe to destroy that shader.</para>
            /// </summary>
            /// <param name="_handle">Shader handle.</param>
            /// <remarks>C99's equivalent binding is `bgfx_destroy_shader`.</remarks>
            public static void Destroy(global::Bgfx.Bgfx.ShaderHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.Destroy_6(*(global::Bgfx.Bgfx.ShaderHandle.__Internal*) __arg0);
            }

            /// <summary>Create program with vertex and fragment shaders.</summary>
            /// <param name="_vsh">Vertex shader.</param>
            /// <param name="_fsh">Fragment shader.</param>
            /// <param name="_destroyShaders">
            /// <para>If true, shaders will be destroyed when</para>
            /// <para>program is destroyed.</para>
            /// </param>
            /// <remarks>
            /// <para>Program handle if vertex shader output and fragment shader</para>
            /// <para>input are matching, otherwise returns invalid program handle.</para>
            /// <para>C99's equivalent binding is `bgfx_create_program`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.ProgramHandle CreateProgram(global::Bgfx.Bgfx.ShaderHandle _vsh, global::Bgfx.Bgfx.ShaderHandle _fsh, bool _destroyShaders)
            {
                if (ReferenceEquals(_vsh, null))
                    throw new global::System.ArgumentNullException("_vsh", "Cannot be null because it is passed by value.");
                var __arg0 = _vsh.__Instance;
                if (ReferenceEquals(_fsh, null))
                    throw new global::System.ArgumentNullException("_fsh", "Cannot be null because it is passed by value.");
                var __arg1 = _fsh.__Instance;
                var __ret = __Internal.CreateProgram(*(global::Bgfx.Bgfx.ShaderHandle.__Internal*) __arg0, *(global::Bgfx.Bgfx.ShaderHandle.__Internal*) __arg1, _destroyShaders);
                return global::Bgfx.Bgfx.ProgramHandle.__CreateInstance(__ret);
            }

            /// <summary>Create program with compute shader.</summary>
            /// <param name="_csh">Compute shader.</param>
            /// <param name="_destroyShader">
            /// <para>If true, shader will be destroyed when</para>
            /// <para>program is destroyed.</para>
            /// </param>
            /// <remarks>
            /// <para>Program handle.</para>
            /// <para>C99's equivalent binding is `bgfx_create_compute_program`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.ProgramHandle CreateProgram(global::Bgfx.Bgfx.ShaderHandle _csh, bool _destroyShader)
            {
                if (ReferenceEquals(_csh, null))
                    throw new global::System.ArgumentNullException("_csh", "Cannot be null because it is passed by value.");
                var __arg0 = _csh.__Instance;
                var __ret = __Internal.CreateProgram(*(global::Bgfx.Bgfx.ShaderHandle.__Internal*) __arg0, _destroyShader);
                return global::Bgfx.Bgfx.ProgramHandle.__CreateInstance(__ret);
            }

            /// <summary>Destroy program.</summary>
            /// <param name="_handle">Program handle.</param>
            /// <remarks>C99's equivalent binding is `bgfx_destroy_program`.</remarks>
            public static void Destroy(global::Bgfx.Bgfx.ProgramHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.Destroy_7(*(global::Bgfx.Bgfx.ProgramHandle.__Internal*) __arg0);
            }

            /// <summary>Validate texture parameters.</summary>
            /// <param name="_depth">Depth dimension of volume texture.</param>
            /// <param name="_cubeMap">Indicates that texture contains cubemap.</param>
            /// <param name="_numLayers">Number of layers in texture array.</param>
            /// <param name="_format">Texture format. See: `TextureFormat::Enum`.</param>
            /// <param name="_flags">Texture flags. See `BGFX_TEXTURE_*`.</param>
            /// <remarks>
            /// <para>True if a texture with the same parameters can be created.</para>
            /// <para>C99's equivalent binding is `bgfx_is_texture_valid`.</para>
            /// </remarks>
            public static bool IsTextureValid(ushort _depth, bool _cubeMap, ushort _numLayers, global::Bgfx.Bgfx.TextureFormat.Enum _format, ulong _flags)
            {
                var __ret = __Internal.IsTextureValid(_depth, _cubeMap, _numLayers, _format, _flags);
                return __ret;
            }

            /// <summary>Validate frame buffer parameters.</summary>
            /// <param name="_num">Number of attachments.</param>
            /// <param name="_attachment">Attachment texture info. See: `bgfx::Attachment`.</param>
            /// <remarks>True if a frame buffer with the same parameters can be created.</remarks>
            public static bool IsFrameBufferValid(byte _num, global::Bgfx.Bgfx.Attachment _attachment)
            {
                var __arg1 = _attachment is null ? __IntPtr.Zero : _attachment.__Instance;
                var __ret = __Internal.IsFrameBufferValid(_num, __arg1);
                return __ret;
            }

            /// <summary>Calculate amount of memory required for texture.</summary>
            /// <param name="_info">Resulting texture info structure. See: `TextureInfo`.</param>
            /// <param name="_width">Width.</param>
            /// <param name="_height">Height.</param>
            /// <param name="_depth">Depth dimension of volume texture.</param>
            /// <param name="_cubeMap">Indicates that texture contains cubemap.</param>
            /// <param name="_hasMips">Indicates that texture contains full mip-map chain.</param>
            /// <param name="_numLayers">Number of layers in texture array.</param>
            /// <param name="_format">Texture format. See: `TextureFormat::Enum`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_calc_texture_size`.</remarks>
            public static void CalcTextureSize(global::Bgfx.Bgfx.TextureInfo _info, ushort _width, ushort _height, ushort _depth, bool _cubeMap, bool _hasMips, ushort _numLayers, global::Bgfx.Bgfx.TextureFormat.Enum _format)
            {
                if (ReferenceEquals(_info, null))
                    throw new global::System.ArgumentNullException("_info", "Cannot be null because it is a C++ reference (&).");
                var __arg0 = _info.__Instance;
                __Internal.CalcTextureSize(__arg0, _width, _height, _depth, _cubeMap, _hasMips, _numLayers, _format);
            }

            /// <summary>Create texture from memory buffer.</summary>
            /// <param name="_mem">DDS, KTX or PVR texture data.</param>
            /// <param name="_flags">
            /// <para>Texture creation (see `BGFX_TEXTURE_*`.), and sampler (see `BGFX_SAMPLER_*`)</para>
            /// <para>flags. Default texture sampling mode is linear, and wrap mode is repeat.</para>
            /// <para>- `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap</para>
            /// <para>mode.</para>
            /// <para>- `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic</para>
            /// <para>sampling.</para>
            /// </param>
            /// <param name="_skip">Skip top level mips when parsing texture.</param>
            /// <param name="_info">When non-`NULL` is specified it returns parsed texture information.</param>
            /// <remarks>
            /// <para>Texture handle.</para>
            /// <para>C99's equivalent binding is `bgfx_create_texture`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.TextureHandle CreateTexture(global::Bgfx.Bgfx.Memory _mem, ulong _flags, byte _skip, global::Bgfx.Bgfx.TextureInfo _info)
            {
                var __arg0 = _mem is null ? __IntPtr.Zero : _mem.__Instance;
                var __arg3 = _info is null ? __IntPtr.Zero : _info.__Instance;
                var __ret = __Internal.CreateTexture(__arg0, _flags, _skip, __arg3);
                return global::Bgfx.Bgfx.TextureHandle.__CreateInstance(__ret);
            }

            /// <summary>Create 2D texture.</summary>
            /// <param name="_width">Width.</param>
            /// <param name="_height">Height.</param>
            /// <param name="_hasMips">Indicates that texture contains full mip-map chain.</param>
            /// <param name="_numLayers">
            /// <para>Number of layers in texture array. Must be 1 if caps</para>
            /// <para>`BGFX_CAPS_TEXTURE_2D_ARRAY` flag is not set.</para>
            /// </param>
            /// <param name="_format">Texture format. See: `TextureFormat::Enum`.</param>
            /// <param name="_flags">
            /// <para>Texture creation (see `BGFX_TEXTURE_*`.), and sampler (see `BGFX_SAMPLER_*`)</para>
            /// <para>flags. Default texture sampling mode is linear, and wrap mode is repeat.</para>
            /// <para>- `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap</para>
            /// <para>mode.</para>
            /// <para>- `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic</para>
            /// <para>sampling.</para>
            /// </param>
            /// <param name="_mem">
            /// <para>Texture data. If `_mem` is non-NULL, created texture will be immutable. If</para>
            /// <para>`_mem` is NULL content of the texture is uninitialized. When `_numLayers` is more than</para>
            /// <para>1, expected memory layout is texture and all mips together for each array element.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_create_texture_2d`.</remarks>
            public static global::Bgfx.Bgfx.TextureHandle CreateTexture2D(ushort _width, ushort _height, bool _hasMips, ushort _numLayers, global::Bgfx.Bgfx.TextureFormat.Enum _format, ulong _flags, global::Bgfx.Bgfx.Memory _mem)
            {
                var __arg6 = _mem is null ? __IntPtr.Zero : _mem.__Instance;
                var __ret = __Internal.CreateTexture2D(_width, _height, _hasMips, _numLayers, _format, _flags, __arg6);
                return global::Bgfx.Bgfx.TextureHandle.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Create texture with size based on back-buffer ratio. Texture will maintain ratio</para>
            /// <para>if back buffer resolution changes.</para>
            /// </summary>
            /// <param name="_ratio">
            /// <para>Frame buffer size in respect to back-buffer size. See:</para>
            /// <para>`BackbufferRatio::Enum`.</para>
            /// </param>
            /// <param name="_hasMips">Indicates that texture contains full mip-map chain.</param>
            /// <param name="_numLayers">
            /// <para>Number of layers in texture array. Must be 1 if caps</para>
            /// <para>`BGFX_CAPS_TEXTURE_2D_ARRAY` flag is not set.</para>
            /// </param>
            /// <param name="_format">Texture format. See: `TextureFormat::Enum`.</param>
            /// <param name="_flags">
            /// <para>Texture creation (see `BGFX_TEXTURE_*`.), and sampler (see `BGFX_SAMPLER_*`)</para>
            /// <para>flags. Default texture sampling mode is linear, and wrap mode is repeat.</para>
            /// <para>- `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap</para>
            /// <para>mode.</para>
            /// <para>- `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic</para>
            /// <para>sampling.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_create_texture_2d_scaled`.</remarks>
            public static global::Bgfx.Bgfx.TextureHandle CreateTexture2D(global::Bgfx.Bgfx.BackbufferRatio.Enum _ratio, bool _hasMips, ushort _numLayers, global::Bgfx.Bgfx.TextureFormat.Enum _format, ulong _flags)
            {
                var __ret = __Internal.CreateTexture2D(_ratio, _hasMips, _numLayers, _format, _flags);
                return global::Bgfx.Bgfx.TextureHandle.__CreateInstance(__ret);
            }

            /// <summary>Create 3D texture.</summary>
            /// <param name="_width">Width.</param>
            /// <param name="_height">Height.</param>
            /// <param name="_depth">Depth.</param>
            /// <param name="_hasMips">Indicates that texture contains full mip-map chain.</param>
            /// <param name="_format">Texture format. See: `TextureFormat::Enum`.</param>
            /// <param name="_flags">
            /// <para>Texture creation (see `BGFX_TEXTURE_*`.), and sampler (see `BGFX_SAMPLER_*`)</para>
            /// <para>flags. Default texture sampling mode is linear, and wrap mode is repeat.</para>
            /// <para>- `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap</para>
            /// <para>mode.</para>
            /// <para>- `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic</para>
            /// <para>sampling.</para>
            /// </param>
            /// <param name="_mem">
            /// <para>Texture data. If `_mem` is non-NULL, created texture will be immutable. If</para>
            /// <para>`_mem` is NULL content of the texture is uninitialized.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_create_texture_3d`.</remarks>
            public static global::Bgfx.Bgfx.TextureHandle CreateTexture3D(ushort _width, ushort _height, ushort _depth, bool _hasMips, global::Bgfx.Bgfx.TextureFormat.Enum _format, ulong _flags, global::Bgfx.Bgfx.Memory _mem)
            {
                var __arg6 = _mem is null ? __IntPtr.Zero : _mem.__Instance;
                var __ret = __Internal.CreateTexture3D(_width, _height, _depth, _hasMips, _format, _flags, __arg6);
                return global::Bgfx.Bgfx.TextureHandle.__CreateInstance(__ret);
            }

            /// <summary>Create Cube texture.</summary>
            /// <param name="_size">Cube side size.</param>
            /// <param name="_hasMips">Indicates that texture contains full mip-map chain.</param>
            /// <param name="_numLayers">
            /// <para>Number of layers in texture array. Must be 1 if caps</para>
            /// <para>`BGFX_CAPS_TEXTURE_CUBE_ARRAY` flag is not set.</para>
            /// </param>
            /// <param name="_format">Texture format. See: `TextureFormat::Enum`.</param>
            /// <param name="_flags">
            /// <para>Texture creation (see `BGFX_TEXTURE_*`.), and sampler (see `BGFX_SAMPLER_*`)</para>
            /// <para>flags. Default texture sampling mode is linear, and wrap mode is repeat.</para>
            /// <para>- `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap</para>
            /// <para>mode.</para>
            /// <para>- `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic</para>
            /// <para>sampling.</para>
            /// </param>
            /// <param name="_mem">
            /// <para>Texture data. If `_mem` is non-NULL, created texture will be immutable. If</para>
            /// <para>`_mem` is NULL content of the texture is uninitialized. When `_numLayers` is more than</para>
            /// <para>1, expected memory layout is texture and all mips together for each array element.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_create_texture_cube`.</remarks>
            public static global::Bgfx.Bgfx.TextureHandle CreateTextureCube(ushort _size, bool _hasMips, ushort _numLayers, global::Bgfx.Bgfx.TextureFormat.Enum _format, ulong _flags, global::Bgfx.Bgfx.Memory _mem)
            {
                var __arg5 = _mem is null ? __IntPtr.Zero : _mem.__Instance;
                var __ret = __Internal.CreateTextureCube(_size, _hasMips, _numLayers, _format, _flags, __arg5);
                return global::Bgfx.Bgfx.TextureHandle.__CreateInstance(__ret);
            }

            /// <summary>Update 2D texture.</summary>
            /// <param name="_handle">Texture handle.</param>
            /// <param name="_layer">Layers in texture array.</param>
            /// <param name="_mip">Mip level.</param>
            /// <param name="_x">X offset in texture.</param>
            /// <param name="_y">Y offset in texture.</param>
            /// <param name="_width">Width of texture block.</param>
            /// <param name="_height">Height of texture block.</param>
            /// <param name="_mem">Texture update data.</param>
            /// <param name="_pitch">
            /// <para>Pitch of input image (bytes). When _pitch is set to</para>
            /// <para>UINT16_MAX, it will be calculated internally based on _width.</para>
            /// </param>
            /// <remarks>
            /// <para>It's valid to update only mutable texture. See `bgfx::createTexture2D` for more info.</para>
            /// <para>C99's equivalent binding is `bgfx_update_texture_2d`.</para>
            /// </remarks>
            public static void UpdateTexture2D(global::Bgfx.Bgfx.TextureHandle _handle, ushort _layer, byte _mip, ushort _x, ushort _y, ushort _width, ushort _height, global::Bgfx.Bgfx.Memory _mem, ushort _pitch)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __arg7 = _mem is null ? __IntPtr.Zero : _mem.__Instance;
                __Internal.UpdateTexture2D(*(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg0, _layer, _mip, _x, _y, _width, _height, __arg7, _pitch);
            }

            /// <summary>Update 3D texture.</summary>
            /// <param name="_handle">Texture handle.</param>
            /// <param name="_mip">Mip level.</param>
            /// <param name="_x">X offset in texture.</param>
            /// <param name="_y">Y offset in texture.</param>
            /// <param name="_z">Z offset in texture.</param>
            /// <param name="_width">Width of texture block.</param>
            /// <param name="_height">Height of texture block.</param>
            /// <param name="_depth">Depth of texture block.</param>
            /// <param name="_mem">Texture update data.</param>
            /// <remarks>
            /// <para>It's valid to update only mutable texture. See `bgfx::createTexture3D` for more info.</para>
            /// <para>C99's equivalent binding is `bgfx_update_texture_3d`.</para>
            /// </remarks>
            public static void UpdateTexture3D(global::Bgfx.Bgfx.TextureHandle _handle, byte _mip, ushort _x, ushort _y, ushort _z, ushort _width, ushort _height, ushort _depth, global::Bgfx.Bgfx.Memory _mem)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __arg8 = _mem is null ? __IntPtr.Zero : _mem.__Instance;
                __Internal.UpdateTexture3D(*(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg0, _mip, _x, _y, _z, _width, _height, _depth, __arg8);
            }

            /// <summary>Update Cube texture.</summary>
            /// <param name="_handle">Texture handle.</param>
            /// <param name="_layer">Layers in texture array.</param>
            /// <param name="_side">
            /// <para>Cubemap side `BGFX_CUBE_MAP_or NEGATIVE&gt;_, Y or Z&gt;`,</para>
            /// <para>where 0 is +X, 1 is -X, 2 is +Y, 3 is -Y, 4 is +Z, and 5 is -Z.</para>
            /// </param>
            /// <param name="_mip">Mip level.</param>
            /// <param name="_x">X offset in texture.</param>
            /// <param name="_y">Y offset in texture.</param>
            /// <param name="_width">Width of texture block.</param>
            /// <param name="_height">Height of texture block.</param>
            /// <param name="_mem">Texture update data.</param>
            /// <param name="_pitch">
            /// <para>Pitch of input image (bytes). When _pitch is set to</para>
            /// <para>UINT16_MAX, it will be calculated internally based on _width.</para>
            /// </param>
            /// <remarks>
            /// <para>+----------+</para>
            /// <para>|-z       2|</para>
            /// <para>| ^  +y    |</para>
            /// <para>| |        |    Unfolded cube:</para>
            /// <para>| +----&gt;+x |</para>
            /// <para>+----------+----------+----------+----------+</para>
            /// <para>|+y       1|+y       4|+y       0|+y       5|</para>
            /// <para>| ^  -x    | ^  +z    | ^  +x    | ^  -z    |</para>
            /// <para>| |        | |        | |        | |        |</para>
            /// <para>| +----&gt;+z | +----&gt;+x | +----&gt;-z | +----&gt;-x |</para>
            /// <para>+----------+----------+----------+----------+</para>
            /// <para>|+z       3|</para>
            /// <para>| ^  -y    |</para>
            /// <para>| |        |</para>
            /// <para>| +----&gt;+x |</para>
            /// <para>+----------+</para>
            /// <para>It's valid to update only mutable texture. See `bgfx::createTextureCube` for more info.</para>
            /// <para>C99's equivalent binding is `bgfx_update_texture_cube`.</para>
            /// </remarks>
            public static void UpdateTextureCube(global::Bgfx.Bgfx.TextureHandle _handle, ushort _layer, byte _side, byte _mip, ushort _x, ushort _y, ushort _width, ushort _height, global::Bgfx.Bgfx.Memory _mem, ushort _pitch)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __arg8 = _mem is null ? __IntPtr.Zero : _mem.__Instance;
                __Internal.UpdateTextureCube(*(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg0, _layer, _side, _mip, _x, _y, _width, _height, __arg8, _pitch);
            }

            /// <summary>Read back texture content.</summary>
            /// <param name="_handle">Texture handle.</param>
            /// <param name="_data">Destination buffer.</param>
            /// <param name="_mip">Mip level.</param>
            /// <remarks>
            /// <para>Frame number when the result will be available. See: `bgfx::frame`.</para>
            /// <para>Texture must be created with `BGFX_TEXTURE_READ_BACK` flag.</para>
            /// <para>Availability depends on: `BGFX_CAPS_TEXTURE_READ_BACK`.</para>
            /// <para>C99's equivalent binding is `bgfx_read_texture`.</para>
            /// </remarks>
            public static uint ReadTexture(global::Bgfx.Bgfx.TextureHandle _handle, __IntPtr _data, byte _mip)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.ReadTexture(*(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg0, _data, _mip);
                return __ret;
            }

            /// <summary>Set texture debug name.</summary>
            /// <param name="_handle">Texture handle.</param>
            /// <param name="_name">Texture name.</param>
            /// <param name="_len">
            /// <para>Texture name length (if length is INT32_MAX, it's expected</para>
            /// <para>that _name is zero terminated string.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_texture_name`.</remarks>
            public static void SetName(global::Bgfx.Bgfx.TextureHandle _handle, string _name, int _len)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetName_3(*(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg0, _name, _len);
            }

            /// <summary>Returns texture direct access pointer.</summary>
            /// <param name="_handle">Texture handle.</param>
            /// <remarks>
            /// <para>Pointer to texture memory. If returned pointer is `NULL` direct access</para>
            /// <para>is not available for this texture. If pointer is `UINTPTR_MAX` sentinel value</para>
            /// <para>it means texture is pending creation. Pointer returned can be cached and it</para>
            /// <para>will be valid until texture is destroyed.</para>
            /// <para>Availability depends on: `BGFX_CAPS_TEXTURE_DIRECT_ACCESS`. This feature</para>
            /// <para>is available on GPUs that have unified memory architecture (UMA) support.</para>
            /// <para>C99's equivalent binding is `bgfx_get_direct_access_ptr`.</para>
            /// </remarks>
            public static __IntPtr GetDirectAccessPtr(global::Bgfx.Bgfx.TextureHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.GetDirectAccessPtr(*(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg0);
                return __ret;
            }

            /// <summary>Destroy texture.</summary>
            /// <param name="_handle">Texture handle.</param>
            /// <remarks>C99's equivalent binding is `bgfx_destroy_texture`.</remarks>
            public static void Destroy(global::Bgfx.Bgfx.TextureHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.Destroy_8(*(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg0);
            }

            /// <summary>Create frame buffer (simple).</summary>
            /// <param name="_width">Texture width.</param>
            /// <param name="_height">Texture height.</param>
            /// <param name="_format">Texture format. See: `TextureFormat::Enum`.</param>
            /// <param name="_textureFlags">
            /// <para>Default texture sampling mode is linear, and wrap mode</para>
            /// <para>is repeat.</para>
            /// <para>- `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap</para>
            /// <para>mode.</para>
            /// <para>- `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic</para>
            /// <para>sampling.</para>
            /// </param>
            /// <remarks>
            /// <para>Handle to frame buffer object.</para>
            /// <para>C99's equivalent binding is `bgfx_create_frame_buffer`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.FrameBufferHandle CreateFrameBuffer(ushort _width, ushort _height, global::Bgfx.Bgfx.TextureFormat.Enum _format, ulong _textureFlags)
            {
                var __ret = __Internal.CreateFrameBuffer(_width, _height, _format, _textureFlags);
                return global::Bgfx.Bgfx.FrameBufferHandle.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Create frame buffer with size based on back-buffer ratio. Frame buffer will maintain ratio</para>
            /// <para>if back buffer resolution changes.</para>
            /// </summary>
            /// <param name="_ratio">
            /// <para>Frame buffer size in respect to back-buffer size. See:</para>
            /// <para>`BackbufferRatio::Enum`.</para>
            /// </param>
            /// <param name="_format">Texture format. See: `TextureFormat::Enum`.</param>
            /// <param name="_textureFlags">
            /// <para>Default texture sampling mode is linear, and wrap mode</para>
            /// <para>is repeat.</para>
            /// <para>- `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap</para>
            /// <para>mode.</para>
            /// <para>- `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic</para>
            /// <para>sampling.</para>
            /// </param>
            /// <remarks>
            /// <para>Handle to frame buffer object.</para>
            /// <para>C99's equivalent binding is `bgfx_create_frame_buffer_scaled`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.FrameBufferHandle CreateFrameBuffer(global::Bgfx.Bgfx.BackbufferRatio.Enum _ratio, global::Bgfx.Bgfx.TextureFormat.Enum _format, ulong _textureFlags)
            {
                var __ret = __Internal.CreateFrameBuffer(_ratio, _format, _textureFlags);
                return global::Bgfx.Bgfx.FrameBufferHandle.__CreateInstance(__ret);
            }

            /// <summary>Create MRT frame buffer from texture handles (simple).</summary>
            /// <param name="_num">Number of texture attachments.</param>
            /// <param name="_handles">Texture attachments.</param>
            /// <param name="_destroyTextures">
            /// <para>If true, textures will be destroyed when</para>
            /// <para>frame buffer is destroyed.</para>
            /// </param>
            /// <remarks>
            /// <para>Handle to frame buffer object.</para>
            /// <para>C99's equivalent binding is `bgfx_create_frame_buffer_from_handles`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.FrameBufferHandle CreateFrameBuffer(byte _num, global::Bgfx.Bgfx.TextureHandle _handles, bool _destroyTextures)
            {
                var __arg1 = _handles is null ? __IntPtr.Zero : _handles.__Instance;
                var __ret = __Internal.CreateFrameBuffer(_num, __arg1, _destroyTextures);
                return global::Bgfx.Bgfx.FrameBufferHandle.__CreateInstance(__ret);
            }

            /// <summary>
            /// <para>Create MRT frame buffer from texture handles with specific layer and</para>
            /// <para>mip level.</para>
            /// </summary>
            /// <param name="_num">Number of texture attachments.</param>
            /// <param name="_attachment">Attachment texture info. See: `bgfx::Attachment`.</param>
            /// <param name="_destroyTextures">
            /// <para>If true, textures will be destroyed when</para>
            /// <para>frame buffer is destroyed.</para>
            /// </param>
            /// <remarks>
            /// <para>Handle to frame buffer object.</para>
            /// <para>C99's equivalent binding is `bgfx_create_frame_buffer_from_attachment`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.FrameBufferHandle CreateFrameBuffer(byte _num, global::Bgfx.Bgfx.Attachment _attachment, bool _destroyTextures)
            {
                var __arg1 = _attachment is null ? __IntPtr.Zero : _attachment.__Instance;
                var __ret = __Internal.CreateFrameBuffer_1(_num, __arg1, _destroyTextures);
                return global::Bgfx.Bgfx.FrameBufferHandle.__CreateInstance(__ret);
            }

            /// <summary>Create frame buffer for multiple window rendering.</summary>
            /// <param name="_nwh">OS' target native window handle.</param>
            /// <param name="_width">Window back buffer width.</param>
            /// <param name="_height">Window back buffer height.</param>
            /// <param name="_format">Window back buffer color format.</param>
            /// <param name="_depthFormat">Window back buffer depth format.</param>
            /// <remarks>
            /// <para>Handle to frame buffer object.</para>
            /// <para>Frame buffer cannot be used for sampling.</para>
            /// <para>C99's equivalent binding is `bgfx_create_frame_buffer_from_nwh`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.FrameBufferHandle CreateFrameBuffer(__IntPtr _nwh, ushort _width, ushort _height, global::Bgfx.Bgfx.TextureFormat.Enum _format, global::Bgfx.Bgfx.TextureFormat.Enum _depthFormat)
            {
                var __ret = __Internal.CreateFrameBuffer(_nwh, _width, _height, _format, _depthFormat);
                return global::Bgfx.Bgfx.FrameBufferHandle.__CreateInstance(__ret);
            }

            /// <summary>Set frame buffer debug name.</summary>
            /// <param name="_handle">frame buffer handle.</param>
            /// <param name="_name">frame buffer name.</param>
            /// <param name="_len">
            /// <para>frame buffer name length (if length is INT32_MAX, it's expected</para>
            /// <para>that _name is zero terminated string.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_frame_buffer_name`.</remarks>
            public static void SetName(global::Bgfx.Bgfx.FrameBufferHandle _handle, string _name, int _len)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetName_4(*(global::Bgfx.Bgfx.FrameBufferHandle.__Internal*) __arg0, _name, _len);
            }

            /// <summary>Obtain texture handle of frame buffer attachment.</summary>
            /// <param name="_handle">Frame buffer handle.</param>
            /// <param name="_attachment">Frame buffer attachment index.</param>
            /// <remarks>
            /// <para>Returns invalid texture handle if attachment index is not</para>
            /// <para>correct, or frame buffer is created with native window handle.</para>
            /// <para>C99's equivalent binding is `bgfx_get_texture`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.TextureHandle GetTexture(global::Bgfx.Bgfx.FrameBufferHandle _handle, byte _attachment)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                var __ret = __Internal.GetTexture(*(global::Bgfx.Bgfx.FrameBufferHandle.__Internal*) __arg0, _attachment);
                return global::Bgfx.Bgfx.TextureHandle.__CreateInstance(__ret);
            }

            /// <summary>Destroy frame buffer.</summary>
            /// <param name="_handle">Frame buffer handle.</param>
            /// <remarks>C99's equivalent binding is `bgfx_destroy_frame_buffer`.</remarks>
            public static void Destroy(global::Bgfx.Bgfx.FrameBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.Destroy_9(*(global::Bgfx.Bgfx.FrameBufferHandle.__Internal*) __arg0);
            }

            /// <summary>Create shader uniform parameter.</summary>
            /// <param name="_name">Uniform name in shader.</param>
            /// <param name="_type">Type of uniform (See: `bgfx::UniformType`).</param>
            /// <param name="_num">Number of elements in array.</param>
            /// <remarks>
            /// <para>Handle to uniform object.</para>
            /// <para>1. Uniform names are unique. It's valid to call `bgfx::createUniform`</para>
            /// <para>multiple times with the same uniform name. The library will always</para>
            /// <para>return the same handle, but the handle reference count will be</para>
            /// <para>incremented. This means that the same number of `bgfx::destroyUniform`</para>
            /// <para>must be called to properly destroy the uniform.</para>
            /// <para>2. Predefined uniforms (declared in `bgfx_shader.sh`):</para>
            /// <para>- `u_viewRect vec4(x, y, width, height)` - view rectangle for current</para>
            /// <para>view, in pixels.</para>
            /// <para>- `u_viewTexel vec4(1.0/width, 1.0/height, undef, undef)` - inverse</para>
            /// <para>width and height</para>
            /// <para>- `u_view mat4` - view matrix</para>
            /// <para>- `u_invView mat4` - inverted view matrix</para>
            /// <para>- `u_proj mat4` - projection matrix</para>
            /// <para>- `u_invProj mat4` - inverted projection matrix</para>
            /// <para>- `u_viewProj mat4` - concatenated view projection matrix</para>
            /// <para>- `u_invViewProj mat4` - concatenated inverted view projection matrix</para>
            /// <para>- `u_model mat4[BGFX_CONFIG_MAX_BONES]` - array of model matrices.</para>
            /// <para>- `u_modelView mat4` - concatenated model view matrix, only first</para>
            /// <para>model matrix from array is used.</para>
            /// <para>- `u_modelViewProj mat4` - concatenated model view projection matrix.</para>
            /// <para>- `u_alphaRef float` - alpha reference value for alpha test.</para>
            /// <para>C99's equivalent binding is `bgfx_create_uniform`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.UniformHandle CreateUniform(string _name, global::Bgfx.Bgfx.UniformType.Enum _type, ushort _num)
            {
                var __ret = __Internal.CreateUniform(_name, _type, _num);
                return global::Bgfx.Bgfx.UniformHandle.__CreateInstance(__ret);
            }

            /// <summary>Retrieve uniform info.</summary>
            /// <param name="_handle">Handle to uniform object.</param>
            /// <param name="_info">Uniform info.</param>
            /// <remarks>C99's equivalent binding is `bgfx_get_uniform_info`.</remarks>
            public static void GetUniformInfo(global::Bgfx.Bgfx.UniformHandle _handle, global::Bgfx.Bgfx.UniformInfo _info)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                if (ReferenceEquals(_info, null))
                    throw new global::System.ArgumentNullException("_info", "Cannot be null because it is a C++ reference (&).");
                var __arg1 = _info.__Instance;
                __Internal.GetUniformInfo(*(global::Bgfx.Bgfx.UniformHandle.__Internal*) __arg0, __arg1);
            }

            /// <summary>Destroy shader uniform parameter.</summary>
            /// <param name="_handle">Handle to uniform object.</param>
            /// <remarks>C99's equivalent binding is `bgfx_destroy_uniform`.</remarks>
            public static void Destroy(global::Bgfx.Bgfx.UniformHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.Destroy_10(*(global::Bgfx.Bgfx.UniformHandle.__Internal*) __arg0);
            }

            /// <summary>Create occlusion query.</summary>
            /// <remarks>
            /// <para>Handle to occlusion query object.</para>
            /// <para>C99's equivalent binding is `bgfx_create_occlusion_query`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.OcclusionQueryHandle CreateOcclusionQuery()
            {
                var __ret = __Internal.CreateOcclusionQuery();
                return global::Bgfx.Bgfx.OcclusionQueryHandle.__CreateInstance(__ret);
            }

            /// <summary>Retrieve occlusion query result from previous frame.</summary>
            /// <param name="_handle">Handle to occlusion query object.</param>
            /// <param name="_result">
            /// <para>Number of pixels that passed test. This argument</para>
            /// <para>can be `NULL` if result of occlusion query is not needed.</para>
            /// </param>
            /// <remarks>
            /// <para>Occlusion query result.</para>
            /// <para>C99's equivalent binding is `bgfx_get_result`.</para>
            /// </remarks>
            public static global::Bgfx.Bgfx.OcclusionQueryResult.Enum GetResult(global::Bgfx.Bgfx.OcclusionQueryHandle _handle, ref int _result)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                fixed (int* ___result1 = &_result)
                {
                    var __arg1 = ___result1;
                    var __ret = __Internal.GetResult(*(global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal*) __arg0, __arg1);
                    return __ret;
                }
            }

            /// <summary>Destroy occlusion query.</summary>
            /// <param name="_handle">Handle to occlusion query object.</param>
            /// <remarks>C99's equivalent binding is `bgfx_destroy_occlusion_query`.</remarks>
            public static void Destroy(global::Bgfx.Bgfx.OcclusionQueryHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.Destroy_11(*(global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal*) __arg0);
            }

            /// <summary>Set palette color value.</summary>
            /// <param name="_index">Index into palette.</param>
            /// <param name="_rgba">Packed 32-bit RGBA value.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_palette_color`.</remarks>
            public static void SetPaletteColor(byte _index, uint _rgba)
            {
                __Internal.SetPaletteColor(_index, _rgba);
            }

            /// <summary>Set palette color value.</summary>
            /// <param name="_index">Index into palette.</param>
            /// <param name="_r,">_g, _b, _a RGBA floating point values.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_palette_color`.</remarks>
            public static void SetPaletteColor(byte _index, float _r, float _g, float _b, float _a)
            {
                __Internal.SetPaletteColor(_index, _r, _g, _b, _a);
            }

            /// <summary>Set palette color value.</summary>
            /// <param name="_index">Index into palette.</param>
            /// <param name="_rgba">RGBA floating point value.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_palette_color`.</remarks>
            public static void SetPaletteColor(byte _index, float[] _rgba)
            {
                if (_rgba == null || _rgba.Length != 4)
                    throw new ArgumentOutOfRangeException("_rgba", "The dimensions of the provided array don't match the required size.");
                __Internal.SetPaletteColor_1(_index, _rgba);
            }

            /// <summary>Set view name.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_name">View name.</param>
            /// <remarks>
            /// <para>This is debug only feature.</para>
            /// <para>In graphics debugger view name will appear as:</para>
            /// <para>&quot;nnncename&gt;&quot;</para>
            /// <para>^  ^^ ^</para>
            /// <para>|  |+-- eye (L/R)</para>
            /// <para>|  +--- compute (C)</para>
            /// <para>+------ view id</para>
            /// <para>C99's equivalent binding is `bgfx_set_view_name`.</para>
            /// </remarks>
            public static void SetViewName(ushort _id, string _name)
            {
                __Internal.SetViewName(_id, _name);
            }

            /// <summary>Set view rectangle. Draw primitive outside view will be clipped.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_x">Position x from the left corner of the window.</param>
            /// <param name="_y">Position y from the top corner of the window.</param>
            /// <param name="_width">Width of view port region.</param>
            /// <param name="_height">Height of view port region.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_view_rect`.</remarks>
            public static void SetViewRect(ushort _id, ushort _x, ushort _y, ushort _width, ushort _height)
            {
                __Internal.SetViewRect(_id, _x, _y, _width, _height);
            }

            /// <summary>Set view rectangle. Draw primitive outside view will be clipped.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_x">Position x from the left corner of the window.</param>
            /// <param name="_y">Position y from the top corner of the window.</param>
            /// <param name="_ratio">
            /// <para>Width and height will be set in respect to back-buffer size. See:</para>
            /// <para>`BackbufferRatio::Enum`.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_view_rect_ratio`.</remarks>
            public static void SetViewRect(ushort _id, ushort _x, ushort _y, global::Bgfx.Bgfx.BackbufferRatio.Enum _ratio)
            {
                __Internal.SetViewRect(_id, _x, _y, _ratio);
            }

            /// <summary>
            /// <para>Set view scissor. Draw primitive outside view will be clipped. When</para>
            /// <para>_x, _y, _width and _height are set to 0, scissor will be disabled.</para>
            /// </summary>
            /// <param name="_id">View id.</param>
            /// <param name="_x">Position x from the left corner of the window.</param>
            /// <param name="_y">Position y from the top corner of the window.</param>
            /// <param name="_width">Width of scissor region.</param>
            /// <param name="_height">Height of scissor region.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_view_scissor`.</remarks>
            public static void SetViewScissor(ushort _id, ushort _x, ushort _y, ushort _width, ushort _height)
            {
                __Internal.SetViewScissor(_id, _x, _y, _width, _height);
            }

            /// <summary>Set view clear flags.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_flags">
            /// <para>Clear flags. Use `BGFX_CLEAR_NONE` to remove any clear</para>
            /// <para>operation. See: `BGFX_CLEAR_*`.</para>
            /// </param>
            /// <param name="_rgba">Color clear value.</param>
            /// <param name="_depth">Depth clear value.</param>
            /// <param name="_stencil">Stencil clear value.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_view_clear`.</remarks>
            public static void SetViewClear(ushort _id, ushort _flags, uint _rgba, float _depth, byte _stencil)
            {
                __Internal.SetViewClear(_id, _flags, _rgba, _depth, _stencil);
            }

            /// <summary>
            /// <para>Set view clear flags with different clear color for each</para>
            /// <para>frame buffer texture. `bgfx::setPaletteColor` must be used to set up a</para>
            /// <para>clear color palette.</para>
            /// </summary>
            /// <param name="_id">View id.</param>
            /// <param name="_flags">
            /// <para>Clear flags. Use `BGFX_CLEAR_NONE` to remove any clear</para>
            /// <para>operation. See: `BGFX_CLEAR_*`.</para>
            /// </param>
            /// <param name="_depth">Depth clear value.</param>
            /// <param name="_stencil">Stencil clear value.</param>
            /// <param name="_0">Palette index for frame buffer attachment 0.</param>
            /// <param name="_1">Palette index for frame buffer attachment 1.</param>
            /// <param name="_2">Palette index for frame buffer attachment 2.</param>
            /// <param name="_3">Palette index for frame buffer attachment 3.</param>
            /// <param name="_4">Palette index for frame buffer attachment 4.</param>
            /// <param name="_5">Palette index for frame buffer attachment 5.</param>
            /// <param name="_6">Palette index for frame buffer attachment 6.</param>
            /// <param name="_7">Palette index for frame buffer attachment 7.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_view_clear_mrt`.</remarks>
            public static void SetViewClear(ushort _id, ushort _flags, float _depth, byte _stencil, byte _0, byte _1, byte _2, byte _3, byte _4, byte _5, byte _6, byte _7)
            {
                __Internal.SetViewClear(_id, _flags, _depth, _stencil, _0, _1, _2, _3, _4, _5, _6, _7);
            }

            /// <summary>Set view sorting mode.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_mode">View sort mode. See `ViewMode::Enum`.</param>
            /// <remarks>
            /// <para>View mode must be set prior calling `bgfx::submit` for the view.</para>
            /// <para>C99's equivalent binding is `bgfx_set_view_mode`.</para>
            /// </remarks>
            public static void SetViewMode(ushort _id, global::Bgfx.Bgfx.ViewMode.Enum _mode)
            {
                __Internal.SetViewMode(_id, _mode);
            }

            /// <summary>Set view frame buffer.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_handle">
            /// <para>Frame buffer handle. Passing `BGFX_INVALID_HANDLE` as</para>
            /// <para>frame buffer handle will draw primitives from this view into</para>
            /// <para>default back buffer.</para>
            /// </param>
            /// <remarks>
            /// <para>Not persistent after `bgfx::reset` call.</para>
            /// <para>C99's equivalent binding is `bgfx_set_view_frame_buffer`.</para>
            /// </remarks>
            public static void SetViewFrameBuffer(ushort _id, global::Bgfx.Bgfx.FrameBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetViewFrameBuffer(_id, *(global::Bgfx.Bgfx.FrameBufferHandle.__Internal*) __arg1);
            }

            /// <summary>
            /// <para>Set view's view matrix and projection matrix,</para>
            /// <para>all draw primitives in this view will use these two matrices.</para>
            /// </summary>
            /// <param name="_id">View id.</param>
            /// <param name="_view">View matrix.</param>
            /// <param name="_proj">Projection matrix.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_view_transform`.</remarks>
            public static void SetViewTransform(ushort _id, __IntPtr _view, __IntPtr _proj)
            {
                __Internal.SetViewTransform(_id, _view, _proj);
            }

            /// <summary>Post submit view reordering.</summary>
            /// <param name="_id">First view id.</param>
            /// <param name="_num">Number of views to remap.</param>
            /// <param name="_remap">
            /// <para>View remap id table. Passing `NULL` will reset view ids</para>
            /// <para>to default state.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_view_order`.</remarks>
            public static void SetViewOrder(ushort _id, ushort _num, ref ushort _remap)
            {
                fixed (ushort* ___remap2 = &_remap)
                {
                    var __arg2 = ___remap2;
                    __Internal.SetViewOrder(_id, _num, __arg2);
                }
            }

            /// <summary>Reset all view settings to default.</summary>
            /// <param name="_id">View id.</param>
            /// <remarks>C99's equivalent binding is `bgfx_reset_view`.</remarks>
            public static void ResetView(ushort _id)
            {
                __Internal.ResetView(_id);
            }

            /// <summary>Sets debug marker.</summary>
            /// <remarks>C99's equivalent binding is `bgfx_set_marker`.</remarks>
            public static void SetMarker(string _marker)
            {
                __Internal.SetMarker(_marker);
            }

            /// <summary>Set render states for draw primitive.</summary>
            /// <param name="_state">
            /// <para>State flags. Default state for primitive type is</para>
            /// <para>triangles. See: `BGFX_STATE_DEFAULT`.</para>
            /// <para>- `BGFX_STATE_DEPTH_TEST_*` - Depth test function.</para>
            /// <para>- `BGFX_STATE_BLEND_*` - See remark 1 about BGFX_STATE_BLEND_FUNC.</para>
            /// <para>- `BGFX_STATE_BLEND_EQUATION_*` - See remark 2.</para>
            /// <para>- `BGFX_STATE_CULL_*` - Backface culling mode.</para>
            /// <para>- `BGFX_STATE_WRITE_*` - Enable R, G, B, A or Z write.</para>
            /// <para>- `BGFX_STATE_MSAA` - Enable MSAA.</para>
            /// <para>- `BGFX_STATE_PT_[TRISTRIP/LINES/POINTS]` - Primitive type.</para>
            /// </param>
            /// <param name="_rgba">
            /// <para>Sets blend factor used by `BGFX_STATE_BLEND_FACTOR` and</para>
            /// <para>`BGFX_STATE_BLEND_INV_FACTOR` blend modes.</para>
            /// </param>
            /// <remarks>
            /// <para>1. To set up more complex states use:</para>
            /// <para>`BGFX_STATE_ALPHA_REF(_ref)`,</para>
            /// <para>`BGFX_STATE_POINT_SIZE(_size)`,</para>
            /// <para>`BGFX_STATE_BLEND_FUNC(_src, _dst)`,</para>
            /// <para>`BGFX_STATE_BLEND_FUNC_SEPARATE(_srcRGB, _dstRGB, _srcA, _dstA)`</para>
            /// <para>`BGFX_STATE_BLEND_EQUATION(_equation)`</para>
            /// <para>`BGFX_STATE_BLEND_EQUATION_SEPARATE(_equationRGB, _equationA)`</para>
            /// <para>2. `BGFX_STATE_BLEND_EQUATION_ADD` is set when no other blend</para>
            /// <para>equation is specified.</para>
            /// <para>C99's equivalent binding is `bgfx_set_state`.</para>
            /// </remarks>
            public static void SetState(ulong _state, uint _rgba)
            {
                __Internal.SetState(_state, _rgba);
            }

            /// <summary>Set condition for rendering.</summary>
            /// <param name="_handle">Occlusion query handle.</param>
            /// <param name="_visible">Render if occlusion query is visible.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_condition`.</remarks>
            public static void SetCondition(global::Bgfx.Bgfx.OcclusionQueryHandle _handle, bool _visible)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetCondition(*(global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal*) __arg0, _visible);
            }

            /// <summary>Set stencil test state.</summary>
            /// <param name="_fstencil">Front stencil state.</param>
            /// <param name="_bstencil">
            /// <para>Back stencil state. If back is set to `BGFX_STENCIL_NONE`</para>
            /// <para>_fstencil is applied to both front and back facing primitives.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_stencil`.</remarks>
            public static void SetStencil(uint _fstencil, uint _bstencil)
            {
                __Internal.SetStencil(_fstencil, _bstencil);
            }

            /// <summary>
            /// <para>Set scissor for draw primitive. For scissor for all primitives in</para>
            /// <para>view see `bgfx::setViewScissor`.</para>
            /// </summary>
            /// <param name="_x">Position x from the left corner of the window.</param>
            /// <param name="_y">Position y from the top corner of the window.</param>
            /// <param name="_width">Width of scissor region.</param>
            /// <param name="_height">Height of scissor region.</param>
            /// <remarks>
            /// <para>Scissor cache index.</para>
            /// <para>C99's equivalent binding is `bgfx_set_scissor`.</para>
            /// </remarks>
            public static ushort SetScissor(ushort _x, ushort _y, ushort _width, ushort _height)
            {
                var __ret = __Internal.SetScissor(_x, _y, _width, _height);
                return __ret;
            }

            /// <summary>Set scissor from cache for draw primitive.</summary>
            /// <param name="_cache">
            /// <para>Index in scissor cache. Passing UINT16_MAX unset primitive</para>
            /// <para>scissor and primitive will use view scissor instead.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_scissor_cached`.</remarks>
            public static void SetScissor(ushort _cache)
            {
                __Internal.SetScissor(_cache);
            }

            /// <summary>
            /// <para>Set model matrix for draw primitive. If it is not called,</para>
            /// <para>the model will be rendered with an identity model matrix.</para>
            /// </summary>
            /// <param name="_mtx">Pointer to first matrix in array.</param>
            /// <param name="_num">Number of matrices in array.</param>
            /// <remarks>
            /// <para>index into matrix cache in case the same model matrix has</para>
            /// <para>to be used for other draw primitive call.</para>
            /// <para>C99's equivalent binding is `bgfx_set_transform`.</para>
            /// </remarks>
            public static uint SetTransform(__IntPtr _mtx, ushort _num)
            {
                var __ret = __Internal.SetTransform(_mtx, _num);
                return __ret;
            }

            /// <summary>Reserve `_num` matrices in internal matrix cache.</summary>
            /// <param name="_transform">Pointer to `Transform` structure.</param>
            /// <param name="_num">Number of matrices.</param>
            /// <remarks>
            /// <para>index into matrix cache.</para>
            /// <para>Pointer returned can be modified until `bgfx::frame` is called.</para>
            /// <para>C99's equivalent binding is `bgfx_alloc_transform`.</para>
            /// </remarks>
            public static uint AllocTransform(global::Bgfx.Bgfx.Transform _transform, ushort _num)
            {
                var __arg0 = _transform is null ? __IntPtr.Zero : _transform.__Instance;
                var __ret = __Internal.AllocTransform(__arg0, _num);
                return __ret;
            }

            /// <summary>Set model matrix from matrix cache for draw primitive.</summary>
            /// <param name="_cache">Index in matrix cache.</param>
            /// <param name="_num">Number of matrices from cache.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_transform_cached`.</remarks>
            public static void SetTransform(uint _cache, ushort _num)
            {
                __Internal.SetTransform(_cache, _num);
            }

            /// <summary>Set shader uniform parameter for draw primitive.</summary>
            /// <param name="_handle">Uniform.</param>
            /// <param name="_value">Pointer to uniform data.</param>
            /// <param name="_num">
            /// <para>Number of elements. Passing `UINT16_MAX` will</para>
            /// <para>use the _num passed on uniform creation.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_uniform`.</remarks>
            public static void SetUniform(global::Bgfx.Bgfx.UniformHandle _handle, __IntPtr _value, ushort _num)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetUniform(*(global::Bgfx.Bgfx.UniformHandle.__Internal*) __arg0, _value, _num);
            }

            /// <summary>Set index buffer for draw primitive.</summary>
            /// <param name="_handle">Index buffer.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_index_buffer`.</remarks>
            public static void SetIndexBuffer(global::Bgfx.Bgfx.IndexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetIndexBuffer(*(global::Bgfx.Bgfx.IndexBufferHandle.__Internal*) __arg0);
            }

            /// <summary>Set index buffer for draw primitive.</summary>
            /// <param name="_handle">Index buffer.</param>
            /// <param name="_firstIndex">First index to render.</param>
            /// <param name="_numIndices">Number of indices to render.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_index_buffer`.</remarks>
            public static void SetIndexBuffer(global::Bgfx.Bgfx.IndexBufferHandle _handle, uint _firstIndex, uint _numIndices)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetIndexBuffer(*(global::Bgfx.Bgfx.IndexBufferHandle.__Internal*) __arg0, _firstIndex, _numIndices);
            }

            /// <summary>Set index buffer for draw primitive.</summary>
            /// <param name="_handle">Dynamic index buffer.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_dynamic_index_buffer`.</remarks>
            public static void SetIndexBuffer(global::Bgfx.Bgfx.DynamicIndexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetIndexBuffer_1(*(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal*) __arg0);
            }

            /// <summary>Set index buffer for draw primitive.</summary>
            /// <param name="_handle">Dynamic index buffer.</param>
            /// <param name="_firstIndex">First index to render.</param>
            /// <param name="_numIndices">Number of indices to render.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_dynamic_index_buffer`.</remarks>
            public static void SetIndexBuffer(global::Bgfx.Bgfx.DynamicIndexBufferHandle _handle, uint _firstIndex, uint _numIndices)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetIndexBuffer_1(*(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal*) __arg0, _firstIndex, _numIndices);
            }

            /// <summary>Set index buffer for draw primitive.</summary>
            /// <param name="_tib">Transient index buffer.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_transient_index_buffer`.</remarks>
            public static void SetIndexBuffer(global::Bgfx.Bgfx.TransientIndexBuffer _tib)
            {
                var __arg0 = _tib is null ? __IntPtr.Zero : _tib.__Instance;
                __Internal.SetIndexBuffer(__arg0);
            }

            /// <summary>Set index buffer for draw primitive.</summary>
            /// <param name="_tib">Transient index buffer.</param>
            /// <param name="_firstIndex">First index to render.</param>
            /// <param name="_numIndices">Number of indices to render.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_transient_index_buffer`.</remarks>
            public static void SetIndexBuffer(global::Bgfx.Bgfx.TransientIndexBuffer _tib, uint _firstIndex, uint _numIndices)
            {
                var __arg0 = _tib is null ? __IntPtr.Zero : _tib.__Instance;
                __Internal.SetIndexBuffer(__arg0, _firstIndex, _numIndices);
            }

            /// <summary>Set vertex buffer for draw primitive.</summary>
            /// <param name="_stream">Vertex stream.</param>
            /// <param name="_handle">Vertex buffer.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_vertex_buffer`.</remarks>
            public static void SetVertexBuffer(byte _stream, global::Bgfx.Bgfx.VertexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetVertexBuffer(_stream, *(global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) __arg1);
            }

            /// <summary>Set vertex buffer for draw primitive.</summary>
            /// <param name="_stream">Vertex stream.</param>
            /// <param name="_handle">Vertex buffer.</param>
            /// <param name="_startVertex">First vertex to render.</param>
            /// <param name="_numVertices">Number of vertices to render.</param>
            /// <param name="_layoutHandle">
            /// <para>Vertex layout for aliasing vertex buffer. If invalid handle is</para>
            /// <para>used, vertex layout used for creation of vertex buffer will be used.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_vertex_buffer`.</remarks>
            public static void SetVertexBuffer(byte _stream, global::Bgfx.Bgfx.VertexBufferHandle _handle, uint _startVertex, uint _numVertices, global::Bgfx.Bgfx.VertexLayoutHandle _layoutHandle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                if (ReferenceEquals(_layoutHandle, null))
                    throw new global::System.ArgumentNullException("_layoutHandle", "Cannot be null because it is passed by value.");
                var __arg4 = _layoutHandle.__Instance;
                __Internal.SetVertexBuffer(_stream, *(global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) __arg1, _startVertex, _numVertices, *(global::Bgfx.Bgfx.VertexLayoutHandle.__Internal*) __arg4);
            }

            /// <summary>Set vertex buffer for draw primitive.</summary>
            /// <param name="_stream">Vertex stream.</param>
            /// <param name="_handle">Dynamic vertex buffer.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_dynamic_vertex_buffer`.</remarks>
            public static void SetVertexBuffer(byte _stream, global::Bgfx.Bgfx.DynamicVertexBufferHandle _handle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetVertexBuffer_1(_stream, *(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal*) __arg1);
            }

            /// <summary>Set vertex buffer for draw primitive.</summary>
            /// <param name="_stream">Vertex stream.</param>
            /// <param name="_handle">Dynamic vertex buffer.</param>
            /// <param name="_startVertex">First vertex to render.</param>
            /// <param name="_numVertices">Number of vertices to render.</param>
            /// <param name="_layoutHandle">
            /// <para>Vertex layout for aliasing vertex buffer. If invalid handle is</para>
            /// <para>used, vertex layout used for creation of vertex buffer will be used.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_dynamic_vertex_buffer`.</remarks>
            public static void SetVertexBuffer(byte _stream, global::Bgfx.Bgfx.DynamicVertexBufferHandle _handle, uint _startVertex, uint _numVertices, global::Bgfx.Bgfx.VertexLayoutHandle _layoutHandle)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                if (ReferenceEquals(_layoutHandle, null))
                    throw new global::System.ArgumentNullException("_layoutHandle", "Cannot be null because it is passed by value.");
                var __arg4 = _layoutHandle.__Instance;
                __Internal.SetVertexBuffer_1(_stream, *(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal*) __arg1, _startVertex, _numVertices, *(global::Bgfx.Bgfx.VertexLayoutHandle.__Internal*) __arg4);
            }

            /// <summary>Set vertex buffer for draw primitive.</summary>
            /// <param name="_stream">Vertex stream.</param>
            /// <param name="_tvb">Transient vertex buffer.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_transient_vertex_buffer`.</remarks>
            public static void SetVertexBuffer(byte _stream, global::Bgfx.Bgfx.TransientVertexBuffer _tvb)
            {
                var __arg1 = _tvb is null ? __IntPtr.Zero : _tvb.__Instance;
                __Internal.SetVertexBuffer(_stream, __arg1);
            }

            /// <summary>Set vertex buffer for draw primitive.</summary>
            /// <param name="_stream">Vertex stream.</param>
            /// <param name="_tvb">Transient vertex buffer.</param>
            /// <param name="_startVertex">First vertex to render.</param>
            /// <param name="_numVertices">Number of vertices to render.</param>
            /// <param name="_layoutHandle">
            /// <para>Vertex layout for aliasing vertex buffer. If invalid handle is</para>
            /// <para>used, vertex layout used for creation of vertex buffer will be used.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_transient_vertex_buffer`.</remarks>
            public static void SetVertexBuffer(byte _stream, global::Bgfx.Bgfx.TransientVertexBuffer _tvb, uint _startVertex, uint _numVertices, global::Bgfx.Bgfx.VertexLayoutHandle _layoutHandle)
            {
                var __arg1 = _tvb is null ? __IntPtr.Zero : _tvb.__Instance;
                if (ReferenceEquals(_layoutHandle, null))
                    throw new global::System.ArgumentNullException("_layoutHandle", "Cannot be null because it is passed by value.");
                var __arg4 = _layoutHandle.__Instance;
                __Internal.SetVertexBuffer(_stream, __arg1, _startVertex, _numVertices, *(global::Bgfx.Bgfx.VertexLayoutHandle.__Internal*) __arg4);
            }

            /// <summary>
            /// <para>Set number of vertices for auto generated vertices use in conjunction</para>
            /// <para>with gl_VertexID.</para>
            /// </summary>
            /// <param name="_numVertices">Number of vertices.</param>
            /// <remarks>
            /// <para>Availability depends on: `BGFX_CAPS_VERTEX_ID`.</para>
            /// <para>C99's equivalent binding is `bgfx_set_vertex_count`.</para>
            /// </remarks>
            public static void SetVertexCount(uint _numVertices)
            {
                __Internal.SetVertexCount(_numVertices);
            }

            /// <summary>Set instance data buffer for draw primitive.</summary>
            /// <param name="_idb">Transient instance data buffer.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_instance_data_buffer`.</remarks>
            public static void SetInstanceDataBuffer(global::Bgfx.Bgfx.InstanceDataBuffer _idb)
            {
                var __arg0 = _idb is null ? __IntPtr.Zero : _idb.__Instance;
                __Internal.SetInstanceDataBuffer(__arg0);
            }

            /// <summary>Set instance data buffer for draw primitive.</summary>
            /// <param name="_idb">Transient instance data buffer.</param>
            /// <param name="_start">First instance data.</param>
            /// <param name="_num">Number of data instances.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_instance_data_buffer`.</remarks>
            public static void SetInstanceDataBuffer(global::Bgfx.Bgfx.InstanceDataBuffer _idb, uint _start, uint _num)
            {
                var __arg0 = _idb is null ? __IntPtr.Zero : _idb.__Instance;
                __Internal.SetInstanceDataBuffer(__arg0, _start, _num);
            }

            /// <summary>Set instance data buffer for draw primitive.</summary>
            /// <param name="_handle">Vertex buffer.</param>
            /// <param name="_start">First instance data.</param>
            /// <param name="_num">Number of data instances.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_instance_data_from_vertex_buffer`.</remarks>
            public static void SetInstanceDataBuffer(global::Bgfx.Bgfx.VertexBufferHandle _handle, uint _start, uint _num)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetInstanceDataBuffer(*(global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) __arg0, _start, _num);
            }

            /// <summary>Set instance data buffer for draw primitive.</summary>
            /// <param name="_handle">Vertex buffer.</param>
            /// <param name="_start">First instance data.</param>
            /// <param name="_num">Number of data instances.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_instance_data_from_dynamic_vertex_buffer`.</remarks>
            public static void SetInstanceDataBuffer(global::Bgfx.Bgfx.DynamicVertexBufferHandle _handle, uint _start, uint _num)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.SetInstanceDataBuffer_1(*(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal*) __arg0, _start, _num);
            }

            /// <summary>
            /// <para>Set number of instances for auto generated instances use in conjunction</para>
            /// <para>with gl_InstanceID.</para>
            /// </summary>
            /// <param name="_numInstances">Number of instances.</param>
            /// <remarks>
            /// <para>Availability depends on: `BGFX_CAPS_VERTEX_ID`.</para>
            /// <para>C99's equivalent binding is `bgfx_set_instance_count`.</para>
            /// </remarks>
            public static void SetInstanceCount(uint _numInstances)
            {
                __Internal.SetInstanceCount(_numInstances);
            }

            /// <summary>Set texture stage for draw primitive.</summary>
            /// <param name="_stage">Texture unit.</param>
            /// <param name="_sampler">Program sampler.</param>
            /// <param name="_handle">Texture handle.</param>
            /// <param name="_flags">
            /// <para>Texture sampling mode. Default value UINT32_MAX uses</para>
            /// <para>texture sampling settings from the texture.</para>
            /// <para>- `BGFX_SAMPLER_[U/V/W]_[MIRROR/CLAMP]` - Mirror or clamp to edge wrap</para>
            /// <para>mode.</para>
            /// <para>- `BGFX_SAMPLER_[MIN/MAG/MIP]_[POINT/ANISOTROPIC]` - Point or anisotropic</para>
            /// <para>sampling.</para>
            /// </param>
            /// <remarks>C99's equivalent binding is `bgfx_set_texture`.</remarks>
            public static void SetTexture(byte _stage, global::Bgfx.Bgfx.UniformHandle _sampler, global::Bgfx.Bgfx.TextureHandle _handle, uint _flags)
            {
                if (ReferenceEquals(_sampler, null))
                    throw new global::System.ArgumentNullException("_sampler", "Cannot be null because it is passed by value.");
                var __arg1 = _sampler.__Instance;
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg2 = _handle.__Instance;
                __Internal.SetTexture(_stage, *(global::Bgfx.Bgfx.UniformHandle.__Internal*) __arg1, *(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg2, _flags);
            }

            /// <summary>
            /// <para>Submit an empty primitive for rendering. Uniforms and draw state</para>
            /// <para>will be applied but no geometry will be submitted.</para>
            /// </summary>
            /// <param name="_id">View id.</param>
            /// <remarks>
            /// <para>These empty draw calls will sort before ordinary draw calls.</para>
            /// <para>C99's equivalent binding is `bgfx_touch`.</para>
            /// </remarks>
            public static void Touch(ushort _id)
            {
                __Internal.Touch(_id);
            }

            /// <summary>Submit primitive for rendering.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_program">Program.</param>
            /// <param name="_depth">Depth for sorting.</param>
            /// <param name="_flags">Discard or preserve states. See `BGFX_DISCARD_*`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_submit`.</remarks>
            public static void Submit(ushort _id, global::Bgfx.Bgfx.ProgramHandle _program, uint _depth, byte _flags)
            {
                if (ReferenceEquals(_program, null))
                    throw new global::System.ArgumentNullException("_program", "Cannot be null because it is passed by value.");
                var __arg1 = _program.__Instance;
                __Internal.Submit(_id, *(global::Bgfx.Bgfx.ProgramHandle.__Internal*) __arg1, _depth, _flags);
            }

            /// <summary>Submit primitive with occlusion query for rendering.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_program">Program.</param>
            /// <param name="_occlusionQuery">Occlusion query.</param>
            /// <param name="_depth">Depth for sorting.</param>
            /// <param name="_flags">Discard or preserve states. See `BGFX_DISCARD_*`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_submit_occlusion_query`.</remarks>
            public static void Submit(ushort _id, global::Bgfx.Bgfx.ProgramHandle _program, global::Bgfx.Bgfx.OcclusionQueryHandle _occlusionQuery, uint _depth, byte _flags)
            {
                if (ReferenceEquals(_program, null))
                    throw new global::System.ArgumentNullException("_program", "Cannot be null because it is passed by value.");
                var __arg1 = _program.__Instance;
                if (ReferenceEquals(_occlusionQuery, null))
                    throw new global::System.ArgumentNullException("_occlusionQuery", "Cannot be null because it is passed by value.");
                var __arg2 = _occlusionQuery.__Instance;
                __Internal.Submit(_id, *(global::Bgfx.Bgfx.ProgramHandle.__Internal*) __arg1, *(global::Bgfx.Bgfx.OcclusionQueryHandle.__Internal*) __arg2, _depth, _flags);
            }

            /// <summary>
            /// <para>Submit primitive for rendering with index and instance data info from</para>
            /// <para>indirect buffer.</para>
            /// </summary>
            /// <param name="_id">View id.</param>
            /// <param name="_program">Program.</param>
            /// <param name="_indirectHandle">Indirect buffer.</param>
            /// <param name="_start">First element in indirect buffer.</param>
            /// <param name="_num">Number of dispatches.</param>
            /// <param name="_depth">Depth for sorting.</param>
            /// <param name="_flags">Discard or preserve states. See `BGFX_DISCARD_*`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_submit_indirect`.</remarks>
            public static void Submit(ushort _id, global::Bgfx.Bgfx.ProgramHandle _program, global::Bgfx.Bgfx.IndirectBufferHandle _indirectHandle, ushort _start, ushort _num, uint _depth, byte _flags)
            {
                if (ReferenceEquals(_program, null))
                    throw new global::System.ArgumentNullException("_program", "Cannot be null because it is passed by value.");
                var __arg1 = _program.__Instance;
                if (ReferenceEquals(_indirectHandle, null))
                    throw new global::System.ArgumentNullException("_indirectHandle", "Cannot be null because it is passed by value.");
                var __arg2 = _indirectHandle.__Instance;
                __Internal.Submit(_id, *(global::Bgfx.Bgfx.ProgramHandle.__Internal*) __arg1, *(global::Bgfx.Bgfx.IndirectBufferHandle.__Internal*) __arg2, _start, _num, _depth, _flags);
            }

            /// <summary>Set compute index buffer.</summary>
            /// <param name="_stage">Compute stage.</param>
            /// <param name="_handle">Index buffer handle.</param>
            /// <param name="_access">Buffer access. See `Access::Enum`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_compute_index_buffer`.</remarks>
            public static void SetBuffer(byte _stage, global::Bgfx.Bgfx.IndexBufferHandle _handle, global::Bgfx.Bgfx.Access.Enum _access)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetBuffer(_stage, *(global::Bgfx.Bgfx.IndexBufferHandle.__Internal*) __arg1, _access);
            }

            /// <summary>Set compute vertex buffer.</summary>
            /// <param name="_stage">Compute stage.</param>
            /// <param name="_handle">Vertex buffer handle.</param>
            /// <param name="_access">Buffer access. See `Access::Enum`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_compute_vertex_buffer`.</remarks>
            public static void SetBuffer(byte _stage, global::Bgfx.Bgfx.VertexBufferHandle _handle, global::Bgfx.Bgfx.Access.Enum _access)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetBuffer_1(_stage, *(global::Bgfx.Bgfx.VertexBufferHandle.__Internal*) __arg1, _access);
            }

            /// <summary>Set compute dynamic index buffer.</summary>
            /// <param name="_stage">Compute stage.</param>
            /// <param name="_handle">Dynamic index buffer handle.</param>
            /// <param name="_access">Buffer access. See `Access::Enum`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_compute_dynamic_index_buffer`.</remarks>
            public static void SetBuffer(byte _stage, global::Bgfx.Bgfx.DynamicIndexBufferHandle _handle, global::Bgfx.Bgfx.Access.Enum _access)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetBuffer_2(_stage, *(global::Bgfx.Bgfx.DynamicIndexBufferHandle.__Internal*) __arg1, _access);
            }

            /// <summary>Set compute dynamic vertex buffer.</summary>
            /// <param name="_stage">Compute stage.</param>
            /// <param name="_handle">Dynamic vertex buffer handle.</param>
            /// <param name="_access">Buffer access. See `Access::Enum`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_compute_dynamic_vertex_buffer`.</remarks>
            public static void SetBuffer(byte _stage, global::Bgfx.Bgfx.DynamicVertexBufferHandle _handle, global::Bgfx.Bgfx.Access.Enum _access)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetBuffer_3(_stage, *(global::Bgfx.Bgfx.DynamicVertexBufferHandle.__Internal*) __arg1, _access);
            }

            /// <summary>Set compute indirect buffer.</summary>
            /// <param name="_stage">Compute stage.</param>
            /// <param name="_handle">Indirect buffer handle.</param>
            /// <param name="_access">Buffer access. See `Access::Enum`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_compute_indirect_buffer`.</remarks>
            public static void SetBuffer(byte _stage, global::Bgfx.Bgfx.IndirectBufferHandle _handle, global::Bgfx.Bgfx.Access.Enum _access)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetBuffer_4(_stage, *(global::Bgfx.Bgfx.IndirectBufferHandle.__Internal*) __arg1, _access);
            }

            /// <summary>Set compute image from texture.</summary>
            /// <param name="_stage">Texture unit.</param>
            /// <param name="_handle">Texture handle.</param>
            /// <param name="_mip">Mip level.</param>
            /// <param name="_access">Texture access. See `Access::Enum`.</param>
            /// <param name="_format">Texture format. See: `TextureFormat::Enum`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_set_image`.</remarks>
            public static void SetImage(byte _stage, global::Bgfx.Bgfx.TextureHandle _handle, byte _mip, global::Bgfx.Bgfx.Access.Enum _access, global::Bgfx.Bgfx.TextureFormat.Enum _format)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.SetImage(_stage, *(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg1, _mip, _access, _format);
            }

            /// <summary>Dispatch compute.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_handle">Compute program.</param>
            /// <param name="_numX">Number of groups X.</param>
            /// <param name="_numY">Number of groups Y.</param>
            /// <param name="_numZ">Number of groups Z.</param>
            /// <param name="_flags">Discard or preserve states. See `BGFX_DISCARD_*`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_dispatch`.</remarks>
            public static void Dispatch(ushort _id, global::Bgfx.Bgfx.ProgramHandle _handle, uint _numX, uint _numY, uint _numZ, byte _flags)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                __Internal.Dispatch(_id, *(global::Bgfx.Bgfx.ProgramHandle.__Internal*) __arg1, _numX, _numY, _numZ, _flags);
            }

            /// <summary>Dispatch compute indirect.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_handle">Compute program.</param>
            /// <param name="_indirectHandle">Indirect buffer.</param>
            /// <param name="_start">First element in indirect buffer.</param>
            /// <param name="_num">Number of dispatches.</param>
            /// <param name="_flags">Discard or preserve states. See `BGFX_DISCARD_*`.</param>
            /// <remarks>C99's equivalent binding is `bgfx_dispatch_indirect`.</remarks>
            public static void Dispatch(ushort _id, global::Bgfx.Bgfx.ProgramHandle _handle, global::Bgfx.Bgfx.IndirectBufferHandle _indirectHandle, ushort _start, ushort _num, byte _flags)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg1 = _handle.__Instance;
                if (ReferenceEquals(_indirectHandle, null))
                    throw new global::System.ArgumentNullException("_indirectHandle", "Cannot be null because it is passed by value.");
                var __arg2 = _indirectHandle.__Instance;
                __Internal.Dispatch_1(_id, *(global::Bgfx.Bgfx.ProgramHandle.__Internal*) __arg1, *(global::Bgfx.Bgfx.IndirectBufferHandle.__Internal*) __arg2, _start, _num, _flags);
            }

            /// <summary>Discard all previously set state for draw or compute call.</summary>
            /// <param name="_flags">Draw/compute states to discard.</param>
            /// <remarks>C99's equivalent binding is `bgfx_discard`.</remarks>
            public static void Discard(byte _flags)
            {
                __Internal.Discard(_flags);
            }

            /// <summary>Blit 2D texture region between two 2D textures.</summary>
            /// <param name="_id">View id.</param>
            /// <param name="_dst">Destination texture handle.</param>
            /// <param name="_dstX">Destination texture X position.</param>
            /// <param name="_dstY">Destination texture Y position.</param>
            /// <param name="_src">Source texture handle.</param>
            /// <param name="_srcX">Source texture X position.</param>
            /// <param name="_srcY">Source texture Y position.</param>
            /// <param name="_width">Width of region.</param>
            /// <param name="_height">Height of region.</param>
            /// <remarks>
            /// <para>Destination texture must be created with `BGFX_TEXTURE_BLIT_DST` flag.</para>
            /// <para>Availability depends on: `BGFX_CAPS_TEXTURE_BLIT`.</para>
            /// <para>C99's equivalent binding is `bgfx_blit`.</para>
            /// </remarks>
            public static void Blit(ushort _id, global::Bgfx.Bgfx.TextureHandle _dst, ushort _dstX, ushort _dstY, global::Bgfx.Bgfx.TextureHandle _src, ushort _srcX, ushort _srcY, ushort _width, ushort _height)
            {
                if (ReferenceEquals(_dst, null))
                    throw new global::System.ArgumentNullException("_dst", "Cannot be null because it is passed by value.");
                var __arg1 = _dst.__Instance;
                if (ReferenceEquals(_src, null))
                    throw new global::System.ArgumentNullException("_src", "Cannot be null because it is passed by value.");
                var __arg4 = _src.__Instance;
                __Internal.Blit(_id, *(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg1, _dstX, _dstY, *(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg4, _srcX, _srcY, _width, _height);
            }

            /// <summary>Blit texture region between two textures.</summary>
            /// <param name="_depth">
            /// <para>If texture is 3D this argument represents depth of region, otherwise it's</para>
            /// <para>unused.</para>
            /// </param>
            /// <param name="_height">Height of region.</param>
            /// <param name="_width">Width of region.</param>
            /// <param name="_srcZ">
            /// <para>If texture is 2D this argument should be 0. If source texture is cube</para>
            /// <para>this argument represents source texture cube face. For 3D texture this argument</para>
            /// <para>represents source texture Z position.</para>
            /// </param>
            /// <param name="_srcY">Source texture Y position.</param>
            /// <param name="_srcX">Source texture X position.</param>
            /// <param name="_src">Source texture handle.</param>
            /// <param name="_srcMip">Source texture mip level.</param>
            /// <param name="_dstY">Destination texture Y position.</param>
            /// <param name="_dstX">Destination texture X position.</param>
            /// <param name="_dstMip">Destination texture mip level.</param>
            /// <param name="_dst">Destination texture handle.</param>
            /// <param name="_id">View id.</param>
            /// <param name="_dstZ">
            /// <para>If texture is 2D this argument should be 0. If destination texture is cube</para>
            /// <para>this argument represents destination texture cube face. For 3D texture this argument</para>
            /// <para>represents destination texture Z position.</para>
            /// </param>
            /// <remarks>
            /// <para>Availability depends on: `BGFX_CAPS_TEXTURE_BLIT`.</para>
            /// <para>Destination texture must be created with `BGFX_TEXTURE_BLIT_DST` flag.</para>
            /// <para>C99's equivalent binding is `bgfx_blit`.</para>
            /// </remarks>
            public static void Blit(ushort _id, global::Bgfx.Bgfx.TextureHandle _dst, byte _dstMip, ushort _dstX, ushort _dstY, ushort _dstZ, global::Bgfx.Bgfx.TextureHandle _src, byte _srcMip, ushort _srcX, ushort _srcY, ushort _srcZ, ushort _width, ushort _height, ushort _depth)
            {
                if (ReferenceEquals(_dst, null))
                    throw new global::System.ArgumentNullException("_dst", "Cannot be null because it is passed by value.");
                var __arg1 = _dst.__Instance;
                if (ReferenceEquals(_src, null))
                    throw new global::System.ArgumentNullException("_src", "Cannot be null because it is passed by value.");
                var __arg6 = _src.__Instance;
                __Internal.Blit(_id, *(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg1, _dstMip, _dstX, _dstY, _dstZ, *(global::Bgfx.Bgfx.TextureHandle.__Internal*) __arg6, _srcMip, _srcX, _srcY, _srcZ, _width, _height, _depth);
            }

            /// <summary>Request screen shot of window back buffer.</summary>
            /// <param name="_handle">
            /// <para>Frame buffer handle. If handle is `BGFX_INVALID_HANDLE` request will be</para>
            /// <para>made for main window back buffer.</para>
            /// </param>
            /// <param name="_filePath">Will be passed to `bgfx::CallbackI::screenShot` callback.</param>
            /// <remarks>
            /// <para>`bgfx::CallbackI::screenShot` must be implemented.</para>
            /// <para>Frame buffer handle must be created with OS' target native window handle.</para>
            /// <para>C99's equivalent binding is `bgfx_request_screen_shot`.</para>
            /// </remarks>
            public static void RequestScreenShot(global::Bgfx.Bgfx.FrameBufferHandle _handle, string _filePath)
            {
                if (ReferenceEquals(_handle, null))
                    throw new global::System.ArgumentNullException("_handle", "Cannot be null because it is passed by value.");
                var __arg0 = _handle.__Instance;
                __Internal.RequestScreenShot(*(global::Bgfx.Bgfx.FrameBufferHandle.__Internal*) __arg0, _filePath);
            }

            public static ushort KInvalidHandle { get; } = 65535;
        }
    }

    namespace Bgfx
    {
        public unsafe partial class EmbeddedShader : IDisposable
        {
            [StructLayout(LayoutKind.Sequential, Size = 296)]
            public partial struct __Internal
            {
                internal __IntPtr name;
                internal fixed byte data[288];

                [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx14EmbeddedShaderC2ERKS0_", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
            }

            public unsafe partial class Data : IDisposable
            {
                [StructLayout(LayoutKind.Sequential, Size = 24)]
                public partial struct __Internal
                {
                    internal global::Bgfx.Bgfx.RendererType.Enum type;
                    internal __IntPtr data;
                    internal uint size;

                    [SuppressUnmanagedCodeSecurity, DllImport("Bgfx", EntryPoint = "_ZN4bgfx14EmbeddedShader4DataC2ERKS1_", CallingConvention = __CallingConvention.Cdecl)]
                    internal static extern void cctor(__IntPtr __instance, __IntPtr _0);
                }

                public __IntPtr __Instance { get; protected set; }

                internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.EmbeddedShader.Data> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.EmbeddedShader.Data>();

                protected bool __ownsNativeInstance;

                internal static Data __CreateInstance(__IntPtr native, bool skipVTables = false)
                {
                    return new Data(native.ToPointer(), skipVTables);
                }

                internal static Data __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
                {
                    if (native == __IntPtr.Zero)
                        return null;
                    if (NativeToManagedMap.TryGetValue(native, out var managed))
                        return (Data)managed;
                    var result = __CreateInstance(native, skipVTables);
                    if (saveInstance)
                        NativeToManagedMap[native] = result;
                    return result;
                }

                internal static Data __CreateInstance(__Internal native, bool skipVTables = false)
                {
                    return new Data(native, skipVTables);
                }

                private static void* __CopyValue(__Internal native)
                {
                    var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                    *(__Internal*) ret = native;
                    return ret.ToPointer();
                }

                private Data(__Internal native, bool skipVTables = false)
                    : this(__CopyValue(native), skipVTables)
                {
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                protected Data(void* native, bool skipVTables = false)
                {
                    if (native == null)
                        return;
                    __Instance = new __IntPtr(native);
                }

                public Data()
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.EmbeddedShader.Data.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                }

                public Data(global::Bgfx.Bgfx.EmbeddedShader.Data _0)
                {
                    __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.EmbeddedShader.Data.__Internal));
                    __ownsNativeInstance = true;
                    NativeToManagedMap[__Instance] = this;
                    *((global::Bgfx.Bgfx.EmbeddedShader.Data.__Internal*) __Instance) = *((global::Bgfx.Bgfx.EmbeddedShader.Data.__Internal*) _0.__Instance);
                }

                public void Dispose()
                {
                    Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
                }

                partial void DisposePartial(bool disposing);

                internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
                {
                    if (__Instance == IntPtr.Zero)
                        return;
                    NativeToManagedMap.TryRemove(__Instance, out _);
                    DisposePartial(disposing);
                    if (__ownsNativeInstance)
                        Marshal.FreeHGlobal(__Instance);
                    __Instance = IntPtr.Zero;
                }

                public global::Bgfx.Bgfx.RendererType.Enum Type
                {
                    get
                    {
                        return ((__Internal*)__Instance)->type;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->type = value;
                    }
                }

                public byte* data
                {
                    get
                    {
                        return (byte*) ((__Internal*)__Instance)->data;
                    }
                }

                public uint Size
                {
                    get
                    {
                        return ((__Internal*)__Instance)->size;
                    }

                    set
                    {
                        ((__Internal*)__Instance)->size = value;
                    }
                }
            }

            public __IntPtr __Instance { get; protected set; }

            internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.EmbeddedShader> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::Bgfx.Bgfx.EmbeddedShader>();

            private bool __name_OwnsNativeMemory = false;
            protected bool __ownsNativeInstance;

            internal static EmbeddedShader __CreateInstance(__IntPtr native, bool skipVTables = false)
            {
                return new EmbeddedShader(native.ToPointer(), skipVTables);
            }

            internal static EmbeddedShader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
            {
                if (native == __IntPtr.Zero)
                    return null;
                if (NativeToManagedMap.TryGetValue(native, out var managed))
                    return (EmbeddedShader)managed;
                var result = __CreateInstance(native, skipVTables);
                if (saveInstance)
                    NativeToManagedMap[native] = result;
                return result;
            }

            internal static EmbeddedShader __CreateInstance(__Internal native, bool skipVTables = false)
            {
                return new EmbeddedShader(native, skipVTables);
            }

            private static void* __CopyValue(__Internal native)
            {
                var ret = Marshal.AllocHGlobal(sizeof(__Internal));
                *(__Internal*) ret = native;
                return ret.ToPointer();
            }

            private EmbeddedShader(__Internal native, bool skipVTables = false)
                : this(__CopyValue(native), skipVTables)
            {
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            protected EmbeddedShader(void* native, bool skipVTables = false)
            {
                if (native == null)
                    return;
                __Instance = new __IntPtr(native);
            }

            public EmbeddedShader()
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.EmbeddedShader.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
            }

            public EmbeddedShader(global::Bgfx.Bgfx.EmbeddedShader _0)
            {
                __Instance = Marshal.AllocHGlobal(sizeof(global::Bgfx.Bgfx.EmbeddedShader.__Internal));
                __ownsNativeInstance = true;
                NativeToManagedMap[__Instance] = this;
                *((global::Bgfx.Bgfx.EmbeddedShader.__Internal*) __Instance) = *((global::Bgfx.Bgfx.EmbeddedShader.__Internal*) _0.__Instance);
                if (_0.__name_OwnsNativeMemory)
                    this.Name = _0.Name;
            }

            public void Dispose()
            {
                Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            }

            partial void DisposePartial(bool disposing);

            internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
            {
                if (__Instance == IntPtr.Zero)
                    return;
                NativeToManagedMap.TryRemove(__Instance, out _);
                DisposePartial(disposing);
                if (__name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                if (__ownsNativeInstance)
                    Marshal.FreeHGlobal(__Instance);
                __Instance = IntPtr.Zero;
            }

            public string Name
            {
                get
                {
                    return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->name);
                }

                set
                {
                    if (__name_OwnsNativeMemory)
                        Marshal.FreeHGlobal(((__Internal*)__Instance)->name);
                    __name_OwnsNativeMemory = true;
                    if (value == null)
                    {
                        ((__Internal*)__Instance)->name = global::System.IntPtr.Zero;
                        return;
                    }
                    var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                    var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                    Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                    Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                    ((__Internal*)__Instance)->name = (__IntPtr) __bytePtr0;
                }
            }

            public global::Bgfx.Bgfx.EmbeddedShader.Data[] data
            {
                get
                {
                    global::Bgfx.Bgfx.EmbeddedShader.Data[] __value = null;
                    if (((__Internal*)__Instance)->data != null)
                    {
                        __value = new global::Bgfx.Bgfx.EmbeddedShader.Data[12];
                        for (int i = 0; i < 12; i++)
                            __value[i] = global::Bgfx.Bgfx.EmbeddedShader.Data.__GetOrCreateInstance((IntPtr)((global::Bgfx.Bgfx.EmbeddedShader.Data.__Internal*)&(((__Internal*)__Instance)->data[i * sizeof(global::Bgfx.Bgfx.EmbeddedShader.Data.__Internal)])), true, true);
                    }
                    return __value;
                }

                set
                {
                    if (value != null)
                    {
                        if (value.Length != 12)
                            throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                        for (int i = 0; i < 12; i++)
                            *(global::Bgfx.Bgfx.EmbeddedShader.Data.__Internal*) &((__Internal*)__Instance)->data[i * sizeof(global::Bgfx.Bgfx.EmbeddedShader.Data.__Internal)] = *(global::Bgfx.Bgfx.EmbeddedShader.Data.__Internal*)value[i].__Instance;
                    }
                }
            }
        }

        public unsafe partial class embedded_shader
        {
            public partial struct __Internal
            {
                [SuppressUnmanagedCodeSecurity, DllImport("bgfx-shared-libDebug", EntryPoint = "_ZN4bgfx20createEmbeddedShaderEPKNS_14EmbeddedShaderENS_12RendererType4EnumEPKc", CallingConvention = __CallingConvention.Cdecl)]
                internal static extern global::Bgfx.Bgfx.ShaderHandle.__Internal CreateEmbeddedShader(__IntPtr _es, global::Bgfx.Bgfx.RendererType.Enum _type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _name);
            }

            /// <summary>Create shader from embedded shader data.</summary>
            /// <param name="_es">Pointer to `BGFX_EMBEDDED_SHADER` data.</param>
            /// <param name="_type">Renderer backend type. See: `bgfx::RendererType`</param>
            /// <param name="_name">Shader name.</param>
            /// <remarks>Shader handle.</remarks>
            public static global::Bgfx.Bgfx.ShaderHandle CreateEmbeddedShader(global::Bgfx.Bgfx.EmbeddedShader _es, global::Bgfx.Bgfx.RendererType.Enum _type, string _name)
            {
                var __arg0 = _es is null ? __IntPtr.Zero : _es.__Instance;
                var __ret = __Internal.CreateEmbeddedShader(__arg0, _type, _name);
                return global::Bgfx.Bgfx.ShaderHandle.__CreateInstance(__ret);
            }
        }
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr(__IntPtr __instance);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_string8_ushort_Bgfx_bgfx_Fatal_Enum_string8(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, ushort arg2, global::Bgfx.Bgfx.Fatal.Enum arg3, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_string8_uint_string8_ushort(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, uint arg2, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg3, ushort arg4);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate uint Func_uint___IntPtr_ulong(__IntPtr __instance, ulong arg1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        internal unsafe delegate bool Func_bool___IntPtr_ulong___IntPtr_uint(__IntPtr __instance, ulong arg1, __IntPtr arg2, uint arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_ulong___IntPtr_uint(__IntPtr __instance, ulong arg1, __IntPtr arg2, uint arg3);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_string8_uint_uint_uint___IntPtr_uint_bool(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string arg1, uint arg2, uint arg3, uint arg4, __IntPtr arg5, uint arg6, [MarshalAs(UnmanagedType.I1)] bool arg7);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr_uint_uint_uint_Bgfx_bgfx_TextureFormat_Enum_bool(__IntPtr __instance, uint arg1, uint arg2, uint arg3, global::Bgfx.Bgfx.TextureFormat.Enum arg4, [MarshalAs(UnmanagedType.I1)] bool arg5);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        internal unsafe delegate void Action___IntPtr___IntPtr_uint(__IntPtr __instance, __IntPtr arg1, uint arg2);
    }
}
